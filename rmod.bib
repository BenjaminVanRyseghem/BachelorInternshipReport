@inproceedings{Abde07a,
  annote = {internationalworkshop},
  author = {Hani Abdeen and Ilham Alloui and St\'ephane Ducasse and Damien Pollet and Mathieu Suen},
  booktitle = {FAMOOSr, 1st Workshop on FAMIX and Moose in Reengineering},
  keywords = {moose-pub stefPub},
  title = {Package References Distribution Fingerprint},
  year = {2007}
}



@inproceedings{Abde08b,
  author = {Hani Abdeen and Ilham Alloui and St\'ephane Ducasse and Damien Pollet and Mathieu Suen},
  title = {Package Reference Fingerprint: a Rich and Compact Visualization to Understand Package Relationships},
  booktitle = {European Conference on Software Maintenance and Reengineering (CSMR)},
  annote = {internationalconference},
  pages = {213--222},
  keywords = {moose-pub cook-pub lse-pub},
  misc = {Acceptance rate: 24/87 = 27\%},
  aeresstatus = {aeres08},
  aeres = {ACT},
  rate = {27%},
  selectif = {oui},
  inria = {ADAM},
  publisher = {IEEE Computer Society Press},
  url = {http://rmod.lille.inria.fr/archives/papers/Abde08b-CSMR2008-Fingerprint.pdf},
  location = {Athens, Greece},
  year = {2008},
  abstract = {Object-oriented languages such as Java, Smalltalk, and C++ structure their programs using packages, allowing classes to be organized into named abstractions. Maintainers of large applications need to understand how packages are structured and how they relate to each other, but this task is very complex because packages often have multiple clients and different roles (class container, code ownership...). Cohesion and coupling are still among the most used metrics, because they help identify candidate packages for restructuring; however, they do not help maintainers understand the structure and interrelationships between packages. In this paper, we present the package fingerprint, a 2D visualization of the references made to and from a package. The proposed visualization offers a semantically rich, but compact and zoomable visualization centered on packages. We focus on two views (incoming and outgoing references) that help users understand how the package under analysis is used by the system and how it uses the system. We applied these views on three large case studies: JBoss, Azureus, and ArgoUML.},
  hal = {http://hal.inria.fr/inria-00200869},
  hal-id = {inria-00200869}
}

@inproceedings{Abde09b,
  author = {Hani Abdeen and St\'ephane Ducasse and Houari A. Sahraoui and Ilham Alloui},
  title = {Automatic Package Coupling and Cycle Minimization},
  booktitle = {International Working Conference on Reverse Engineering (WCRE)},
  publisher = {IEEE Computer Society Press},
  address = {Washington, DC, USA},
  misc = {acceptance rate: 20/79 = 25\%},
  pages = {103--112},
  annote = {internationalconference},
  aeres = {ACT},
  x-pays = {CA},
  x-country = {FR},
  x-editorial-board = {yes},
  inriareport = {2009},
  x-proceedings = {yes},
  x-international-audience = {yes},
  aeresstatus = {aeres12},
  rate = {25\%},
  selectif = {oui},
  inria = {RMOD},
  keywords = {moose remoose2 lse-pub cook},
  year = {2009},
  hal = {http://hal.inria.fr/inria-00425417},
  hal-id = {inria-00425417 to recover as lse},
  url = {http://rmod.lille.inria.fr/archives/papers/Abde09b-WCRE2009-AutomaticPackageCoupling.pdf},
  abstract = {Object-oriented (OO) software is usually organized into subsystems using the concepts of package or module. Such modular structure helps applications to evolve when facing new requirements. However, studies show that as soft- ware evolves to meet requirements and environment changes, modularization quality degrades. To help maintainers improve the quality of software modularization we have designed and implemented a heuristic search-based approach for automatically optimizing inter-package connectivity (i.e., dependencies). In this paper, we present our approach and its underlying techniques and algorithm. We show through a case study how it enables maintainers to optimize OO package structure of source code. Our optimization approach is based on Simulated Annealing technique.},
  x-language = {EN}
}

@phdthesis{Abde09c,
  author = {Hani Abdeen},
  title = {Visualizing, Assessing and Re-Modularizing Object-Oriented Architectural Elements},
  school = {Universit\'e de Lille},
  year = {2009},
  annote = {PhD},
  institution = {INRIA},
  inria = {RMOD},
  keywords = {moose remoose2 lse-pub cook},
  aeres = {AP},
  type_rapport = {PhD},
  abstract = {To cope with the complexity of large object-oriented software systems, developers organize classes into subsystems using the concepts of module or package. Such modular structure helps software systems to evolve when facing new requirements. The organization of classes into packages and/or subsystems represents the software modularization. the software modularization usually follows interrelationships between classes. Ideally, packages should to be loosely coupled and cohesive to a certain extent. However, Studies show that as
    software evolves to meet requirements and environment changes, the software modularization gradually drifts
    and looses quality. As a consequence, the software modularization must be maintained. It is thus important to
    understand, to assess and to optimize the organization of packages and their relationships.
    Our claim is that the maintenance of large and complex software modularizations needs approaches that help in:
    (1) understanding package shapes and relationships; (2) assessing the quality of a modularization, as well as
    the quality of a single package within a given modularization; (3) optimizing the quality of an existing
    modularization.
    In this thesis, we concentrate on three research fields: software visualizations, metrics and algorithms. At
    first, we define two visualizations that help maintainers: (1) to understand packages structure, usage and
    relationships; (2) to spot patterns; and (3) to identify misplaced classes and structural anomalies. In
    addition to visualizations, we define a suite of metrics that help in assessing the package design quality
    (i.e., package cohesion and coupling). We also define metrics that assess the quality of a collection of
    inter-dependent packages from different view points, such as the degree of package coupling and cycles.
    Finally, we define a search-based algorithm that automatically reduces package coupling and cycles only by
    moving classes over existing packages. Our optimization approach takes explicitly into account the original
    class organization and package structure. It also allows maintainers to control the optimization process by
    specifying: (1) the maximal number of classes that may change their packages; (2) the classes that are
    candidate for moving and the classes that should not; (3) the packages that are candidate for restructuring
    and the packages that should not; and (4) the maximal number of classes that a given package can entail.
    The approaches presented in this thesis have been applied to real large object-oriented software systems. The
    results we obtained demonstrate the usefulness of our visualizations and metrics; and the effectiveness of our
    optimization algorithm.},
  url = {http://rmod.lille.inria.fr/archives/phd/PhD-2009-Abdeen.pdf},
  hal-id = {tel-00498389 / zi#3ow#h},
  x-language = {EN}
}

@article{Abde10a,
  title = {Package Fingerprint: a visual summary of package interfaces and relationships},
  author = {Hani Abdeen and St\'ephane Ducasse  and Damien Pollet and Ilham Alloui},
  journal = {Information and Software Technology Journal},
  annote = {internationaljournal},
  inriareport = {2010},
  inria = {RMOD},
  pages = {1312-1330},
  keywords = {moose remoose2 lse-pub cook},
  doi = {10.1016/j.infsof.2010.07.005},
  x-editorial-board = {yes},
  impactfactor = {ISI impact factor 1.821 (2010)},
  x-proceedings = {yes},
  volume = {52},
  x-international-audience = {yes},
  aeres = {ACL},
  aeresstatus = {aeres12},
  year = {2010},
  abstract = {Context: Object-oriented languages such as Java, Smalltalk, and C++ structure their programs using packages. Maintainers of large systems need to understand how packages relate to each other, but this task is complex because packages often have multiple clients and play different roles (class container, code ownership. . . ). Several approaches have been proposed, among which the use of cohesion and coupling metrics. Such metrics help identify candidate packages for restructuring; however, they do not help maintainers actually understand the structure and interrelation- ships between packages.
Objectives: In this paper, we use pre-attentive processing as the basis for package visualization and see to what extent it could be used in package understanding.
Method: We present the package fingerprint, a 2D visualization of the references made to and from a package. The proposed visualization offers a semantically rich, but compact and zoomable views centered on packages. We focus on two views (incoming and outgoing references) that help users understand how the package under analysis is used by the system and how it uses the system.
Results: We applied these views on four large systems: Squeak, JBoss, Azureus, and ArgoUML. We obtained several interesting results, among which, the identification of a set of recurring visual patterns that help maintainers: (a) more easily identify the role of and the way a package is used within the system (e.g., the package under analysis provides a set of layered services), and, (b) detect either problematic situations (e.g., a single package that groups together a large number of basic services) or opportunities for better package restructuring (e.g., removing cyclic dependencies among packages). The visualization generally scaled well and the detection of different patterns was always possible.
Conclusion: The proposed visualizations and patterns proved to be useful in understanding and maintaining the different systems we addressed. To generalize to other contexts and systems, a real user study is required.},
  url = {http://rmod.lille.inria.fr/archives/papers/Abde10a-IST-Official-packageFingerprints.pdf},
  secondurl = {http://rmod.lille.inria.fr/archives/papers/Abde10a-IST-packageFingerprints.pdf},
  hal-id = {inria-00531496}
}

@inproceedings{Anqu01a,
 author = {Anquetil, Nicolas},
 title = {Characterizing the Informal Knowledge Contained in Systems},
 booktitle = {WCRE '01: Proceedings of the Eighth Working Conference on Reverse Engineering (WCRE'01)},
 year = {2001},
 isbn = {0-7695-1303-4},
 pages = {166},
 publisher = {IEEE Computer Society},
 address = {Washington, DC, USA},
  annote = {internationalconference},
 aeres = {ACT},
 selectif = {oui},
 labo = {non},
 x-editorial-board = {yes},
 x-international-audience = {yes}
}

@article{Anqu03a,
  author = {Nicolas Anquetil and Timothy Lethbridge},
  title = {Comparative study of clustering algorithms and abstract representations for software remodularization},
  annote = {internationaljournal},
  journal = {IEE Proceedings - Software},
  volume = {150},
  number = {3},
  year = {2003},
  pages = {185-201},
  annote = {internationaljournal},
 aeres = {ACL},
 selectif = {oui},
 labo = {non},
 x-editorial-board = {yes},
 x-international-audience = {yes},
 x-pays = {CA}
}

@inproceedings{Anqu03b,
  author    = {Nicolas Anquetil and
               K{\'a}thia Mar\c{c}al de Oliveira and
               M{\'a}rcio Greyck Batista Dias and
               Marcelo Ramal and
               Ricardo de Moura Meneses},
  title     = {Knowledge for Software Maintenance},
  booktitle = {Proceedings of the Fifteenth International Conference on
               Software Engineering {\&} Knowledge Engineering (SEKE'2003)},
  year      = {2003},
  pages     = {61-68},
  annote = {internationalconference},
 aeres = {ACT},
 selectif = {oui},
 labo = {non},
 x-editorial-board = {yes},
 x-international-audience = {yes},
 x-pays = {BR}
}

@article{Anqu06a,
  author = {Souza, Sergio Cozzetti B. de and Anquetil, Nicolas and Oliveira, K\'{a}thia M. de},
  title = {Which documentation for software maintenance?},
  journal = {Journal of the Brazilian Computer Society},
  issn = {0104-6500},
  year = {2006},
  pages = {31--44},
  aeres	       = {ACL},
  impactfactor = {},
  labo         = {hors},
  inria	       = {hors},
  selectif     = {oui},
  x-editorial-board = {yes},
  x-proceedings = {no},
  x-international-audience = {yes},
  x-language = {EN}
}

@article{Anqu07a,
 author = {Anquetil, Nicolas and de Oliveira, K\'{a}thia M. and de Sousa, Kleiber D. and Batista Dias, M\'{a}rcio G.},
 title = {Software maintenance seen as a knowledge management issue},
 journal = {Inf. Softw. Technol.},
 volume = {49},
 number = {5},
 year = {2007},
 issn = {0950-5849},
 pages = {515--529},
 doi = {10.1016/j.infsof.2006.07.007},
 publisher = {Butterworth-Heinemann},
 address = {Newton, MA, USA},
 annote = {internationaljournal},
 aeres = {ACL},
 selectif = {oui},
 labo = {non},
 x-editorial-board = {yes},
 x-international-audience = {yes},
 x-pays = {BR}
}

@article{Anqu10a,
 author = {Anquetil, Nicolas and Kulesza, Uir\'{a} and Mitschke, Ralf and Moreira, Ana and Royer, Jean-Claude and Rummler, Andreas and Sousa, Andr\'{e}},
 title = {A model-driven traceability framework for software product lines},
 journal = {Softw. Syst. Model.},
 volume = {9},
 number = {4},
 year = {2010},
 issn = {1619-1366},
 pages = {427--451},
 doi = {10.1007/s10270-009-0120-9},
 publisher = {Springer-Verlag New York, Inc.},
 address = {Secaucus, NJ, USA},
 annote = {internationaljournal},
 aeresstatus= {aeres12},
 aeres = {ACL},
 selectif = {oui},
 labo = {non},
 x-editorial-board = {yes},
 x-international-audience = {yes},
 x-pays = {DE,PT,BR},
 hal-id = {tobedone2010}
}

@inproceedings{Anqu97a,
  author = {Nicolas Anquetil and Timothy Lethbridge},
  booktitle = {Proceedings of CASCON '97},
  annote = {internationalconference},
  keywords = {clustering},
  month = nov,
  pages = {184--195},
  title = {File {Clustering} using {Naming} {Conventions} for {Legacy} {Systems}},
  year = {1997},
 aeres = {ACT},
 selectif = {oui},
 labo = {non},
 x-editorial-board = {yes},
 x-international-audience = {yes},
 x-pays = {CA}
}

@inproceedings{Anqu98a,
  author = {Nicolas Anquetil and Timothy Lethbridge},
  booktitle = {Conference of the Centre for Advanced Studies on Collaborative research (CASCON'98)},
  annote = {internationalconference},
  pages = {213--222},
  publisher = {IBM Press},
  title = {Assessing the relevance of identifier names in a legacy software system},
  year = {1998},
 aeres = {ACT},
 selectif = {oui},
 labo = {non},
 x-editorial-board = {yes},
 x-international-audience = {yes},
 x-pays = {CA}
}

@inproceedings{Anqu98b,
  author = {Nicolas Anquetil and Timothy Lethbridge},
  booktitle = {International Conference on Software Engineering (ICSE 1998)},
  annote = {internationalconference},
  pages = {84--93},
  title = {Extracting Concepts from File Names; a New File Clustering Criterion},
  year = {1998},
 aeres = {ACT},
 selectif = {oui},
 labo = {non},
 x-editorial-board = {yes},
 x-international-audience = {yes},
 x-pays = {CA}
}

@article{Anqu98c,
 author = {Anquetil, Nicolas and Vaucher, Jean},
 title = {Expressing opposition in the object model, first step towards negation},
 journal = {SIGPLAN Notices},
 volume = {33},
 number = {1},
 year = {1998},
 issn = {0362-1340},
 pages = {48--55},
 doi = {10.1145/609742.609749},
 publisher = {ACM},
 address = {New York, NY, USA},
 annote = {internationaljournal},
 aeres = {ASCL},
 selectif = {non},
 labo = {non},
 x-editorial-board = {no},
 x-international-audience = {yes},
 x-pays = {CA}
}

@inproceedings{Anqu99a,
  author = {Nicolas Anquetil and Timothy Lethbridge},
  booktitle = {Proceedings of WCRE '99 (6th Working Conference on Reverse Engineering)},
   annote = {internationalconference},
  keywords = {clustering},
  pages = {235--255},
  title = {Experiments with {Clustering} as a {Software} {Remodularization} {Method}},
  year = {1999},
 aeres = {ACT},
 selectif = {oui},
 labo = {non},
 x-editorial-board = {yes},
 x-international-audience = {yes},
 x-pays = {CA}
}

@article{Anqu99b,
  author = {Nicolas Anquetil and Timothy C. Lethbridge},
  journal = {Journal of Software Maintenance: Research and Practice},
  pages = {201--21},
  annote = {internationaljournal},
  title = {Recovering Software Architecture from the Names of Source Files},
  misc = {5 Year ISI impact factor 1.523 (2010)},
  impactfactor = {5 Year ISI impact factor 1.523 (2010)},
  volume = {11},
  year = {1999},
 aeres = {ACT},
 selectif = {oui},
 labo = {non},
 x-editorial-board = {yes},
 x-international-audience = {yes},
 x-pays = {CA}
}

@booklet{Ardi95b,
  annote = {lectures},
  author = {Laurent Arditi and St\'ephane Ducasse},
  keywords = {stefPub},
  note = {support de cours de Deug SM-PE et Mass, 120 pages},
  title = {Une premi\`ere approche fonctionnelle et r\'ecursive de la programmation},
  year = {1995}
}

@book{Ardi96a,
  address = {Paris},
  annote = {book},
  author = {Laurent Arditi and St\'ephane Ducasse},
  keywords = {stefPub scglib},
  month = apr,
  note = {238 pages, Pr\'eface de G\'erard Huet},
  publisher = {Eyrolles},
  title = {La programmation: une approche fonctionelle et r\'ecursive avec Scheme},
  isbn = {2-212-08915-5},
  year = {1996}
}

@inproceedings{Ardi97a,
  abstract = {Dans cet article, nous pr\'esentons une exp\'erience d'enseignement de l'informatique en milieu aride: volume horaire faible, faible coefficient, \'etudiants peu motiv\'es. Dans ce contexte d\'efavorable, nous avons choisi de privil\`egier un concept, la r\'ecursivit\'e dans le cadre de la programmation fonctionnelle, plut\^ot qu'un langage.  Ce choix nous a conduit \`a consid\`erer le langage Scheme pour sa simplicit\'e. Nous d\'ecrivons ici notre cours, les probl\`emes que nous avons rencontr\'es et les solutions que nous avons choisies.},
  annote = {nationalconference},
  author = {Laurent Arditi and St\'ephane Ducasse},
  booktitle = {Actes des Journ\'ees Fran\c{c}aises des Langages Applicatifs (JFLA '97)},
  keywords = {stefPub snf97},
  pages = {209--228},
  title = {Scheme: un langage applicatif pour l'enseignement de l'informatique en milieu aride},
  url = {http://rmod.lille.inria.fr/archives/papers/Ardi97a-JFLA07-SchemeTeaching.pdf},
  url = {http://scg.unibe.ch/archive/papers/Ardi97aSchemeTeaching.pdf},
  hal-id = {inria-00533051},
  year = {1997}
}

@inproceedings{Arev03c,
  abstract = {Understanding the internal workings of classes is a key prerequisite to maintaining an object-oriented software system. Unfortunately, classical editing and browsing tools offer mainly linear and textual views of classes and their implementation. These views fail to expose the semantic relationships between the internal parts of a class. We propose XRay views --a technique based on Concept Analysis-- which reveal the internal relationships between groups of methods and attributes of a class. XRay views are composed out of elementary collaborations between attributes and methods, and help the engineer to build a mental model of how a class works internally. In this paper we present XRay views, and illustrate the approach by applying it on the Smalltalk class UIBuilder.},
  annote = {internationalconference},
  author = {Gabriela Ar{\'e}valo and St\'ephane Ducasse and Oscar Nierstrasz},
  booktitle = {Proceedings of 18th Conference on Automated Software Engineering (ASE'03)},
  cvs = {ConAnASE03XRayViews},
  doi = {10.1109/ASE.2003.1240318},
  keywords = {recast03 scg-pub stefPub moose-pub arevalo jb04},
  month = oct,
  note = {Short paper},
  pages = {267--270},
  publisher = {IEEE Computer Society},
  title = {{X-Ray} Views: Understanding the Internals of Classes},
  url = {http://rmod.lille.inria.fr/archives/papers/Arev03c-ASE03-XRayViews.pdf},
  secondurl = {http://scg.unibe.ch/archive/papers/Arev03cASE03XRayViews.pdf},
  abstract = {Understanding the internal workings of classes is a key prerequisite to maintaining an object-oriented software system. Unfortunately, classical editing and browsing tools offer mainly linear and textual views of classes and their implementation. These views fail to expose the semantic relationships between the internal parts of a class. We propose XRay views -- a technique based on Concept Analysis --  which reveal the internal relationships between groups of methods and attributes of a class. XRay views are com- posed out of elementary collaborations between attributes and methods, and help the engineer to build a mental model of how a class works internally. In this paper we present XRay views, and illustrate the approach by applying it on the Smalltalk class UIBuilder.},
  hal-id={inria-00533054},
  year = {2003}
}

@inproceedings{Arev03d,
  abstract = {Understanding the internal workings of classes is a key prerequisite to maintaining an object-oriented software system. Unfortunately, classical editing and browsing tools offer mainly linear and textual views of classes and their implementation. These views fail to expose the semantic relationships between the internal parts of a class. We propose XRay views --a technique based on Concept Analysis-- which reveal the internal relationships between groups of methods and attributes of a class. XRay views are composed out of elementary collaborations between attributes and methods and help the engineer to build a mental model of how a class works internally. In this paper we present XRay views, and illustrate the approach by applying it to three Smalltalk classes: OrderedCollection, Scanner, and UIBuilder.},
  annote = {internationalworkshop},
  author = {Gabriela Ar{\'e}valo and St\'ephane Ducasse and Oscar Nierstrasz},
  booktitle = {Proceedings of 2nd International Workshop on MASPEGHI 2003 (ASE 2003)},
  cvs = {ConAnMASPEGHI03XRayViews},
  keywords = {snf04 scg-pub skip-doi stefPub arevalo jb04 moose-pub},
  month = oct,
  pages = {9--18},
  publisher = {CRIM --- University of Montreal (Canada)},
  title = {Understanding Classes using {X-Ray} Views},
  url = {http://scg.unibe.ch/archive/papers/Arev03dMASPEGHI03XRayViews.pdf},
  year = {2003}
}

@inproceedings{Arev05b,
  abstract = {Object-oriented applications are difficult to extend and maintain, due to the presence of implicit dependencies in the inheritance hierarchy. Although these dependencies often correspond to well-known schemas, such as hook and template methods, new unanticipated dependency schemas occur in practice, and can consequently be hard to recognize and detect. To tackle this problem, we have applied Concept Analysis to automatically detect recurring dependency schemas in class hierarchies used in object-oriented applications. In this paper we describe our mapping of OO dependencies to the formal framework of Concept Analysis, we apply our approach to a non-trivial case study, and we report on the kinds of dependencies that are uncovered with this technique. As a result, we show how the discovered dependency schemas correspond not only to good design practices, but also to bad smells in design.},
  aeres = {ACT},
  aeresstatus = {aeres08},
  annote = {internationalconference},
  author = {Gabriela Ar{\'e}valo and St\'ephane Ducasse and Oscar Nierstrasz},
  booktitle = {Proceedings of 9th European Conference on Software Maintenance and Reengineering (CSMR'05)},
  cvs = {ConAnCSMR05ClassHierarchies},
  doi = {10.1109/CSMR.2005.24},
  impactfactor = {hors},
  keywords = {scg-pub arevalo jb05 recast05 stefPub moose-pub},
  location = {Manchester, United Kingdom},
  misc = {acceptance rate: 33/81 = 41\%},
  accepttotal = {81},
  acceptnum = {33},
  month = mar,
  pages = {62--71},
  publisher = {IEEE Computer Society},
  rate = {41%},
  selectif = {non},
  title = {Discovering Unanticipated Dependency Schemas in Class Hierarchies},
  abstract = {Object-oriented applications are difficult to extend and maintain, due to the presence of implicit dependencies in the inheritance hierarchy. Although these dependencies of- ten correspond to well-known schemas, such as hook and template methods, new unanticipated dependency schemas occur in practice, and can consequently be hard to recognize and detect. To tackle this problem, we have applied Concept Analysis to automatically detect recurring dependency schemas in class hierarchies used in object-oriented applications. In this paper we describe our mapping of OO dependencies to the formal framework of Concept Analysis, we apply our approach to a non-trivial case study, and we report on the kinds of dependencies that are uncovered with this technique. As a result, we show how the discovered dependency schemas correspond not only to good design practices, but also to "bad smells" in design.},
  hal-id = {inria-00533057},
  url = {http://rmod.lille.inria.fr/archives/papers/Arev05b-CSMR05-ClassHierarchies.pdf},
  secondurl = {http://scg.unibe.ch/archive/papers/Arev05bCSMR05ClassHierarchies.pdf},
  year = {2005}
}

@inproceedings{Arev05c,
  abstract = {A key difficulty in the maintenance and evolution of complex software systems is to recognize and understand the implicit dependencies that define contracts that must be respected by changes to the software. Formal Concept Analysis is a well-established technique for identifying groups of elements with common sets of properties. We have successfully applied FCA to complex software systems in order to automatically discover a variety of different kinds of implicit, recurring sets of dependencies amongst design artifacts. In this paper we describe our approach, outline three case studies, and draw various lessons from our experiences. In particular, we discuss how our approach is applied iteratively in order to draw the maximum benefit offered by FCA.},
  aeres = {ACT},
  aeresstatus = {aeres08},
  annote = {internationalconference},
  author = {Gabriela Ar{\'e}valo and St\'ephane Ducasse and Oscar Nierstrasz},
  booktitle = {Proceedings of 3rd International Conference on Formal Concept Analysis (ICFCA '05)},
  cvs = {ConAnICFCA05LessonsLearned},
  doi = {10.1007/b105806},
  impactfactor = {hors},
  keywords = {scg-pub jb05 recast05 arevalo stefPub},
  location = {Lens, France},
  month = feb,
  pages = {95--112},
  publisher = {Springer Verlag},
  selectif = {non},
  series = {LNAI (Lecture Notes in Artificial Intelligence)},
  title = {Lessons Learned in Applying Formal Concept Analysis},
  url = {http://rmod.lille.inria.fr/archives/papers/Arev05c-ICFCA05-LessonsLearned.pdf},
  secondurl = {http://scg.unibe.ch/archive/papers/Arev05cICFCA05LessonsLearned.pdf},
  volume = {3403},
  hal-id = {inria-00533445},
  year = {2005}
}

@inproceedings{Arev06a,
  abstract = {Designing class models is usually an iterative process to detect how to express, for a specific domain, the adequate concepts and their relationships. During those iterations, the abstraction of concepts and relationships is an important step. In this paper, we propose to automate this abstraction process using techniques based on Formal Concept Analysis in a model-driven context. Using UML 2.0 class diagrams as modeling language for class models, in this proposal we show how our model-driven approach enables parameterization, tracing and generalization to any metamodel to express class models.},
  author = {Gabriela Ar\'evalo and Jean-R\'emy Falleri and Marianne Huchard and Cl\'ementine Nebut},
  booktitle = {{MoDELS} 2006},
  editor = {Oscar Nierstrasz; Jhon Whittle; David Harel; Gianna Reggio},
  isbn = {978-3-540-45772-5},
  keywords = {UML, model transformation, refactoring, formal concept analysis, relational concept analysis},
  month = oct,
  pages = {513-527},
  publisher = {Springer Verlag},
  series = {{LNCS} ({L}ecture {N}otes in {C}omputer {S}cience)},
  title = {Building Abstractions in Class Models: Formal Concept Analysis in a Model-Driven Approach},
  volume = {4199},
  year = {2006}
}

@article{Arev10a,
  author = {Gabriela Ar\'evalo and St\'ephane Ducasse and Silvia Gordillo and Oscar Nierstrasz},
  month = dec,
  annote = {internationaljournal},
  title = {Generating a catalog of unanticipated schemas in class hierarchies using Formal Concept Analysis},
  journal = {Information and Software Technology},
  volume = {52},
  pages = {1167-1187},
  aeres = {ACL},
  impactfactor = {ISI impact factor 1.821 (2010)},
  misc = {ISI impact factor 1.821 (2010)},
  inriareport = {2010},
  inria = {RMOD},
  x-editorial-board = {yes},
  x-proceedings = {yes},
  x-international-audience = {yes},
  keywords = {moose lse-pub cook},
  aeresstatus = {aeres12},
  issn = {0950-5849},
  doi = {10.1016/j.infsof.2010.05.010},
  hal-id = {inria-00531498},
  year = {2010},
  x-pays = {AR,CH},
  url =  {http://rmod.lille.inria.fr/archives/papers/Arev10a-IST-generating_a_catalog.pdf},
  secondurl = {http://rmod.lille.inria.fr/archives/papers/Arev10a-IST-Official-generating_a_catalog.pdf}
}

@inproceedings{Arna10a,
  title = {Read-Only Execution for Dynamic Languages},
  author = {Jean-Baptiste Arnaud and Marcus Denker and St\'ephane Ducasse and Damien Pollet and Alexandre Bergel and  Mathieu Suen},
  booktitle = {Proceedings of the 48th International Conference Objects, Models, Components, Patterns (TOOLS-Europe'10)},
  year = {2010},
  annote = {internationalconference},
  keywords = {tools10  lse-pub marcusdenker},
  month = jun,
  inria = {RMOD},
  inriareport = {2010},
  x-editorial-board = {yes},
  x-proceedings = {yes},
  x-international-audience = {yes},
  x-country = {FR},
  x-language = {EN},
  address = {Malaga, Spain},
  url = {http://rmod.lille.inria.fr/archives/papers/Arna10a-Tools2010-ReadOnlyExecutionForDynamicLanguages.pdf},
  abstract = {Supporting read-only and side effect free execution has been the focus of a large body of work in the area of statically typed programming languages. Read-onlyness in dynamically typed languages is difficult to achieve because of the absence of a type checking phase and the support of an open-world assumption in which code can be constantly added and modified. To address this issue, we propose Dynamic Read-Only references (DRO) that provide a view on an object where this object and its object graph are protected from modification. The read- only view dynamically propagates to aggregated objects, without changing the object graph itself; it acts as a read-only view of complex data structures, without making them read-only globally. We implement dynamic read-only references by using smart object proxies that lazily propagate the read-only view, following the object graph and driven by control flow and applied them to realize side-effect free assertions.},
  hal-id = {inria-00498377 / 7a#ndah},
  misc = {25%},
  rate = {25%},
  hal = {http://hal.archives-ouvertes.fr/inria-00498377/fr/}
}

@techreport{Balm09a,
  author = {Fran{\c c}oise Balmas and Alexandre Bergel and Simon Denier and St\'ephane Ducasse and Jannik Laval and Karine Mordal-Manet and Hani Abdeen and Fabrice Bellingard},
  title = {Software metric for Java and C++ practices},
  keywords = {squale-pub lse-pub deliverable11},
  annote = {technicalReport},
  institution = {INRIA Lille Nord Europe},
  type_rapport = {Rapport technique},
  abstract = {No abstract},
  year = {2009},
  inria = {RMOD},
  inriareport = {2009},
  hal-id = {inria-00533617}
}

@techreport{Balm09c,
  author = {Fran{\c c}oise Balmas and Fabrice Bellingard and Simon Denier and St\'ephane Ducasse and Jannik Laval and Karine Mordal-Manet},
  title = {Practices in the Squale Quality Model (Squale Deliverable 1.3)},
  keywords = {squale-pub lse-pub deliverable13},
  institution = {INRIA},
  inria = {RMOD},
  inriareport = {2009},
  year = {2009},
  aeres = {AP},
  type_rapport = {Rapport technique},
  abstract = {No abstract},
  x-language = {EN},
  hal-id = {inria-00533654}
}

@inproceedings{Berg03a,
  abstract = {Classical module systems support well the modular development of applications but do not offer the ability to add or replace a method in a class that is not defined in that module. On the other hand, languages that support method addition and replacement do not provide a modular view of applications, and their changes have a global impact. The result is a gap between module systems for object-oriented languages on one hand, and the very desirable feature of method addition and replacement on the other hand. To solve these problems we present classboxes, a module system for object-oriented languages that provides method addition and replacement. Moreover, the changes made by a classbox are only visible to that classbox (or classboxes that import it), a feature we call local rebinding. To validate the model, we have implemented it in the Squeak Smalltalk environment, and performed experiments modularising code.},
  aeres = {ACT},
  aeresstatus = {aeres08},
  annote = {internationalconference},
  author = {Alexandre Bergel and St\'ephane Ducasse and Roel Wuyts},
  booktitle = {Proceedings of Joint Modular Languages Conference (JMLC'03)},
  doi = {10.1007/b12023},
  inria = {hors},
  isbn = {978-3-540-40796-6},
  keywords = {module classbox},
  misc = {Best Paper Award},
  pages = {122--131},
  publisher = {Springer-Verlag},
  selectif = {non},
  series = {LNCS},
  title = {Classboxes: A Minimal Module Model Supporting Local Rebinding},
  secondurl = {http://scg.unibe.ch/archive/papers/Berg03aClassboxes.pdf},
  url = {http://rmod.lille.inria.fr/archives/papers/Berg03a-JLMC03-Classboxes.pdf},
  volume = {2789},
  hal-id = {inria-00533446},
  year = {2003}
}

@inproceedings{Berg03b,
  abstract = {Classical module systems support well the modular development of applications but do not offer the ability to add or replace a method in a class that is not defined in that module. On the other hand, languages that support method addition and replacement do not provide a modular view of applications, and their changes have a global impact. The result is a gap between module systems for object-oriented languages on one hand, and the very desirable feature of method addition and replacement on the other hand. To solve these problems we present classboxes, a module system for object-oriented languages that provides method addition and replacement. Moreover, the changes made by a classbox are only visible to that classbox (or classboxes that import it), a feature we call local rebinding. To validate the model, we have implemented it in the Squeak Smalltalk environment, and performed experiments modularising code.},
  aeres = {ACT},
  aeresstatus = {aeres05},
  annote = {internationalworkshop},
  author = {Alexandre Bergel and St\'ephane Ducasse and Roel Wuyts},
  booktitle = {Proceedings of the ECOOP '03 Workshop on Object-oriented Language Engineering for the Post-Java Era},
  inria = {hors},
  keywords = {snf03 scg-pub skip-doi jb03 stefPub alexandrePub module classbox alexPub},
  month = jul,
  selectif = {non},
  title = {The {Classbox} Module System},
  url = {http://scg.unibe.ch/archive/papers/Berg03bClassboxes.pdf},
  year = {2003}
}

@techreport{Berg04a,
  abstract = {A class extension is a method that is defined in a module, but whose class is defined elsewhere. Class extensions offer a convenient way to incrementally modify existing classes when subclassing is inappropriate. Unfortunately existing approaches suffer from various limitations. Either class extensions have a global impact, with possibly negative effects for unexpected clients, or they have a purely local impact, with negative results for collaborating clients. Furthermore, conflicting class extensions are either disallowed, or resolved by linearization, with consequent negative effects.  To solve these problems we present classboxes, a module system for object-oriented languages that provides for method addition and replacement.  Moreover, the changes made by a classbox are only visible to that classbox (or classboxes that import it), a feature we call local rebinding. To validate the model we have implemented it in the Squeak Smalltalk environment, and performed benchmarks.},
  address = {Universit\"at Bern, Switzerland},
  aeres = {AP},
  aeresstatus = {aeres05},
  annote = {report notrefereed technicalReport},
  author = {Alexandre Bergel and St\'ephane Ducasse and Oscar Nierstrasz and Roel Wuyts},
  classification = {D.1.5 Object-oriented Programming; D.3.3 Language Constructs and Features},
  general_terms = {Inheritance, Mixins, Multiple Inheritance, Traits, Reuse, Smalltalk},
  inria = {hors},
  institution = {Institut f\"ur Informatik},
  keywords = {snf-redundant scg-pub skip-doi jb04 snf04 stefPub alexPub alexandrePub},
  misc = {ClassboxTR04},
  month = jun,
  number = {IAM-04-003},
  selectif = {non},
  title = {Classboxes: Controlling Visibility of Class Extensions},
  type = {Technical Report},
  url = {http://scg.unibe.ch/archive/papers/Berg04aIAM-04-003.pdf},
  year = {2004},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Berg04aIAM-04-003.pdf}
}

@inproceedings{Berg04c,
  abstract = {With prototype-based languages, concretization and abstraction are unified into a single concept a prototype. Prototype-based languages are based on a simple set of principles: object-centered representation, dynamic reshape of objects, cloning and possibly message delegation. However, they all differ in the interpretation and combination of these principles. Therefore there is a need to compare and understand. In this paper we present Prototalk, a research and teaching vehicle to understand, implement and compare prototype-based languages. Prototalk is a framework that offers a predefined set of language data structures and mechanisms that can be composed and extended to generate various prototype-based language interpreters. It presents a classification of languages based on different mechanisms in an operational manner.},
  aeres = {ACT},
  aeresstatus = {aeres05},
  annote = {internationalconference},
  author = {Alexandre Bergel and Christophe Dony and St\'ephane Ducasse},
  booktitle = {Proceedings of 12th International Smalltalk Conference (ISC'04)},
  cvs = {PrototalkESUG04},
  inria = {hors},
  keywords = {scg-pub skip-doi jb05 snf04 stefPub alexPub alexandrePub noWorkshop},
  month = sep,
  pages = {107--130},
  selectif = {non},
  title = {Prototalk: an Environment for Teaching, Understanding, Designing and Prototyping Object-Oriented Languages},
  url = {http://rmod.lille.inria.fr/archives/papers/Berg04c-ISC04-prototalk.pdf},
  secondurl = {http://scg.unibe.ch/archive/papers/Berg04cprototalk.pdf},
  hal-id = {inria-00533452},
  year = {2004}
}

@article{Berg05a,
  abstract = {A class extension is a method that is defined in a module, but whose class is
defined elsewhere. Class extensions offer a convenient way to incrementally modify existing
classes when subclassing is inappropriate. Unfortunately existing approaches suffer from
various limitations. Either class extensions have a global impact, with possibly negative
effects for unexpected clients, or they have a purely local impact, with negative results
for collaborating clients. Furthermore, conflicting class extensions are either disallowed,
or resolved by linearization, with consequent negative effects. To solve these problems we
present classboxes, a module system for object-oriented languages that provides for method
addition and replacement. Moreover, the changes made by a classbox are only visible to that
classbox (or classboxes that import it), a feature we call local rebinding. To validate the
model we have implemented it in the Squeak Smalltalk environment, and performed
benchmarks.},
  aeres = {ACL},
  aeresstatus = {aeres08},
  annote = {internationaljournal},
  author = {Alexandre Bergel and St\'ephane Ducasse and Oscar Nierstrasz and Roel Wuyts},
  cvs = {ClassboxESUG04},
  doi = {10.1016/j.cl.2004.11.002},
  impactfactor = {5 Year ISI impact factor 0.698 (2010)},
  misc = {5 Year ISI impact factor 0.698 (2010)},
  inria = {hors},
  journal = {Journal of Computer Languages, Systems and Structures},
  keywords = {scg-pub snf-actsc jb05 classbox snf05 stefPub},
  month = dec,
  number = {3-4},
  pages = {107--126},
  publisher = {Elsevier},
  selectif = {non},
  title = {Classboxes: Controlling Visibility of Class Extensions},
  url = {http://rmod.lille.inria.fr/archives/papers/Berg05a-CompLangESUG04-classboxesJournal.pdf},
  secondurl = {http://scg.unibe.ch/archive/papers/Berg05aclassboxesJournal.pdf},
  volume = {31},
  hal-id = {inria-00533458},
  year = {2005}
}

@inproceedings{Berg05b,
  abstract = {Unanticipated changes to complex software systems can introduce anomalies such as duplicated code, suboptimal inheritance relationships and a proliferation of run-time downcasts. Refactoring to eliminate these anomalies may not be an option, at least in certain stages of software evolution.  Classboxes are modules that restrict the visibility of changes to selected clients only, thereby offering more freedom in the way unanticipated changes may be implemented, and thus reducing the need for convoluted design anomalies. In this paper we demonstrate how classboxes can be implemented in statically-typed languages like {Java}. We also present an extended case study of Swing, a {Java} GUI package built on top of AWT, and we document the ensuing anomalies that Swing introduces. We show how Classbox/J, a prototype implementation of classboxes for {Java}, is used to provide a cleaner implementation of Swing using local refinement rather than subclassing.},
  address = {New York, NY, USA},
  aeres = {ACT},
  aeresstatus = {aeres08},
  annote = {internationalconference topconference},
  author = {Alexandre Bergel and St\'ephane Ducasse and Oscar Nierstrasz},
  booktitle = {Proceedings of 20th International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA'05)},
  doi = {10.1145/1094811.1094826},
  inria = {hors},
  keywords = {snf05 stefPub alexPub snf06 jb06 scg-pub},
  misc = {acceptance rate: 25/142 = 17\%},
  accepttotal = {142},
  acceptnum = {25},
  pages = {177--189},
  publisher = {ACM Press},
  rate = {17%},
  selectif = {oui},
  hal-id = {inria-00533461},
  title = {Classbox/{J}: Controlling the Scope of Change in {Java}},
  url = {http://rmod.lille.inria.fr/archives/papers/Berg05b-OOSPLA05-classboxJ},
  secondurl = {http://scg.unibe.ch/archive/papers/Berg05bclassboxjOOPSLA.pdf},
  year = {2005}
}

@article{Berg05c,
  abstract = {Each object-oriented programming language proposes various grouping
mechanisms to bundle interacting classes (i.e., packages, modules, selector namespaces,
etc). To understand such diversity and to compare the different approaches, a common
foundation is needed. As far as we are aware of, no major attempt that would go in that
direction has been realized. In this paper we present a simple module calculus together
with a set of operators for modeling the composition semantics of different grouping
mechanisms. Using this module calculus we are able to express the semantics of {Java}
packages, C# namespaces, Ruby modules, selector namespaces, gbeta classes, classboxes,
MZScheme units, and MixJuice modules. This calculus supports the identification of system
families sharing similar characteristics. In addition it provides a uniform way to
represent and analyze fine-grained module semantics.},
  aeres = {ACL},
  aeresstatus = {aeres08},
  annote = {internationaljournal},
  author = {Alexandre Bergel and St\'ephane Ducasse and Oscar Nierstrasz},
  cvs = {ModuleAnalysisJUCS05},
  impactfactor = {0.337, SCI},
  inria = {hors},
  journal = {Journal of Universal Computer Science},
  keywords = {scg-pub skip-doi jb06 classbox snf06 stefPub alexPub listic},
  misc = {SCI impact factor 0.337},
  month = nov,
  number = {10},
  pages = {1613--1644},
  selectif = {non},
  title = {Analyzing Module Diversity},
  url = {http://www.jucs.org/jucs_11_10/analyzing_module_diversity
                  http://scg.unibe.ch/archive/papers/Berg05cModuleDiversity.pdf},
  volume = {11},
  year = {2005}
}

@inproceedings{Berg05d,
  abstract = {On the one hand, traits are a powerful way of structuring classes. Traits
support the reuse of method collections over several classes. However, traits cannot be
used when specifying unanticipated changes to an application. On the other hand, classboxes
are a new module system that supports the local redefinition of classes: a collection of
classes can be locally extended with variables and/or methods and the existing clients do
not get impacted by changes. However, an extension applied to a class by a classbox cannot
be reused for other classes. This paper describes how combining Traits and Classboxes
supports the safe introduction of crosscutting collaborations: safe because the existing
clients of the classes do not get impacted, crosscutting because collaborations between
several classes can be put in place in a unanticipated manner. In the resulting system, a
collaboration is represented by a classbox and a role by a trait.},
  address = {Erfurt, Germany},
  aeres = {ACT},
  aeresstatus = {aeres08},
  annote = {nationalconference},
  author = {Alexandre Bergel and St\'ephane Ducasse},
  booktitle = {{Net}.{ObjectDays} (NODE'05)},
  inria = {hors},
  keywords = {snf05 jb06 scg-pub skip-doi alexPub stefPub listic},
  month = sep,
  pages = {61--75},
  selectif = {non},
  title = {Supporting Unanticipated Changes with {Traits} and {Classboxes}},
  url = {http://scg.unibe.ch/archive/papers/Berg05dTraitsClassbox.pdf},
  year = {2005}
}

@article{Berg05e,
  abstract = {Atomically introducing changes to a group of classes is a challenging task.
In addition, certain applications require that changes be applied dynamically without
shutting down and restarting the application. In this paper we present an extension of
classboxes to make them dynamic. A classbox is a kind of module that supports class
extension and instance variable addition. Class extensions and definitions defined in a
classbox represent an aspect. In addition, with classboxes, aspects are dynamically applied
to, removed from hot- in a system. Such aspects may crosscut a large number of classes
which are extended by adding or redefining existing methods and adding new instance
variables. Finally the aspects are scoped i.e., they are local to the classboxes that
define them.},
  aeres = {ACT},
  annote = {nationaljournal},
  author = {Alexandre Bergel and St\'ephane Ducasse},
  cvs = {ClassboxJFDLPA04},
  inria = {hors},
  journal = {Revue des Sciences et Technologies de l'Information (RSTI) --- L'Objet
(Num\'ero sp\'ecial : Programmation par aspects)},
  keywords = {scg-pub skip-doi jb05 classboxes snf05 stefPub alexandrePub alexPub listic},
  month = nov,
  number = {3},
  pages = {53--68},
  publisher = {Hermes, Paris},
  selectif = {non},
  title = {Scoped and Dynamic Aspects with {Classboxes}},
  url = {http://scg.unibe.ch/archive/papers/Berg05eDynamicClassboxes.pdf},
  volume = {11},
  year = {2005}
}

@inproceedings{Berg06b,
  abstract = {Prototyping new programming languages is often assimilated as a task
requiring heavy expertise in parsing and compilation. This paper argues that choosing as a
host platform a language having advanced reflective capabilities helps in reducing the
effort and time spent on developing new language related constructs and tools. The Squeak
Smalltalk implementation provides very expressive reflective facilities. In this paper we
focus on having methods as first class entities, enabling methods manipulation as plain
standard objects and reification of method execution. Powerful language related tools and
efficient new programming constructs can be quickly implemented. ByteSurgeon, a bytecode
manipulation library, and FacetS, an aspect mechanism, serve as illustrations.},
  aeres = {ACT},
  annote = {internationalworkshop},
  author = {Alexandre Bergel and Marcus Denker},
  booktitle = {Proceedings of the ECOOP'06 Workshop on Revival of Dynamic Languages},
  cvs = {SqueakRSP06},
  inria = {hors},
  keywords = {snf06 scg-pub skip-doi jb06 fb06 alexpub fromscgbib marcusdenker},
  medium = {4},
  month = jul,
  peerreview = {yes},
  selectif = {non},
  title = {Prototyping Languages, Related Constructs and Tools with {Squeak}},
  url = {http://rmod.lille.inria.fr/archives/workshops/Bergel06b-RDL06-Prototyping.pdf},
  year = {2006}
}

@inproceedings{Berg07a,
  abstract = {Traits offer a fine-grained mechanism to compose classes from reusable
components while avoiding problems of fragility brought by multiple inheritance and mixins.
Traits as originally proposed are \emph{stateless}, that is, they contain only methods, but
no instance variables. State can only be accessed within traits by accessors, which become
\emph{required methods} of the trait. Although this approach works reasonably well in
practice, it means that many traits, viewed as software components, are artificially
\emph{incomplete}, and classes that use such traits may contain significant amounts of
boilerplate glue code. Although these limitations are largely mitigated by proper tool
support, we seek a cleaner solution that supports \emph{stateful traits}. The key
difficulty is how to handle conflicts that arise when composed traits contribute instance
variables whose names clash. We present a solution that is faithful to the guiding
principle of stateless traits: \emph{the client retains control of the composition}.
Stateful traits consist of a minimal extension to stateless traits in which instance
variables are purely local to the scope of a trait, unless they are explicitly made
accessible by the composing client of a trait. Naming conflicts are avoided, and variables
of disjoint traits can be explicitly merged by clients. We discuss and compare two
implementation strategies, and briefly present a case study in which stateful traits have
been used to refactor the trait-based version of the Smalltalk collection hierarchy.},
  aeres = {ACL},
  aeresstatus = {aeres08},
  annote = {internationalconference},
  author = {Alexandre Bergel and St\'ephane Ducasse and Oscar Nierstrasz and Roel Wuyts},
  booktitle = {Advances in Smalltalk --- Proceedings of 14th International Smalltalk Conference (ISC 2006)},
  doi = {10.1007/978-3-540-71836-9\_3},
  inria = {hors},
  isbn = {978-3-540-71835-2},
  issn = {0302-9743},
  keywords = {scg07 stefPub scg-pub jb07 snf06 traits},
  medium = {2},
  month = aug,
  pages = {66--90},
  peerreview = {yes},
  publisher = {Springer},
  selectif = {non},
  series = {LNCS},
  title = {Stateful Traits},
  url = {http://scg.unibe.ch/archive/papers/Berg07aStatefulTraits.pdf},
  volume = {4406},
  year = {2007}
}

@inproceedings{Berg07c,
  abstract = {Smalltalk is not only an object-oriented programming language; it is also known for its extensive integrated development environment supporting interactive and dynamic programming. While the default tools are adequate for browsing the code and developing applications, it is often cumbersome to extend the environment to support new language constructs or to build additional tools supporting new ways of navigating and presenting source code. In this paper, we present the OmniBrowser, a browser framework that supports the definition of browsers based on an explicit metamodel. With OmniBrowser a domain model is described in a graph and the navigation in this graph is specified in its associated metagraph. We present how new browsers are built from predefined parts and how new tools are easily described. The browser framework is implemented in the Squeak Smalltalk environment. This paper shows several concrete instantiations of the framework: a remake of the ubiquitous Smalltalk System Browser, and a coverage browser.},
  aeres = {ACT},
  aeresstatus = {aeres08},
  annote = {internationalconference},
  author = {Alexandre Bergel and St\'ephane Ducasse and Colin Putney and Roel Wuyts},
  booktitle = {Advances in Smalltalk --- Proceedings of 14th International Smalltalk Conference (ISC 2006)},
  doi = {10.1007/978-3-540-71836-9\_3},
  inria = {hors},
  isbn = {978-3-540-71835-2},
  issn = {0302-9743},
  keywords = {scg07 stefPub scg-pub jb07 snf06},
  medium = {2},
  month = aug,
  pages = {134--156},
  peerreview = {yes},
  publisher = {Springer},
  selectif = {non},
  series = {LNCS},
  title = {Meta-Driven Browsers},
  url = {http://scg.unibe.ch/archive/papers/Berg07cOmnibrowser.pdf},
  volume = {4406},
  year = {2007}
}

@article{Berg08a,
  abstract = {Page-centric Web application frameworks fail to offer adequate solutions to
model composition and control flow. Seaside allows Web applications to be developed in the
same way as desktop applications. Control flow is modelled as a continuous piece of code,
and components may be composed, configured and nested as one would expect from traditional
user interface frameworks.},
  aeres = {AP},
  aeresstatus = {aeres08},
  annote = {notrefereed},
  author = {Alexandre Bergel and St\'ephane Ducasse and Lukas Renggli},
  inria = {hors},
  journal = {ERCIM News},
  keywords = {scg-pub snf-none skip-doi alexPub stefPub jb08 remoose},
  month = jan,
  selectif = {non},
  title = {Seaside -- Advanced Composition and Control Flow for Dynamic Web Applications},
  url = {http://ercim-news.ercim.org/content/view/325/536/},
  volume = 72,
  year = {2008}
}

@inproceedings{Berg08b,
  abstract = {Following last two years' workshop on dynamic languages at the ECOOP
conference, the Dyla 2007 workshop was a successful and popular event. As its name implies,
the workshop's focus was on dynamic languages and their applications. Topics and
discussions at the workshop included macro expansion mechanisms, extension of the method
lookup algorithm, language interpretation, reflexivity and languages for mobile ad hoc
networks. The main goal of this workshop was to bring together different dynamic language
communities and favouring cross communities interaction. Dyla 2007 was organised as a full
day meeting, partly devoted to presentation of submitted position papers and partly devoted
to tool demonstration. All accepted papers can be downloaded from the workshop's web site.
In this report, we provide an overview of the presentations and a summary of discussions.},
  aeres = {DO},
  aeresstatus = {aeres08},
  annote = {workshopproceedings},
  author = {Alexandre Bergel and Wolfgang De Meuter and St\'ephane Ducasse and Oscar Nierstrasz and Roel Wuyts},
  booktitle = {Object-Oriented Technology. ECOOP 2007 Workshop Reader},
  doi = {10.1007/978-3-540-78195-0},
  inria = {hors},
  isbn = {978-3-540-78194-3},
  keywords = {scg07 scg-pub stefPub jb08 snf-none},
  medium = {2},
  pages = {7--12},
  peerreview = {yes},
  publisher = {Springer-Verlag},
  selectif = {non},
  series = {LNCS},
  title = {Dynamic Languages and Applications, Report on the Workshop {Dyla}'07 at {ECOOP}
2007},
  url = {http://dyla2007.unibe.ch/
                  http://scg.unibe.ch/archive/papers/Berg08bDyla07Report.pdf
                  http://www.springer.com/computer/programming/book/978-3-540-78194-3},
  volume = {4906},
  year = {2008}
}

@inproceedings{Berg08c,
  author = {Alexandre Bergel and St\'ephane Ducasse and Jannik Laval and Romain Peirs},
  title = {Enhanced Dependency Structure Matrix for Moose},
  annote = {internationalworkshop},
  keywords = {moose},
  aeres = {missing},
  booktitle = {FAMOOSr, 2nd Workshop on FAMIX and Moose in Reengineering},
  year = {2008},
  x-editorial-board = {yes},
  x-proceedings = {no},
  x-international-audience = {yes},
  aeres = {COM},
  aeresstatus = {aeres12},
  selectif = {non},
  labo = {dans},
  inria = {RMOD},
  url = {http://rmod.lille.inria.fr/archives/workshops/Berg08c-Famoosr2008-DSM.pdf},
  hal-id = {inria-00498484}
}

@article{Berg08d,
  abstract = {Smalltalk is not only an object-oriented programming language; it is also
known for its extensive integrated development environment supporting interactive and
dynamic programming. While the default tools are adequate for browsing the code and
developing applications, it is often cumbersome to extend the environment to support new
language constructs or to build additional tools supporting new ways of navigating and
presenting source code. In this paper, we present the OmniBrowser, a browser framework that
supports the definition of browsers based on an explicit metamodel. With OmniBrowser a
domain model is described in a graph and the navigation in this graph is specified in its
associated metagraph. We present how new browsers are built from predefined parts and how
new tools are easily described. The browser framework is implemented in the Squeak
Smalltalk environment. This paper shows several concrete instantiations of the framework: a
remake of the ubiquitous Smalltalk System Browser, a coverage browser, the Duo Browser and
the Dynamic Protocols browser.},
  aeres = {ACL},
  aeresstatus = {aeres08},
  annote = {internationaljournal},
  author = {Alexandre Bergel and St\'ephane Ducasse and Colin Putney and Roel Wuyts},
  doi = {10.1016/j.cl.2007.05.005},
  inria = {hors},
  journal = {Journal of Computer Languages, Systems and Structures},
  impactfactor = {5 Year ISI impact factor 0.698 (2010)},
  misc = {5 Year ISI impact factor 0.698 (2010)},
  keywords = {stefPub snf06},
  number = {2-3},
  pages = {109--129},
  publisher = {Elsevier},
  selectif = {non},
  title = {Creating Sophisticated Development Tools with {OmniBrowser}},
  volume = {34},
  year = {2005},
  bdsk-url-1 = {http://dx.doi.org/10.1016/j.cl.2007.05.005}
}

@article{Berg08e,
  abstract = {Traits offer a fine-grained mechanism to compose classes from reusable components while avoiding problems of fragility brought by multiple inheritance and mixins. Traits as originally proposed are stateless, that is, they contain only methods, but no instance variables. State can only be accessed within stateless traits by accessors, which become required methods of the trait. Although this approach works reasonably well in practice, it means that many traits, viewed as software components, are artificially \emph{incomplete}, and classes that use such traits may contain significant amounts of boilerplate glue code. We present an approach to stateful traits that is faithful to the guiding principle of stateless traits: the client retains control of the composition. Stateful traits consist of a minimal extension to stateless traits in which instance variables are purely local to the scope of a trait, unless they are explicitly made accessible by the composing client of a trait. We demonstrate by means of a formal object calculus that adding state to traits preserves the flattening property: traits contained in a program can be compiled away. We discuss and compare two implementation strategies, and briefly present a case study in which stateful traits have been used to refactor the trait-based version of the Smalltalk collection hierarchy.},
  aeres = {ACL},
  aeresstatus = {aeres08},
  annote = {internationaljournal},
  author = {Alexandre Bergel and St\'ephane Ducasse and Oscar Nierstrasz and Roel Wuyts},
  doi = {10.1016/j.cl.2007.05.003},
  impactfactor = {5 Year ISI impact factor 0.698 (2010)},
  misc = {5 Year ISI impact factor 0.698 (2010)},
  inria = {hors},
  issn = {1477-8424},
  journal = {Journal of Computer Languages, Systems and Structures},
  keywords = {scg07 stefPub scg-pub jb08 snf06},
  medium = {2},
  number = {2-3},
  pages = {83--108},
  peerreview = {yes},
  publisher = {Elsevier},
  selectif = {non},
  title = {Stateful Traits and their Formalization},
  url = {http://scg.unibe.ch/archive/papers/Berg07eStatefulTraits.pdf},
  volume = {34},
  year = {2008}
}

@inproceedings{Berg09a,
  title = {SQUALE -- Software QUALity Enhancement},
  author = {Alexandre Bergel and Simon Denier and St\'ephane Ducasse and Jannik Laval and Fabrice Bellingard and Philippe Vaillergues and Fran{\c c}oise Balmas and Karine Mordal-Manet},
  booktitle = {Proceedings of the 13th European Conference on Software Maintenance and Reengineering (CSMR 2009), European Projects Track},
  annote = {internationalconference},
  year = {2009},
  month = {mar},
  institution = {INRIA},
  aeres = {COM},
  note = {Presentation},
  keywords = {squale-pub lse-pub},
  aeres = {ACT},
  aeresstatus = {aeres12},
  selectif = {non},
  labo = {dans},
  inria = {RMOD},
  x-editorial-board = {yes},
  x-proceedings = {yes},
  x-international-audience = {yes},
  abstract = {No abstract},
  x-language = {EN},
  url = {http://rmod.lille.inria.fr/archives/workshops/Berg09c-CSMR2009-Squale.pdf},
  hal-id = {tobedone}
}

@inproceedings{Bert03a,
  abstract = {Understanding object-oriented legacy systems is a complex task exacerbated by the presence of late binding and polymorphism. Moreover, the metaphor of message sending and the anthropomorphism promoted by object-oriented languages makes it difficult to statically identify the precise role the objects play at run-time. We propose a lightweight visualization approach enriched with run-time information which allows us to identify precise aspects of the objects lifetime such as the role played in the creation of other objects and the communication architecture they support. Our approach not only supports the run-time understanding of an application but also allows one to evaluate test understanding and test coverage.},
  annote = {internationalworkshop},
  author = {Roland Bertuli and St\'ephane Ducasse and Michele Lanza},
  booktitle = {Proceedings of WOOR 2003 (4th International Workshop on Object-Oriented Reengineering)},
  keywords = {snf03 scg-pub skip-doi jb03 stefPub moose-pub},
  pages = {10--19},
  publisher = {University of Antwerp},
  title = {Run-Time Information Visualization for Understanding Object-Oriented Systems},
  url = {http://scg.unibe.ch/archive/papers/Bert03aEcoopWorkshop.pdf},
  year = {2003}
}

@inproceedings{Bezi03a,
  annote = {internationalconference},
  author = {B\'ezivin, Jean and Farcet, Nicolas and J\'ez\'equel, Jean-Marc and Langlois, Beno\^\it and Pollet, Damien},
  booktitle = {UML~2003 --- The Unified Modeling Language --- Modeling Languages and Applications},
  editor = {Stevens, Perdita and Whittle, Jon and Booch, Grady},
  isbn = {3-540-20243-9},
  month = oct,
  pages = {175--189},
  publisher = {Springer Verlag},
  series = {LNCS},
  title = {Reflective Model Driven Engineering},
  url = {http://www.irisa.fr/triskell/publis/2003/Bezivin03.pdf},
  volume = {2863},
  year = {2003}
}


@inproceedings{Bhat07a,
  author = {Bhatti, Muhammad Usman and St\'ephane Ducasse},
  title = {Surgical Information to Detect Design Problems with MOOSE},
  annote = {internationalworkshop},
  keywords = {moose-pub},
  booktitle = {FAMOOSr, 1st Workshop on FAMIX and Moose in Reengineering},
  url = {http://scg.unibe.ch/archive/papers/Bhat07aFamoosRWorkshop.pdf},
  year = {2007},
  hal-id = {tobedone}
}

@inproceedings{Bhat08a,
  author = {Bhatti, Muhammad Usman and St\'ephane Ducasse and Awais Rashid},
  title = {Aspect Mining in Procedural Object-Oriented Code},
  annote = {internationalconference shortpaper},
  keywords = {moose-pub},
  aeres = {ACT},
  aeresstatus = {aeres08},
  selectif = {non},
  inria = {RMOD},
  booktitle = {International Conference on Program Comprehension (ICPC 2008)},
  url = {http://rmod.lille.inria.fr/archives/papers/Bhat08a-ICPC2008-AspectMining.pdf},
  year = {2008},
  x-editorial-board = {yes},
  x-proceedings = {yes},
  x-international-audience = {yes},
  x-pays = {UK},
  hal-id = {tobedone}
}

@inproceedings{Bhat08b,
  author = {Bhatti, Muhammad Usman and St\'ephane Ducasse and Marianne Huchard},
  title = {Reconsidering Classes in Procedural Object-Oriented Code},
  annote = {internationalconference stefPub},
  keywords = {moose-pub},
  aeres = {ACT},
  aeresstatus = {aeres08},
  selectif = {non},
  inria = {RMOD},
  booktitle = {International Conference on Reverse Engineering (WCRE)},
  url = {http://rmod.lille.inria.fr/archives/papers/Bhat08b-WCRE2008-ObjectIdentification.pdf},
  year = {2008},
  x-editorial-board = {yes},
  x-proceedings = {yes},
  x-international-audience = {yes},
  hal-id = {tobedone}
}



@techreport{Bhat08c,
  author = {Bhatti, Muhammad Usman and St\'ephane Ducasse and
                  Awais Rashid},
  title = {Aspect Mining in Procedural Object-Oriented Code},
  url = {http://rmod.lille.inria.fr/archives/papers/Bhat08c-TechReport-AspectMining.pdf},
  annote = {technicalreport},
  institution = {INRIA Lille Nord Europe},
  year = {2008},
  x-pays = {UK}
}

@phdthesis{Bhat08d,
  author = {Muhammad Usman Bhatti},
  title = {Object Identification and Aspect Mining in Procedural Object-Oriented Code},
  school = {UNIVERSITE PARIS I -- PANTHEON -- SORBONNE},
  abstract = {In this dissertation, we present Procedural Object-Oriented Code (POC). POC is the aftermath of the software development activity that involves state of the art object-oriented languages, without employing object-oriented analysis and design. Huge classes, absence of abstractions for domain entities, and shallow inheritance hierarchies are hallmark design defects of procedural object-oriented code. POC also consists of scattered code appearing not only due to the absence of aspects, but it also manifests scattered code appearing due to the non-abstracted domain entities i.e., domain entities that do not have their proper object-oriented classes. The non-abstracted domain logic hinders mining useful crosscutting concerns related to aspects in POC. Confronted with the absence of object-oriented design and the difficulty of mining aspects in POC, we studied it from two perspectives.
	First, we improve aspect mining techniques by classifying various crosscutting concerns identified in POC with a two-pronged approach: Firstly, the approach identifies and groups crosscutting concerns present in a software system: aspects as well as non-abstracted domain logic. Crosscutting concerns pertaining to non- abstracted domain entities are identified and extracted through their usage of application domain entity data. Secondly, a new metric called spread-out is introduced to quantify the divulgence of diverse crosscutting concerns.
	Second, we studied the problem of object identification in procedural object- oriented code. We present a semi-automatic, tool-assisted approach for restructuring POC into an improved object-oriented design. The approach identifies principal classes in POC. These principal classes are then used to extract object-oriented abstractions using Formal Concept Analysis lattices. This is achieved by providing three different concept lattices, namely fundamental, association, and interactions views.
	We developed tools to validate the approaches presented in the thesis. The approaches are validated on a recently developed industrial application. The application is used to run blood plasma analysis automatons. The results of our approach are promising.},
  year = {2008},
  hal = {tel-00498436 /}
}

@techreport{Blac02a,
  abstract = {Traits are a programming language technology modeled after mixins but
avoiding their problems. In this paper we refactor the Smalltalk collections hierarchy
using traits. We observed that the original hierarchy contained much duplication of code;
traits let us remove all of it. Traits also make possible much more general reuse of
collection code outside of the existing hierarchy; for example, they make it easy to
convert other collection-like things into true collections. Our refactoring reduced the
size of the collection hierarchy by approximately 12 per cent, with no measurable impact on
execution efficiency. More importantly, understandability and reusability of the code was
significantly improved, and the path was paved for a more intensive refactoring.},
  address = {Universit\"at Bern, Switzerland},
  annote = {report notrefereed},
  author = {Andrew P. Black and Nathanael Sch\"arli and St\'ephane Ducasse},
  classification = {D.2.6 Programming Environments D.2.10 Design D.1.5 Object-oriented
Programming; D.3.3 Language Constructs and Features},
  general_terms = {Inheritance, Mixins, Multiple Inheritance, Traits, Reuse, Smalltalk},
  institution = {Institut f\"ur Informatik},
  month = nov,
  note = {Also available as Technical Report CSE-02-014, OGI School of Science \& Engineering, Beaverton, Oregon, USA},
  number = {IAM-02-007},
  title = {Applying Traits to the {Smalltalk} Collection Hierarchy},
  type = {Technical Report},
  url = {http://scg.unibe.ch/archive/papers/Blac02aTraitsHierarchy.pdf},
  year = {2002},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Blac02aTraitsHierarchy.pdf}
}

@inproceedings{Blac03a,
  abstract = {Traits are a programming language technology that promote the reuse of
methods between unrelated classes. This paper reports on a refactoring of the Smalltalk
collections classes using traits. The original collection classes contained much
duplication of code; traits let us remove all of it. We also found places where the
protocols of the collections lacked uniformity; traits allowed us to correct these
non-uniformities without code duplication. Traits also make it possible to reuse fragments
of collection code outside of the existing hierarchy; for example, they make it easy to
convert other collection-like things into true collections. Our refactoring reduced the
number of methods in the collection classes by approximately 10 per cent. More importantly,
understandability maintainability and reusability of the code were significantly improved.},
  annote = {internationalconference topconference},
  author = {Andrew P. Black and Nathanael Sch\"arli and St\'ephane Ducasse},
  booktitle = {Proceedings of 17th International Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA'03)},
  cvs = {TraitsRefactoringOOPSLA2003},
  doi = {10.1145/949305.949311},
  misc = {acceptance rate: 26/142 = 18\%},
  accepttotal = {142},
  acceptnum = {26},
  month = oct,
  pages = {47--64},
  title = {Applying Traits to the {Smalltalk} Collection Hierarchy},
  url = {http://scg.unibe.ch/archive/papers/Blac03aTraitsHierarchy.pdf},
  volume = {38},
  year = {2003}
}

@book{Blac07a,
  title = {Squeak by Example},
  author = {Andrew Black and St\'ephane Ducasse and Oscar Nierstrasz and Damien Pollet and Damien Cassou and Marcus Denker},
  note = {http://SqueakByExample.org/  ordered but not received},
  publisher = {Square Bracket Associates},
  year = {2007},
  aeres = {OV},
  aeresstatus = {2008},
  inria = {RMOD},
  abstract = {Squeak by Example, intended for both students and developers, will guide you gently through the Squeak language and environment by means of a series of examples and exercises. This book is made available under the Creative Commons Attribution-ShareAlike 3.0 license.},
  isbn = {978-3-9523341-0-2},
  annote = {book},
  url = {http://SqueakByExample.org/index.html},
  keywords = {skipdoi remoose1-pub marcusdenker}
}


@book{Blac09a,
  title = {Pharo by Example},
  author = {Andrew P. Black and St\'ephane Ducasse and Oscar Nierstrasz and Damien Pollet and Damien Cassou and Marcus Denker},
  publisher = {Square Bracket Associates},
  year = {2009},
  aeres = {OV},
  aeresstatus = {2012},
  annote = {book},
  inria = {RMOD},
  inriareport = {2009},
  keywords = {skipdoi remoose2-pub pharo-pub marcusdenker},
  abstract = {Pharo by Example, intended for both students and developers, will guide you gently through the Pharo open-source Smalltalk language and environment by means of a series of examples and exercises. This book is made available under the Creative Commons Attribution-ShareAlike 3.0 license.},
  isbn = {978-3-9523341-4-0},
  url = {http://pharobyexample.org/},
  x-pays = {CH,US},
  x-scientific-popularization = {yes},
  x-international-audience = {yes},
  pages = 333,
  x-language = {EN}
}


@inproceedings{Bour10a,
  title = {BLOC: a Trait-Based Collections Library - a Preliminary Experience Report},
  author = {Tristan Bourgois and Jannik Laval and St\'ephane Ducasse and Damien Pollet},
  booktitle = {Proceedings of ESUG International Workshop on Smalltalk Technologies (IWST 2010)},
  year = {2010},
  keywords = {pharo-pub lse-pub},
  annote = {internationalworkshop},
  aeres = {ACT},
  aeresstatus = {aeres12},
  selectif = {oui},
  inria = {RMOD},
  labo = {dans},
  x-pays = {FR},
  x-editorial-board = {yes},
  x-proceedings = {yes},
  x-international-audience = {yes},
  x-country = {FR},
  x-language = {EN},
  address = {Barcelona, Spain},
  url = {http://rmod.lille.inria.fr/archives/workshops/Bourg10a-IWST10-bloc.pdf},
  abstract = {A trait is a programming construct which provides code reusability. Traits are groups of methods that can be reused orthogonally from inheritance. Traits offer a solution to the problems of multiple inheritance by providing a behavior-centric modularity. Since traits offer an alternative to traditional inheritance-based code reuse, a couple of questions arise. For example, what is a good granularity for a Trait enabling reuse as well as plug ease? How much reuse can we expect on large existing inheritance-based hierarchies?
In this paper we take as case study the Smalltalk Collection hierarchy and we start rewriting it from scratch using traits from the beginning. We show how such library can be built using traits and we report such a preliminary experience. Since the Collection library is large, we focused and built the main classes of the library with Traits and report problems we encountered and how we solved them. Results of this experience are positive and show that we can build new collections based on the traits used to define the new library kernel.},
  hal-id = {inria-00511902/}
}

@book{Brif01a,
  annote = {book},
  author = {Xavier Briffault and St\'ephane Ducasse},
  keywords = {smalltalk squeak scglib},
  month = nov,
  publisher = {Eyrolles, Paris},
  title = {Squeak},
  year = {2001}
}

@techreport{Brun09a,
  abstract = {Virtual machines emulating hardware devices are generally implemented in low-level languages and using a low-level style for performance reasons.  This trend results in largely difficult to understand, difficult to extend and unmaintainable systems. As new general techniques for virtual machines arise, it gets harder to incorporate or test these techniques because of early design and optimization decisions. In this paper we show how such decisions can be postponed to later phases by separating virtual machine implementation issues from the high-level machine-specific model. We construct compact models of whole-system VMs in a high-level language, which exclude all low-level implementation details. We use the pluggable translation toolchain PyPy to translate those models to executables. During the translation process, the toolchain reintroduces the VM implementation and optimization details for specific target platforms.  As a case study we implement an executable model of a hardware gaming device. We show that our approach to VM building increases understandability, maintainability and extendability while preserving performance.},
  annote = {report notrefereed},
  author = {Camillo Bruni and Toon Verwaest and Marcus Denker},
  institution = {University of Bern, Institute of Applied Mathematics
                  and Computer Sciences},
  keywords = {scg09 scg-pub jb09 snf09 skip-doi tverwaes marcusdenker fromscgbib},
  medium = {2},
  number = {IAM-09-002},
  peerreview = {yes},
  title = {{PyGirl}: Generating Whole-System {VM}s from
                  high-level models using {PyPy}},
  type = {Technical Report},
  url = {http://rmod.lille.inria.fr/archives/reports/Brun09a-TechReport-PyGirl.pdf},
  year = {2009}
}

@inproceedings{Casa09a,
  title = {Object Spaces for Safe Image Surgery},
  author = {Gwena{\"e}l Casaccio and Damien Pollet and Marcus Denker and St{\'e}phane Ducasse},
  booktitle = {Proceedings of ESUG International Workshop on Smalltalk Technologies (IWST 2009)},
  year = {2009},
  aeres = {ACT},
  aeresstatus = {aeres12},
  selectif = {non},
  labo = {dans},
  publisher = {ACM digital library},
  inria = {RMOD},
  inriareport = {2009},
  keywords = {remoose2-pub marcusdenker lse-pub},
  x-editorial-board = {yes},
  x-proceedings = {yes},
  x-international-audience = {yes},
  x-pays = {CL},
  url = {http://rmod.lille.inria.fr/archives/workshops/Casa09a-IWST09-ObjectSpaces.pdf},
  x-country = {FR},
  x-language = {EN},
  address = {New York, USA},
  abstract = {Long-lived systems rely on reflective self-modification to evolve.  Unfortunately, since such a system is at both ends of a causal loop, this means modifications that impact the reflective layer itself can be overly difficult to apply.  This paper introduces ObjectSpaces, a reification of the familiar Smalltalk image as a first-class entity. By confining the system inside an ObjectSpace, we isolate the evolution tools from it, while still giving them reflective access to the confined system.  We describe the ObjectSpaces idea, the interface to communicate, inspect, and debug objects contained inside and ObjectSpace, based on a prototype implementation in GNU Smalltalk.},
  pages = {77-81}
}

@inproceedings{Cass07a,
  abstract = {Recently, traits have been proposed as a single inheritance backward compatible solution in which the composing entity has the control over the trait composition. Traits are fine-grained units used to compose classes, while avoiding many of the problems of multiple inheritance and mixin-based approaches.  To evaluate the expressiveness of traits, some hierarchies were refactored, showing code reuse.  However, such large refactorings, while valuable, may not be facing all the problems, since the hierarchies were previously expressed within single inheritance and following certain patterns. We wanted to evaluate how traits enable reuse, and what problems could be encountered when building a library using traits from scratch, taking into account that traits are units of reuse. This paper presents our work on designing a new stream library named Nile. We present the reuse that we attained using traits, and the problems we encountered.},
  aeres = {ACT},
  aeresstatus = {aeres08},
  annote = {internationalconference},
  author = {Damien Cassou and St\'ephane Ducasse and Roel Wuyts},
  booktitle = {ICDL'07: Proceedings of the 15th International Conference on Dynamic Languages},
  doi = {10.1145/1352678.1352682},
  inria = {hors},
  isbn = {978-1-60558-084-5},
  keywords = {nile cook},
  pages = {50--75},
  publisher = {ACM Digital Library},
  selectif = {non},
  title = {Redesigning with Traits: the {Nile} Stream trait-based Library},
  url = {http://scg.unibe.ch/archive/papers/Cass07aTraitsStreamRedesign-ICDL.pdf},
  year = {2007}
}

@article{Cass09a,
  abstract = {Recent years saw the development of a composition mechanism called Traits. Traits are pure units of behavior that can be composed to form classes or other traits. The trait composition mechanism is an alternative to multiple or mixin inheritance in which the composer has full control over the trait composition. To evaluate the expressiveness of traits, some hierarchies were refactored, showing code reuse. However, such large refactorings, while valuable, may not exhibit all possible composition problems, since the hierarchies were previously expressed using single inheritance and following certain patterns. This paper presents our work on designing and implementing a new trait-based stream library named Nile. It evaluates how far traits enable reuse, what problems can be encountered when building a library using traits from scratch and compares the traits solution to alternative composition mechanisms. Nile's core allows the definition of compact collection and file streaming libraries as well as the implementation of a backward-compatible new stream library. Nile method size shows a reduction of 40% compared to the Squeak equivalent. The possibility to reuse the same set of traits to implement two distinct libraries is a concrete illustration of trait reuse capability.},
  aeres = {ACL},
  aeresstatus = {aeres12},
  annote = {internationaljournal},
  author = {Damien Cassou and St\'ephane Ducasse and Roel Wuyts},
  doi = {10.1016/j.cl.2008.05.004},
  halt = {inria-00216108,celwz9},
  inria = {RMOD},
  journal = {Journal of Computer Languages, Systems and Structures},
  impactfactor = {5 Year ISI impact factor 0.698 (2010)},
  misc = {5 Year ISI impact factor 0.698 (2010)},
  keywords = {cook nile stlit-traits},
  number = {1},
  pages = {2--20},
  publisher = {Elsevier},
  selectif = {non},
  title = {Traits at Work: the design of a new trait-based stream library},
  url = {http://scg.unibe.ch/archive/papers/Cass08a-NileNewKernel-ComputerLanguages.pdf},
  volume = {35},
  year = {2009}
}

@inproceedings{Cruz99a,
  abstract = {Although coordination of concurrent objects is a fundamental as-pect of object-oriented concurrent programming, there is only little support for its specification and abstraction at the language level.  This is a problem because coordination is often buried in the code of the coordinated objects, leading to a lack of abstraction and reuse. Here we present CoLaS, a coordination model and its implementation based on the notion of Coordination Groups. By clearly identifying and separating the coordination from the co-ordinated objects CoLaS provides a better abstraction and reuse of the coordination and the coordinated objects. Moreover CoLaS's high dynamicity provides better support for coordination of active objects.},
  annote = {internationalconference},
  author = {Juan-Carlos Cruz and St\'ephane Ducasse},
  booktitle = {Proceedings of Coordination '99},
  pages = {355--371},
  publisher = {Springer-Verlag},
  series = {LNCS},
  title = {A Group Based Approach for Coordinating Active Objects},
  url = {http://scg.unibe.ch/archive/papers/Cruz99aGroupBasedApproach.pdf},
  volume = {1594},
  year = {1999}
}

@inproceedings{Cruz99b,
  abstract = {Open Distributed Systems are the dominating intellectual issue of the end of this century.  Figuring out how to build those systems will become a central issue in distributed system research in the next future. Although CORBA seems to provide all the necessary support to construct those systems. It provides a very limited support to the evolution of requirements in those systems. The main problem is that the description of the elements from which systems are built, and the way in which they are composed are mixed into the application code. Making them difficult to understand, modify and customize.  We think that a solution to this problem goes through the introduction of the so called coordination models and languages into the CORBA model. We propose in this paper the introduction of our object coordination model called CoLaS into the CORBA model.},
  annote = {internationalworkshop},
  author = {Juan-Carlos Cruz and St\'ephane Ducasse},
  booktitle = {Proceedings of International Workshop in Future Trends in Distributed Computing Systems '99},
  doi = {10.1109/FTDCS.1999.818794},
  keywords = {olit scg-pub scg-coord-99 snf99 jb99 stefPub},
  title = {Coordinating Open Distributed Systems},
  url = {http://scg.unibe.ch/archive/papers/Cruz99FTDCS.pdf},
  year = {1999}
}


@inproceedings{Cuts09a,
  author = {van Cutsem, Tom and Alexandre Bergel and St\'ephane Ducasse and De Meuter, Wolfgang},
  booktitle = {Proceedings of ECOOP 2009},
  keywords = {traits alexPub stefPub},
  editor = {Sophia Drossopoulou},
  publisher = {Springer},
  annote = {internationalconference topconference},
  series = {Lecture Notes in Computer Science},
  title = {Adding State and Visibility Control to Traits using Lexical Nesting},
  year = {2009},
  url = {http://rmod.lille.inria.fr/archives/papers/Cuts09a-ECOOP09-Traits.pdf},
  aeres = {ACT},
  aeresstatus = {aeres12},
  selectif = {oui},
  rate = {21%},
  misc = {21%},
  labo = {dans},
  inria = {RMOD},
  inriareport = {2009},
  x-editorial-board = {yes},
  x-proceedings = {yes},
  x-international-audience = {yes},
  x-pays = {BE},
  x-country = {BE},
  x-language = {EN},
  address = {London, UK},
  abstract = {Traits are reusable building blocks that can be composed to share methods across unrelated class hierarchies. Original traits are stateless and cannot express visibility control for methods. Two extensions, stateful traits and freezable traits, have been proposed to overcome these limitations. However, these extensions introduce complexity and have not yet been combined to simultaneously add both state and visibility control to traits.
This paper revisits the addition of state and visibility control to traits. Rather than extending the original traits model with additional operations, we allow traits to be lexically nested within other modules. Traits can then have (shared) state and visibility control by hiding variables or methods in their lexical scope. Although the Traits' flattening property has to be revisited, the combination of traits with lexical nesting results in a simple and expressive trait model. We discuss an implementation of the model in AmbientTalk and specify its operational semantics.},
  hal-id = {inria-00498397 / v?f3e59}
}

@inproceedings{Deme00a,
  abstract = {Reverse engineering is the process of uncovering the design and the design rationale from a functioning software system. Reverse engineering is an integral part of any successful software system, because changing requirements lead to implementations that drift from their original design. In contrast to traditional reverse engineering techniques -which analyse a single snapshot of a system- we focus the reverse engineering effort by determining where the implementation has changed. Since changes of object-oriented software are often phrased in terms of refactorings, we propose a set of heuristics for detecting refactorings by applying lightweight, object-oriented metrics to successive versions of a software system. We validate our approach with three separate case studies of mature object-oriented software systems for which multiple versions are available. The case studies suggest that the heuristics support the reverse engineering process by focusing attention on the relevant parts of a software system.},
  address = {New York NY},
  annote = {internationalconference topconference},
  author = {Serge Demeyer and St\'ephane Ducasse and Oscar
                  Nierstrasz},
  booktitle = {Proceedings of 15th International Conference on
                  Object-Oriented Programming, Systems, Languages, and
                  Applications (OOPSLA '00)},
  doi = {10.1145/353171.353183},
  keywords = {olit scg-pub jb00 snf00 oorp stefPub moose-pub},
  misc = {acceptance rate: 26/142 = 18\%, SCI impact factor
                  0.190, ranked 66/77},
  accepttotal = {142},
  acceptnum = {26},
  note = {Also in ACM SIGPLAN Notices 35 (10)},
  pages = {166--178},
  publisher = {ACM Press},
  title = {Finding Refactorings via Change Metrics},
  url = {http://scg.unibe.ch/archive/papers/Deme00aFindingRefactoring.pdf},
  year = {2000}
}

@inproceedings{Deme00d,
  abstract = {Since object-oriented programming is usually associated with iterative development, reverse engineering must be considered an essential facet of the object-oriented paradigm. The reverse engineering pattern language presented here summarises the reverse engineering experience gathered as part of the FAMOOS project, a project with the explicit goal of investigating reverse and reengineering techniques in an object-oriented context. Due to limitations on EuroPLOP submissions, only part of the full pattern language is presented, namely the patterns describing how to gain an initial understanding of a software system.},
  annote = {internationalworkshop},
  author = {Serge Demeyer and St\'ephane Ducasse and Oscar Nierstrasz},
  booktitle = {Proceedings of EuroPLoP '2000},
  isbn = {3-87940-775-4},
  keywords = {snf-none stefPub olit scg-pub skip-doi jb00},
  pages = {189--208},
  publisher = {UVK GmbH},
  title = {A Pattern Language for Reverse Engineering},
  url = {http://scg.unibe.ch/archive/papers/Deme00dRevEng.pdf},
  year = {2000}
}

@techreport{Deme01y,
  annote = {report notrefereed},
  author = {Serge Demeyer and Sander Tichelaar and St\'ephane Ducasse},
  institution = {University of Bern},
  title = {{FAMIX} 2.1 --- {The} {FAMOOS} {Information} {Exchange} {Model}},
  year = {2001}
}

@book{Deme02a,
  abstract = {The rapid growth of object-oriented development over the past twenty years has given rise to many object-oriented systems that are large, complex and hard to maintain. Object-Oriented Reengineering Patterns addresses the problem of understanding and reengineering such object-oriented legacy systems. This book collects and distills successful techniques in planning a reengineering project, reverse-engineering, problem detection, migration strategies and software redesign. The material in this book is presented as a set of "reengineering patterns" --- recurring solutions that experts apply while reengineering and maintaining object-oriented systems. The principles and techniques described in this book have been observed and validated in a number of industrial projects, and reflect best practice in object-oriented reengineering.},
  annote = {book},
  author = {Serge Demeyer and St{\'e}phane Ducasse and Oscar Nierstrasz},
  isbn = {1-55860-639-4},
  publisher = {Morgan Kaufmann},
  title = {Object-Oriented Reengineering Patterns},
  url = {http://www.iam.unibe.ch/~scg/OORP},
  year = {2002}
}

@inproceedings{Deme03a,
  annote = {workshopproceedings},
  author = {Serge Demeyer and St\'ephane Ducasse and Kim Mens and Adrian Trifu and Rajesh Vasa},
  booktitle = {Object-Oriented Technology (ECOOP'03 Workshop Reader)},
  publisher = {Springer-Verlag},
  pages = {72-85},
  series = {LNCS},
  title = {Report of the {ECOOP}'03 Workshop on Object-Oriented Reengineering},
  year = {2003}
}

@misc{Deme03b,
  annote = {workshopproceedings},
  author = {Wolfgang Demeuter and St\'ephane Ducasse and Theo D'hondt and Ole Lehrmann Madsen},
  booktitle = {Object-Oriented Technology (ECOOP'03 Workshop Reader)},
  publisher = {Springer-Verlag},
  series = {LNCS},
  title = {Report of the {ECOOP}'03 Workshop on Object-Oriented Language Engineering in Post-Java Era},
  year = {2003}
}

@inproceedings{Deme05a,
  abstract = {The notion of refactoring --- transforming the source-code of an object-oriented program without changing its external behaviour --- has been studied intensively within the last decade. This diversity has created a plethora of toy-examples, cases and code snippets, which make it hard to assess the current state-of-the-art.  Moreover, due to this diversity, there is currently no accepted way of teaching good refactoring practices, despite the acknowledgment in the software engineering body of knowledge. Therefore, this paper presents a common example --- the LAN simulation --- which has been used by a number of European Universities for both research and teaching purposes.},
  address = {Los Alamitos CA},
  aeres = {ACT},
  aeresstatus = {aeres08},
  annote = {internationalworkshop},
  author = {Serge Demeyer and Filip Van Rysselberghe and Tudor G\^irba and Jacek Ratzinger and Radu Marinescu and Tom Mens and Bart Du Bois and Dirk Janssens and St\'ephane Ducasse and Michele Lanza and Matthias Rieger and Harald Gall and Michel Wermelinger and Mohammad El-Ramly},
  booktitle = {Proceedings of IWPSE 2005 (8th International
                  Workshop on Principles of Software Evolution)},
  doi = {10.1109/IWPSE.2005.30},
  inri = {hors},
  location = {Lisbon, Portugal},
  misc = {acceptance rate: 13/54=24\%},
  accepttotal = {54},
  acceptnum = {13},
  pages = {123--131},
  publisher = {IEEE Computer Society Press},
  rate = {24%},
  selectif = {oui},
  title = {The {LAN}-simulation: A Research and Teaching Example for Refactoring},
  url = {http://scg.unibe.ch/archive/papers/Deme05aLANRefactoring.pdf},
  year = {2005}
}

@misc{Deme05b,
  abstract = {Surprising as it may seem, many of the early adopters of the object-oriented paradigm already face a number of problems typically encountered in large-scale legacy systems. Software engineers are now confronted with millions of lines of industrial source code, developed using object-oriented design methods and languages of the late 80s and early 90s.  These systems exhibit a range of problems, effectively preventing them from satisfying the evolving requirements imposed by their customers.  This paper shares our knowledge concerning the reengineering of object-oriented legacy systems. We draw upon our experiences, to show you techniques and tools we have applied on real industrial OO systems to detect and repair problems. In particular, we discuss issues like reverse engineering, design extraction, metrics, refactoring and program visualisation.},
  address = {Washington, DC, USA},
  annote = {tutorial},
  author = {Serge Demeyer and St\'{e}phane Ducasse and Oscar
                  Nierstrasz},
  booktitle = {ICSM '05: Proceedings of the 21st IEEE International
                  Conference on Software Maintenance},
  doi = {10.1109/ICSM.2005.67},
  isbn = {0-7695-2368-4},
  keywords = {scg-misc jb-none tutorial},
  note = {tutorial},
  pages = {723--724},
  publisher = {IEEE Computer Society},
  title = {Object-Oriented Reengineering: Patterns and
                  Techniques},
  url = {http://scg.unibe.ch/archive/papers/Deme05bOORP-Tutorial.pdf},
  year = {2005},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Deme05bOORP-Tutorial.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1109/ICSM.2005.67}
}

@inproceedings{Deme06a,
  annote = {workshopproceedings},
  author = {Serge Demeyer and Kim Mens and Roel Wuyts and
                  Yann-Ga\"el Gu\'e{e}h\'{e}neuc and Andy Zaidman and
                  Neil Walkinshaw and Ademar Aguiar and St\'ephane
                  Ducasse},
  booktitle = {Object-Oriented Technology. ECOOP'05 Workshop
                  Reader},
  keywords = {scg-pub skip-abstract skip-doi jb-none stefPub},
  title = {Report of the 6th ECOOP'05 Workshop on
                  Object-Oriented Reengineering},
  url = {http://www.info.ucl.ac.be/~km/MyResearchPages/publications/workshop_report/WR_2006_ECOOP2005_WOOR.pdf},
  year = {2006},
  bdsk-url-1 = {http://www.info.ucl.ac.be/~km/MyResearchPages/publications/workshop_report/WR_2006_ECOOP2005_WOOR.pdf}
}

@book{Deme08a,
  abstract = {The rapid growth of object-oriented development over the past twenty years has given rise to many object-oriented systems that are large, complex and hard to maintain. Object-Oriented Reengineering Patterns addresses the problem of understanding and reengineering such object-oriented legacy systems.  This book collects and distills successful techniques in planning a reengineering project, reverse-engineering, problem detection, migration strategies and software redesign. The material in this book is presented as a set of "reengineering patterns" --- recurring solutions that experts apply while reengineering and maintaining object-oriented systems. The principles and techniques described in this book have been observed and validated in a number of industrial projects, and reflect best practice in object-oriented reengineering.},
  annote = {book},
  author = {Serge Demeyer and St{\'e}phane Ducasse and Oscar Nierstrasz},
  isbn = {978-3-9523341-2-6},
  keywords = {olit scg08 scg-pub snf-none jb09 skip-doi stefPub mooseCincom moose-pub},
  medium = {2},
  peerreview = {no},
  publisher = {Square Bracket Associates},
  title = {Object-Oriented Reengineering Patterns},
  url = {http://scg.unibe.ch/download/oorp/},
  year = {2008}
}

@unpublished{Deme97z,
  abstract = {Applying object-oriented design methods and languages does not guarantee that the resulting software systems will be flexible and adaptable. The industrial partners in the FAMOOS project have learned this lesson the hard way: they are now faced with large and rigid software systems that hamper them in meeting a diverse and evolving set of customer requirements. Object-oriented frameworks are touted as a promising solution, but it is unclear how to transform object-oriented legacy systems into frameworks. This paper proposes an approach --i.e, a methodology and tools-- for re-engineering object-oriented systems towards frameworks by means of high-level and low-level restructuring transformations that detect and resolve architectural and detailed design anomalies, and improve application flexibility and adaptability.},
  author = {Serge Demeyer and St\'ephane Ducasse and Robb Nebbe
                  and Oscar Nierstrasz and Tamar Richner},
  keywords = {olit famoos-techrep scg-wp skip-doi snf97
                  sergedem-techrep},
  month = may,
  note = {technical report},
  title = {Using Restructuring Transformations to Reengineer
                  Object-Oriented Systems},
  url = {http://www.iam.unibe.ch/~demeyer/Deme97z/index.html
                  http://scg.unibe.ch/archive/papers/Deme97zWCRE.pdf},
  year = {1997}
}

@inproceedings{Deme98n,
  annote = {internationalworkshop},
  author = {Serge Demeyer and St\'ephane Ducasse},
  booktitle = {Object-Oriented Technology (ECOOP '98 Workshop
                  Reader)},
  editor = {Serge Demeyer and Jan Bosch},
  keywords = {olit famoos-papunr scg-pub skip-pdf skip-abstract
                  skip-doi snf98 metrics jb98 stefPub},
  pages = {247--249},
  publisher = {Springer-Verlag},
  series = {LNCS},
  title = {Do Metrics Support Framework Development?},
  volume = {1543},
  year = {1998}
}

@inproceedings{Deme99a,
  abstract = {Maturing a well designed framework requires a set of software metrics to steer the iterative development process. Based on a case study of the VisualWorks/Smalltalk framework for user-interface building, we conclude that today's size and inheritance metrics are not reliable to detect problems but are useful in measuring stability. We expect that this work will contribute to the application of metrics as a project management tool.},
  annote = {nationalconference},
  author = {Serge Demeyer and St\'ephane Ducasse},
  booktitle = {Proceedings of Languages et Mod\`eles \`a Objets (LMO'99)},
  editor = {Jacques Malenfant},
  keywords = {olit famoos-papref scg-pub skip-doi snf99 jb99 oorp
                  stefPub moose-pub},
  pages = {69--82},
  publisher = {HERMES Science Publications, Paris},
  title = {Metrics, Do They Really Help?},
  url = {http://scg.unibe.ch/archive/papers/Deme99aDemeyerDucasseLMO99.pdf},
  year = {1999},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Deme99aDemeyerDucasseLMO99.pdf}
}

@inproceedings{Deme99c,
  abstract = {Surprising as it may seem, many of the early adopters of the object-oriented paradigm already face a number of problems typically encountered in large-scale legacy systems. Consequently, reverse engineering techniques are relevant in an object-oriented context as well. This paper investigates a hybrid approach, combining the immediate appeal of visualisations with the scalability of metrics. We validate such a hybrid approach by showing how CodeCrawler ---the experimental platform we built--- allowed us to understand the program structure of, and identify potential design anomalies in a public domain software system.},
  annote = {internationalconference},
  author = {Serge Demeyer and St\'ephane Ducasse and Michele
                  Lanza},
  booktitle = {Proceedings of 6th Working Conference on Reverse
                  Engineering (WCRE '99)},
  doi = {10.1109/WCRE.1999.806958},
  editor = {Francoise Balmas and Mike Blaha and Spencer Rugaber},
  keywords = {olit famoos-papref scg-pub snf99 jb99 oorp stefPub
                  moose-pub},
  month = oct,
  publisher = {IEEE Computer Society},
  title = {A Hybrid Reverse Engineering Platform Combining
                  Metrics and Program Visualization},
  url = {http://scg.unibe.ch/archive/papers/Deme99cCodeCrawler.pdf},
  year = {1999}
}

@inproceedings{Deme99d,
  abstract = {UML is currently embraced as "the" standard in object-oriented modeling languages, the recent work of OMG on the Meta Object Faci lity (MOF) being the most noteworthy example. We welcome these standardisation efforts, yet warn against the tendency to use UML as the panacea for all exchange standards. In particular, we argue that UML is not sufficient to serve as a tool-interoperability standard for integrating round-trip engineering tools, because one is forced to rely on UML's built-in extension mechanisms to a dequately model the reality in source-code. Meanwhile, our argumentation includes a number of constructive suggestions that we ho pe will influence future releases of the UML and MOF standards.},
  address = {Kaiserslautern, Germany},
  annote = {internationalconference},
  author = {Serge Demeyer and St\'ephane Ducasse and Sander
                  Tichelaar},
  booktitle = {Proceedings UML '99 (The Second International
                  Conference on The Unified Modeling Language)},
  editor = {Bernhard Rumpe},
  keywords = {olit famoos-papref scg-pub skip-doi snf99 jb99
                  stefPub moose-pub},
  misc = {acceptance rate: 44/166 = 26\%, SCI impact 0.515, ranked 39/69},
  accepttotal = {166},
  acceptnum = {44},
  month = oct,
  pages = {630--644},
  publisher = {Springer-Verlag},
  series = {LNCS},
  title = {Why Unified is not Universal. {UML} Shortcomings for
                  Coping with Round-trip Engineering},
  url = {http://scg.unibe.ch/archive/papers/Deme99dUML99.pdf},
  volume = {1723},
  year = {1999},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Deme99dUML99.pdf}
}

@inproceedings{Deme99n,
  abstract = {This pattern language describes how to reverse engineer an object-oriented software system. Since the only way to achieve a truly reusable object-oriented design is recognised to be iterative development, reverse engineering is indeed an essential facet of any object-oriented development process. The pattern language itself covers the different phases one encounters when reverse engineering a large software system: from being unfamiliar with a software system up untill preparations for actual reengineering. What you read here is a short version of a complete pattern language. We present only five patterns in full detail and include a summary for the remaining patterns.},
  address = {Konstanz, Germany},
  annote = {internationalworkshop},
  author = {Serge Demeyer and St\'ephane Ducasse and Sander Tichelaar},
  booktitle = {Proceedings of the 4th European Conference on Pattern Languages of Programming and Computing},
  editor = {Paul Dyson},
  keywords = {scg-pub skip-doi stefPub},
  month = jul,
  publisher = {UVK Universit\"atsverlag Konstanz GmbH},
  title = {A Pattern Language for Reverse Engineering},
  url = {http://scg.unibe.ch/archive/papers/Deme99nEuroplop99.pdf},
  year = {1999}
}

@inproceedings{Deni04a,
  address = {Paris, France},
  author = {Simon Denier},
  booktitle = {Actes de la Premi\`ere Journ\'ee Francophone sur le D\'eveloppement du Logiciel par Aspects (JFDLPA'04)},
  editor = {Pierre Cointe},
  month = sep,
  pages = {62--78},
  title = {Traits Programming with {AspectJ}},
  url = {http://www.emn.fr/x-info/obasco/events/jfdlpa04/},
  year = {2004},
  bdsk-url-1 = {http://www.emn.fr/x-info/obasco/events/jfdlpa04/}
}

@inproceedings{Deni09a,
  title = {Understanding the Use of Inheritance with Visual Patterns},
  author = {Simon Denier and Houari A. Sahraoui},
  booktitle = {Proceedings of the 3rd International Symposium on Empirical Software Engineering and Measurement (ESEM 2009)},
  editor = {James Miller and Rick Selby},
  publisher = {IEEE Computer Society Press},
  address = {Lake Buena Vista, FL, USA},
  year = {2009},
  inriareport = {2009},
  keywords = {lse-pub remoose},
  annote = {internationalconference},
  aeres = {ACT},
  aeresstatus = {aeres12},
  selectif = {non},
  labo = {dans},
  inria = {RMOD},
  rate = {39\%},
  x-editorial-board = {yes},
  x-proceedings = {yes},
  x-international-audience = {yes},
  x-language = {EN},
  x-country = {FR},
  x-pays = {CA},
  url = {http://rmod.lille.inria.fr/archives/papers/Deni09a-ESEM09-VisuInheritance.pdf},
  abstract = {The goal of this work is to visualize inheritance in object-oriented programs to help its comprehension. We propose a single, compact view of all class hierarchies at once using a custom Sunburst layout. It enables to quickly discover interesting facts across classes while preserving the essential relationship between parent and children classes. We explain how standard inheritance metrics are mapped into our visualization. Additionally, we define a new metric characterizing similar children classes. Using these metrics and the proposed layout, a set of common visual patterns is derived.  These patterns allow the programmer to quickly understand how inheritance is used and provide answers to some essential questions when performing program comprehension tasks. Our approach is evaluated through a case study that involves examples from large programs, demonstrating its scalability.}
}

@inproceedings{Deni09b,
  title = {Proposals for the Reborn Pharo Developer},
  author = {Simon Denier and Damien Pollet and St\'ephane Ducasse},
  booktitle = {Proceedings of ESUG International Workshop on Smalltalk Technologies (IWST 2009)},
  year = {2009},
  keywords = {lse-pub pharo-pub},
  annote = {internationalworkshop},
  aeres = {ACT},
  aeresstatus = {aeres12},
  selectif = {non},
  labo = {dans},
  inria = {RMOD},
  inriareport = {2009},
  x-editorial-board = {yes},
  x-proceedings = {yes},
  x-international-audience = {yes},
  url = {http://rmod.lille.inria.fr/archives/workshops/Deni09b-IWST09-PharoBrowsers.pdf},
  x-country = {FR},
  x-language = {EN},
  address = {Brest, France},
  abstract = {No abstract}
}

@proceedings{Deni09c,
  title = {Proceedings of the 3rd Workshop on FAMIX and MOOSE in Software Reengineering (FAMOOSr 2009)},
  author = {Simon Denier and Tudor G\^irba},
  editor = {Simon Denier and Tudor G\^irba},
  pages = {27},
  year = {2009},
  keywords = {moose-pub lse-pub},
  annote = {workshopproceedings},
  aeres = {AP},
  aeresstatus = {aeres12},
  labo = {dans},
  inria = {RMOD},
  inriareport = {2009},
  x-editorial-board = {yes},
  x-proceedings = {yes},
  x-international-audience = {yes},
  x-language = {EN},
  x-pays = {CH},
  url = {http://rmod.lille.inria.fr/archives/workshops/Deni09c-famoosr09-proceedings.pdf},
  abstract = {The increasing amount of data available about software systems poses new challenges for re- and reverse engineering research, as the proposed approaches need to scale. In this context, concerns about meta-modeling and analysis techniques need to be augmented by technical concerns about how to reuse and how to build upon the efforts of previous research. MOOSE is an extensive infrastructure for reverse engineering evolved for over 10 years that promotes the reuse of engineering efforts in research. MOOSE accommodates various types of data modeled in the FAMIX family of meta-models. The goal of this half-day workshop is to strengthen the community of researchers and practitioners who are working in re- and reverse engineering, by providing a forum for building future research starting from MOOSE and FAMIX as shared infrastructure.}
}

@techreport{Deni10a,
  author = {Simon Denier and Jannik Laval and St\'ephane Ducasse and Fabrice Bellingard},
  title = {Technical and Economical Model (Squale Deliverable 2.1)},
  institution = {INRIA},
  inriareport = {2010},
  year = {2010},
  type_rapport = {Rapport technique},
  abstract = {No abstract},
  hal-id = {inria-00533656}
}

@techreport{Deni10b,
  author = {Simon Denier and Jannik Laval and St\'ephane Ducasse and Fabrice Bellingard},
  title = {Technical Model for Remediation (Squale Deliverable 2.2)},
  institution = {INRIA},
  inriareport = {2010},
  year = {2010},
  type_rapport = {Rapport technique},
  abstract = {No abstract},
  hal-id = {inria-00533659}
}

@inproceedings{Denk00a,
  abstract = {Mittels CORBA k\"onnen verteilte Applikationen einfach \"uber ein Netzwerk miteinander kommunizieren. Doch das von CORBA zur Verf\"ugung gestellte Kommunikationsmodell reicht in manchen F\"allen nicht aus, es wird ein Modell zur asynchronen Kommunikation zwischen lose gekoppelten Objekten ben\"otigt. Der CORBA Event Service ist ein Versuch, ein solches Kommunikationsmodell bereitzustellen. Der Event Service hat sich aber als unzureichend herausgestellt. Daher wurde er um einige Aspekte zum Notiocation Service erweitert.},
  author = {Marcus Denker},
  booktitle = {Architektur vernetzter Systeme},
  issn = {1432-7864},
  page = {7--13},
  keywords = {marcusdenker fromscgbib},
  publisher = {Universit\"at Karlsruhe, Institut fuer Telematik (Interner Bericht)},
  title = {Event und Notification Service in CORBA},
  url = {http://rmod.lille.inria.fr/archives/reports/Denk00a-TechReport-Corba.pdf},
  year = {2000}
}

@article{Denk01a,
  author = {Marcus Denker},
  journal = {Der Eulenspiegel},
  number = {2},
  keywords = {Etoys Squeak Education marcusdenker fromscgbib},
  annote = {notrefereed},
  selectif = {non},
  publisher = {Fachschaft Mathematik/Informatik, University of Karlsruhe},
  title = {Squeak: Zur&uuml;ck in die Zukunft},
  url = {http://rmod.lille.inria.fr/archives/popular/Denk01a-EulenSpiegel-Squeak.pdf},
  volume = {2001},
  year = {2001}
}

@misc{Denk02a,
  abstract = {Das Squeak-System m\"ochte eine flexible Programmierumgebung und ein m\"achtiges multimediales Autorensystem f\"ur Kinder bereitstellen. Die besonderen Eigenschaften eines solchen Systems stellen besondere Anforderungen an die Implementierung. Die Studienarbeit zeigt die Probleme der bestehenden Implementierungen auf und stellt einen verbesserten Entwurf vor.},
  author = {Marcus Denker},
  keywords = {Squeak marcusdenker fromscgbib},
  note = {Studienarbeit, Universit\"at Karlsruhe},
  title = {Entwurf von Optimierungen f\"ur Squeak},
  url = {http://rmod.lille.inria.fr/archives/reports/Denk02a-Studienarbeit-J3.pdf},
  year = {2002}
}

@mastersthesis{Denk04a,
  author = {Marcus Denker},
  school = {University of Karlsruhe},
  title = {Erweiterung eines statischen \"Ubersetzers zu einem
                  Laufzeit\"ubersetzungssystem},
  type = {diploma thesis},
  keywords = {marcusdenker fromscgbib},
  url = {http://rmod.lille.inria.fr/archives/reports/Denk04a-Thesis-Karlsruhe.pdf},
  year = {2004}
}

@inproceedings{Denk04b,
  abstract = {This is not a real article. While putting together
                  the demo image for for 21C3, I decided to not write
                  an article that is just to be read (mostly because
                  these are really boring to write...) This text is
                  just a short user manual for that thing (we call it
                  Squeak Image) that I will use for the demo at 21C3.
                  So if you follow the instructions, you will be able
                  to go through the slides and play with everything
                  yourself.},
  author = {Marcus Denker},
  keywords = {fromscgbib marcusdenker},
  booktitle = {Proceedings of the 21st Chaos Communication
                  Congress},
  isbn = {3-934636-02-0},
  page = {52--59},
  publisher = {Chaos Computer Club},
  title = {Squeak@21c3},
  url = {http://rmod.lille.inria.fr/archives/popular/Denk04b-21C3-Squeak.pdf},
  year = {2004}
}

@inproceedings{Denk05a,
  abstract = {Squeak allows kids of all ages to be creative with their computer. The goal of the Squeak Project is to build a system without constraints: It is used at schools, universities and in industry. Squeak is an open System: It is implemented in Squeak itself, all parts are available for learning and hacking. The whole source code is available and can be changed while the system is running. Squeak is available on the internet under a free license, it is highly portable and currently used on over 20 different platforms. This talk will give an overview over the Squeak Project: From the eToy kids programming environment up to the Seaside system for professional web development. The eToys make programming fun for children from around age 8. The talk will show how to build simple eToy programs and how Squeak is used at school. But even professional developers are using Squeak; The Seaside framework shows how the openness of Squeak can help to make developers more productive. The last part of the talk will give a glimpse into the future: OpenCroquet. The Croquet project is building a revolutionary collaborative environment based on Squeak. It provides a scalable, peer-to-peer multiuser 3D environment that is completely open for exploration and makes novel ways for communication and interaction possible.},
  keywords = {fromscgbib marcusdenker},
  author = {Marcus Denker},
  booktitle = {Proceedings of LinuxTag 2005},
  title = {Squeak and Croquet},
  url = {http://rmod.lille.inria.fr/archives/popular/Denk05a-LinuxTag-Squeak.pdf},
  year = {2005}
}

@article{Denk06a,
  abstract = {Transforming programs to alter their semantics is of
                  wide interest, for purposes as diverse as
                  off-the-shelf component adaptation, optimization,
                  trace generation, and experimentation with new
                  language features. The current wave of interest in
                  advanced technologies for better separation of
                  concerns, such as aspect-oriented programming, is a
                  solid testimony of this fact. Strangely enough,
                  almost all proposals are formulated in the context
                  of {Java}, in which tool providers encounter severe
                  restrictions due to the rigidity of the environment.
                  This paper present ByteSurgeon, a library to
                  transform binary code in Smalltalk. ByteSurgeon
                  takes full advantage of the flexibility of the
                  Squeak environment to enable bytecode transformation
                  at runtime, thereby allowing dynamic, on-the-fly
                  modification of applications. ByteSurgeon operates
                  on bytecode in order to cope with situations where
                  the source code is not available, while providing
                  appropriate high-level abstractions so that users do
                  not need to program at the bytecode level. We
                  illustrate the use of ByteSurgeon via the
                  implementation of method wrappers and a simple MOP,
                  and report on its efficiency.},
  aeres = {ACL},
  aeresstatus = {aeres08},
  annote = {internationaljournal},
  author = {Marcus Denker and St\'ephane Ducasse and {\'E}ric Tanter},
  doi = {10.1016/j.cl.2005.10.002},
  impactfactor = {5 Year ISI impact factor 0.698 (2010)},
  journal = {Journal of Computer Languages, Systems and Structures},
  keywords = {scg-pub stefPub jb06 snf-actsc snf06 mdPub fromscgbib marcusdenker},
  misc = {5 Year ISI impact factor 0.698 (2010)},
  month = jul,
  number = {2-3},
  pages = {125--139},
  publisher = {Elsevier},
  selectif = {non},
  title = {Runtime Bytecode Transformation for {Smalltalk}},
  url = {http://rmod.lille.inria.fr/archives/papers/Denk06a-COMLAN-RuntimeByteCode.pdf},
  volume = {32},
  year = {2006}
}


@inproceedings{Denk06c,
  abstract = {The developers of tools for dynamic analysis are faced with choosing from the many approaches to gathering runtime data. Typically, dynamic analysis involves instrumenting the program under investigation to record its runtime behavior.  Current approaches for byte-code based systems like Java and Smalltalk rely often on inserting byte-code into the program under analysis. However, detailed knowledge of the target programming language or virtual machine is required to implement dynamic analysis tools. Obtaining and exploiting this knowledge to build better analysis tools is cumbersome and often distracts the tool builder from the actual goal, which is the analysis of the runtime behavior of a system. In this paper, we argue that we need to adopt a higher level view of a software system when considering the task of abstracting runtime information. We focus on object-oriented virtual machine based languages. We want to be able to deal with the runtime system as a collection of reified first-class entities. We propose to achieve this by introducing a layer of abstraction, i.e., a behavioral middle layer. This has the advantage that the task of collecting dynamic information is not concerned with low level details of a specific language or virtual machine.  The positive effect of such a behavioral middle layer is twofold: on the one hand it provides us with a standard API for all dynamic analysis based tools to use, on the other hand it allows the tool developer to abstract from the actual implementation technique.},
  annote = {internationalworkshop},
  author = {Marcus Denker and Orla Greevy and Michele Lanza},
  booktitle = {2nd International Workshop on Program Comprehension
                  through Dynamic Analysis (PCODA 2006)},
  keywords = {scg-pub skip-doi snf07 jb07 fb06 reflectivity fromscgbib marcusdenker},
  medium = {2},
  pages = {32--38},
  peerreview = {yes},
  title = {Higher Abstractions for Dynamic Analysis},
  url = {http://rmod.lille.inria.fr/archives/workshops/Denk06c-PCODA06-HigherAbstractions.pdf},
  year = {2006}
}



@inproceedings{Denk07a,
  abstract = {Over the last few years, we actively participated in the maintenance and evolution of Squeak, an open-source Smalltalk. The community is constantly faced with the problem of enabling changes while at the same time preserving compatibility. In this paper we describe the current situation, the problems that faced the community and we outline the solutions that have been put in place. We also identify some areas where problems continue to exist and propose these as potential problems to addressed by the research community.},
  aeres = {ACT},
  aeresstatus = {aeres08},
  annote = {internationalworkshop},
  author = {Marcus Denker and St\'ephane Ducasse},
  booktitle = {Proceedings of the ERCIM Working Group on Software Evolution (2006)},
  doi = {10.1016/j.entcs.2006.08.003},
  inria = {hors},
  issn = {1571-0661},
  keywords = {scg07 stefPub scg-pub snf06 recast06 jb07 marcusdenker fromscgbib},
  medium = {2},
  month = jan,
  pages = {81--91},
  peerreview = {yes},
  publisher = {Elsevier},
  selectif = {non},
  series = {Electronic Notes in Theoretical Computer Science},
  title = {Software Evolution from the Field: an Experience
                  Report from the {Squeak} Maintainers},
  url = {http://rmod.lille.inria.fr/archives/workshops/Denk07a-Ercim06-EvolutionSqueak.pdf},
  volume = {166},
  year = {2007}
}

@inproceedings{Denk07b,
  abstract = {Reflection has proved to be a powerful feature to support the design of development environments and to extend languages. However, the granularity of structural reflection stops at the method level.  This is a problem since without sub-method reflection developers have to duplicate efforts, for example to introduce transparently pluggable type-checkers or fine-grained profilers. In this paper we present Persephone, an efficient implementation of a sub-method meta-object protocol (MOP) based on AST annotations and dual methods (a compiled method and its meta-object) that reconcile AST expressiveness with bytecode execution. We validate the MOP by presenting TreeNurse, a method instrumentation framework and TypePlug, an optional, pluggable type system which is based on Persephone.},
  aeres = {ACT},
  aeresstatus = {aeres08},
  annote = {internationalconference},
  author = {Marcus Denker and St\'ephane Ducasse and Adrian Lienhard and Philippe Marschall},
  booktitle = {Journal of Object Technology, Special Issue.  Proceedings of TOOLS Europe 2007},
  inria = {hors},
  issn = {1660-1769},
  keywords = {scg07 scg-pub jb08 snf07 skip-doi jot snf-bmcc
                  reflectivity fromscgbib marcusdenker},
  medium = {2},
  month = oct,
  pages = {231--251},
  peerreview = {yes},
  publisher = {ETH},
  selectif = {non},
  title = {Sub-Method Reflection},
  url = {http://rmod.lille.inria.fr/archives/papers/Denk07b-TOOLS07-Submethod.pdf},
  volume = {6/9},
  year = {2007}
}


@inproceedings{Denk07c,
  abstract = {Real world software systems change continuously to meet new demands. Most programming languages and development environments, however, are more concerned with limiting the effects of change rather than enabling and exploiting change. Various techniques and technologies to exploit change have been developed over the years, but there exists no common support for these approaches. We propose Changeboxes as a general-purpose mechanism for encapsulating change as a first-class entity in a running software system. Changeboxes support multiple, concurrent and possibly inconsistent views of software artifacts within the same running system.  Since Changeboxes are first-class, they can be manipulated to control the scope of change in a running system.Furthermore, Changeboxes capture the semantics of change. Changeboxes can be used, for example, to encapsulate refactorings, or to replay or analyze the history of changes. In this paper we introduce Changeboxes by means of a prototype implementation. We illustrate the benefits that Changeboxes offer for evolving software systems, and we present the results of a preliminary performance evaluation that assesses the costs associated with Changeboxes while suggesting possible strategies for improvement.},
  annote = {internationalconference},
  author = {Marcus Denker and Tudor G\^irba and Adrian Lienhard and Oscar Nierstrasz and Lukas Renggli and Pascal Zumkehr},
  booktitle = {Proceedings of the 2007 International Conference on Dynamic Languages (ICDL 2007)},
  publisher = {ACM Digital Library},
  isbn = {978-1-60558-084-5},
  peer = {yes},
  keywords = {scg07 scg-pub jb08 snf08 girba cop-lit marcusdenker fromscgbib},
  pages = {25--49},
  url = {http://rmod.lille.inria.fr/archives/papers/Denk07c-ICDL07-Changeboxes.pdf},
  doi = {10.1145/1352678.1352681},
  title = {Encapsulating and Exploiting Change with {Changeboxes}},
  year = {2007}
}

@inproceedings{Denk07d,
  abstract = {The dynamic analysis approach to feature identification describes a technique for capturing feature behavior and mapping it to source code.  Major drawbacks of this approach are (1) large amounts of data and (2) lack of support for sub-method elements. In this paper we propose to leverage sub-method reflection to identify and model features. We perform an on-the-fly analysis resulting in annotating the operations participating in a feature's behavior with meta-data.The primary advantage of our annotation approach is that we obtain a fine-grained level of granularity while at the same time eliminating the need to retain and analyze large traces for feature analysis.},
  annote = {internationalworkshop},
  author = {Marcus Denker and Orla Greevy and Oscar Nierstrasz},
  booktitle = {Proceedings of the 3rd International Workshop on Program Comprehension through Dynamic Analysis (PCODA 2007)},
  issn = {1872-5392},
  keywords = {scg07 scg-pub skip-doi snf08 jb08 reflectivity fromscgbib marcusdenker},
  medium = {2},
  pages = {29--33},
  peerreview = {yes},
  publisher = {Technische Universiteit Delft},
  title = {Supporting Feature Analysis with Runtime
                  Annotations},
  url = {http://rmod.lille.inria.fr/archives/workshops/Denk07d-PCODA07-FeatureAnnotation.pdf},
  year = {2007}
}

@phdthesis{Denk08a,
  abstract = {Computational reflection is a fundamental mechanism in object oriented languages. Reflection has proved useful in many contexts, such as in the design of development environments, language extension, and the dynamic, unanticipated adaptation of running systems We identify three problems with the current approach to reflection in object oriented languages: partial behavioral reflection needs to be anticipated, structural reflection is limited to the granularity of a method, and behavioral reflection cannot be applied to the whole system. To address these problems, we extend structural reflection to cover sub-method elements and present how sub-method structural reflection supports unanticipated partial behavioral reflection. We add the concept of context to represent meta-level execution and show how this allows behavioral reflection to be applied even to system classes. We describe an implementation in Smalltalk. Benchmarks validate the practicability of our approach. In addition, we present an experimental evaluation in which we show how the system is used for dynamic analysis. We realize dynamic feature analysis by annotating the sub-method structure of the system directly to denote features instead of recording full execution traces.},
  author = {Marcus Denker},
  keywords = {scg-phd snf08 jb08 reflectivity marcusdenker fromscgbib},
  month = may,
  school = {University of Bern},
  title = {Sub-method Structural and Behavioral Reflection},
  type = {{PhD} thesis},
  url = {http://rmod.lille.inria.fr/archives/phd/PhD-2008-Denker.pdf},
  year = {2008}
}

@inproceedings{Denk08b,
  abstract = {Behavioral reflection is crucial to support for example functional upgrades, on-the-fly debugging, or monitoring critical applications. However the use of reflective features can lead to severe problems due to infinite metacall recursion even in simple cases. This is especially a problem when reflecting on core language features since there is a high chance that such features are used to implement the reflective behavior itself. In this paper we analyze the problem of infinite meta-object call recursion and solve it by providing a first class representation of meta-level execution: at any point in the execution of a system it can be determined if we are operating on a meta-level or base level so that we can prevent infinite recursion. We present how meta-level execution can be represented by a meta-context and how reflection becomes context-aware. Our solution makes it possible to freely apply behavioral reflection even on system classes: the meta-context brings stability to behavioral reflection. We validate the concept with a robust implementation and we present benchmarks.},
  annote = {internationalconference},
  author = {Marcus Denker and Mathieu Suen and St\'ephane Ducasse},
  booktitle = {Proceedings of TOOLS EUROPE 2008},
  peer = {yes},
  pages = {218--237},
  aeres = {ACT},
  aeresstatus = {aeres12},
  inria = {RMOD},
  selectif = {non},
  issn = {1865-1348},
  keywords = {scg-pub jb08 fb08 snf08 reflectivity marcusdenker remoose},
  publisher = {Springer-Verlag},
  series = {LNBIP},
  volume = 11,
  doi = {10.1007/978-3-540-69824-1_13},
  url = {http://rmod.lille.inria.fr/archives/papers/Denk08b-Tools08-MetaContext.pdf},
  title = {The Meta in Meta-object Architectures},
  hal = {inria-00271286,p56w09p},
  year = {2008}
}

@inproceedings{Denk10a,
  abstract = {A feature represents a functional requirement fulfilled by a system. Since many maintenance tasks are expressed in terms of features, it is important to establish the correspondence between a feature and its implementation in source code.  Traditional approaches to establish this correspondence exercise features to generate a trace of runtime events, which is then processed by post-mortem analysis.  These approaches typically generate large amounts of data to analyze. Due to their static nature, these approaches do not support incremental and interactive analysis of features. We propose a radically different approach called live feature analysis, which provides a model at runtime of features. Our approach analyzes features on a running system and also makes it possible to grow feature representations by exercising different scenarios of the same feature, and identifies execution elements even to the sub-method level.  We describe how live feature analysis is implemented effectively by annotating structural representations of code based on abstract syntax trees. We illustrate our live analysis with a case study where we achieve a more complete feature representation by exercising and merging variants of feature behavior and demonstrate the efficiency or our technique with benchmarks.},
  author = {Marcus Denker and Jorge Ressia and Orla Greevy and Oscar Nierstrasz},
  keywords = {snf10 jb11 scg-pub lse-pub marcusdenker},
  month = oct,
  title = {Modeling Features at Runtime},
  booktitle = {Proceedings of MODELS 2010 Part II},
  publisher = {Springer-Verlag},
  series = {LNCS},
  volume = 6395,
  pages = {138--152},
  year = {2010},
  inriareport = {2010},
  inria = {RMOD},
  peer = {yes},
  ISBN         = {978-3-642-16128-5},
  doi 		   = {10.1007/978-3-642-16129-2\_11},
  url = {http://rmod.lille.inria.fr/archives/papers/Denk10a-Models10-FeatureModels.pdf},
  misc = {Acceptance rate: 20.8\%},
  x-proceedings = {yes},
  x-international-audience = {yes}
}


@inproceedings{Dery96a,
  annote = {nationalconference},
  author = {Anne-Marie Dery and St\'ephane Ducasse and Mireille
                  Fornarino},
  booktitle = {Actes d'Interfaces Hommes Machine (IHM'96)},
  keywords = {stefPub},
  title = {Inhibition et resynchronisation des contr\^oleurs de dialogue},
  year = {1996}
}

@incollection{Dery96b,
  annote = {articlebook},
  author = {Anne-Marie Dery and St\'ephane Ducasse and Mireille Fornarino},
  booktitle = {Ing\'eni\`erie Objet},
  editor = {O. Mourad},
  keywords = {stefPub},
  note = {ISBN: 2-7296-0642-4},
  pages = {131--155},
  publisher = {Inter-Editions},
  title = {Objets et D\'ependances},
  year = {1996}
}

@techreport{Dery96c,
  annote = {report notrefereed},
  author = {Anne-Marie Dery and St\'ephane Ducasse and Mireille Fornarino},
  institution = {Laboratoire I3S},
  keywords = {stefPub},
  number = {I3S Lab, RR-96-06},
  title = {A New Vision of Control in the {PAC} Model},
  year = {1996}
}

@article{Dias03a,
 author = {M\'{a}rcio G. B. Dias and Nicolas Anquetil and K\'{a}thia M. de Oliveira},
 title = {Organizing the Knowledge Used in Software Maintenance},
 journal = {Journal of Universal Computer Science},
 year = {2003},
 volume = {9},
 number = {7},
 pages = {641--658},
 doi = {10.1049/ip-sen:20030581},
 annote = {internationaljournal},
 aeres = {ACLN},
 selectif = {non},
 labo = {non},
 x-editorial-board = {yes},
 x-international-audience = {yes},
 x-pays = {BR}
}

@inproceedings{Dias03b,
  author    = {M{\'a}rcio Greyck Batista Dias and
               Nicolas Anquetil and
               K{\'a}thia Mar\c{c}al de Oliveira},
  title     = {Organizing the Knowledge Used in Software Maintance},
  booktitle = {WM 2003: Professionelles Wissesmanagement - Erfahrungen
               und Visionen, Beitr{\"a}ge der 2. Konferenz Professionelles
               Wissensmanagement},
  year      = {2003},
  pages     = {65-72},
  editor    = {Ulrich Reimer and
               Andreas Abecker and
               Steffen Staab and
               Gerd Stumme},
  volume    = {28},
  isbn      = {3-88579-357-1},
  annote = {internationalworkshop},
 aeres = {ACT},
 selectif = {oui},
 labo = {non},
 x-editorial-board = {yes},
 x-international-audience = {no},
 x-pays = {BR}
}

@inproceedings{Duca00a,
  abstract = {Reengineering is an inherent aspect of modern software development, with its emphasis on iterative and incremental development. The reengineering pattern presented in this paper shows how you can support your understanding during system reengineering by linking your questions or information about the code in the code itself.},
  annote = {internationalworkshop},
  author = {St{\'e}phane Ducasse and Serge Demeyer and Oscar Nierstrasz},
  booktitle = {Proceedings of EuroPLoP '2000},
  keywords = {snf-none olit scg-pub skip-doi jb00 stefPub},
  pages = {209--217},
  title = {Tie Code And Questions: a Reengineering Pattern},
  url = {http://scg.unibe.ch/archive/papers/Duca00aTieCode.pdf},
  year = {2000},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca00aTieCode.pdf}
}


@inproceedings{Duca00b,
  abstract = {Surprising as it may seem, many of the early adopters of the object-oriented paradigm already face a number of problems typically encountered in large-scale legacy systems. The reengineering of those systems often poses problems because of the considerable size and complexity of such systems. In the context of the FAMOOS project we have developed a language independent environment called Moose which can deal with that complexity. This paper describes the architecture of Moose, the tools which have been developed around it and the industrial experiences we have obtained.},
  annote = {internationalworkshop},
  author = {Ducasse, St\'ephane and Lanza, Michele and Tichelaar, Sander},
  booktitle = {Proceedings of CoSET '00 (2nd International Symposium on Constructing Software Engineering Tools)},
  keywords = {components scg-pub skip-doi snf00 jb00 repository
                  abb oorp stefPub moose-pub},
  month = jun,
  title = {Moose: an {Extensible} {Language}-{Independent} {Environment} for {Reengineering} {Object}-{Oriented} {Systems}},
  url = {http://scg.unibe.ch/archive/papers/Duca00bMooseCoset.pdf},
  year = {2000},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca00bMooseCoset.pdf}
}


@inproceedings{Duca00c,
  abstract = {Conditionals -i.e., switch statements, nested ifs- that are used to simulate polymorphism hamper evolution and flexibility of applications. The reengineering patterns presented in this paper show you how to transform conditionals in object-oriented code to improve the flexibility of application.},
  annote = {internationalworkshop},
  author = {St\'ephane Ducasse and Serge Demeyer and Oscar
                  Nierstrasz},
  booktitle = {Proceedings of EuroPLoP '2000},
  keywords = {snf-none skip-doi olit scg-pub jb00 stefPub},
  pages = {219--252},
  title = {Transform Conditionals to Polymorphism},
  url = {http://scg.unibe.ch/archive/papers/Duca00cTransform.pdf},
  year = {2000},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca00cTransform.pdf}
}

@inproceedings{Duca00d,
  abstract = {Tuple spaces have turned out to be one of the most fundamental abstractions for coordinating communicating agents. At the same time, researchers continue to propose new variants of tuple spaces, since no one approach seems to be universally applicable to all problem domains. Some models offer a certain configurability, but existing approaches generally stop at afixed set of configuration options and static configuration at instantiation time. We argue that a more open approach is needed, and present OpenSpaces, an object-oriented framework that supports static configurability through subclassing across several dimensions, as well as dynamic configurability of policies through runtime composition. We introduce OpenSpaces by showing how it can be used to instantiate a typical application, and we present an overview of the framework, implemented in Smalltalk, detailing the various degrees of configurability.},
  address = {Limassol, Cyprus},
  annote = {internationalconference},
  author = {St{\'e}phane Ducasse and Thomas Hofmann and Oscar
                  Nierstrasz},
  booktitle = {Coordination Languages and Models},
  doi = {10.1007/3-540-45263-X_1},
  editor = {Ant{\'o}nio Porto and Gruia-Catalin Roman},
  isbn = {978-3-540-41020-1},
  keywords = {olit scg-pub coordination jb00 scg-coord-00 stefPub},
  misc = {acceptance rate: 18/52 = 35\%},
  accepttotal = {52},
  acceptnum = {18},
  month = sep,
  pages = {1--19},
  series = {LNCS},
  title = {OpenSpaces: An Object-Oriented Framework For Reconfigurable Coordination Spaces},
  url = {http://scg.unibe.ch/archive/papers/Duca00dOpenSpaces.pdf},
  volume = {1906},
  year = {2000}
}

@inproceedings{Duca00f,
  annote = {internationalworkshop},
  author = {St{\'e}phane Ducasse and Michele Lanza and Lukas Steiger},
  booktitle = {ECOOP 2000 International Workshop of Architecture Evolution},
  keywords = {scg-pub skip-abstract skip-pdf skip-doi snf00 jb00
                  stefPub design-recovery moose-pub},
  title = {Supporting Evolution Recovery: a Query-based
                  Approach},
  year = {2000}
}

@techreport{Duca00g,
  annote = {report notrefereed},
  author = {St\'ephane Ducasse and Michele Lanza and Oscar
                  Nierstrasz and Matthias Rieger and Sander Tichelaar},
  institution = {University of Bern},
  keywords = {skip-abstract skip-pdf skip-doi stefPub},
  title = {BEOC Analysis Report},
  year = {2000}
}

@article{Duca00x,
  address = {13 rue du Jura, Paris 13},
  annote = {notrefereed},
  author = {St\'ephane Ducasse and Florence Ducasse},
  journal = {Journal de l'association EPI Enseignement Public et
                  Informatiques},
  keywords = {snf-none scg-pub skip-abstract skip-doi jb00
                  stefPub},
  month = sep,
  number = 97,
  title = {De l'enseignement de concepts informatiques},
  url = {http://scg.unibe.ch/archive/papers/Duca00xExperienceEnseig.pdf},
  volume = 4,
  year = {2000},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca00xExperienceEnseig.pdf}
}

@booklet{Duca00z,
  annote = {lectures},
  author = {St\'ephane Ducasse and Florence Ducasse},
  keywords = {scg-old scg-misc stefPub},
  note = {Support de cours de Technologie, 150 pages, http://www.iam.unibe.ch/~ducasse/},
  title = {Caro, Dis-moi c'est quoi programmer?},
  url = {http://scg.unibe.ch/archive/papers/Duca00zCaroLecturesFr.pdf},
  year = {2000},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca00zCaroLecturesFr.pdf}
}

@article{Duca01a,
  abstract = {The reverse engineering of object-oriented legacy systems presents a number
of problems typically encountered in large-scale legacy systems: the lack of overview and
the need to focus on interesting parts. To help in reverse engineering large
object-oriented legacy systems, we proposed a hybrid approach combining the immediate
appeal of visualisations with the scalability of metrics. However, our approach lacked of a
methodology that guides the reverse engineer. In this paper we present a first methodology
that we developed from our industrial experiments.},
  annote = {nationaljournal},
  author = {St\'ephane Ducasse and Michele Lanza},
  journal = {Technique et science informatiques},
  keywords = {scg-pub skip-doi jb01 snf02 stePub},
  number = {4},
  pages = {539--566},
  title = {Towards a Methodology for the Understanding of Object-Oriented Systems},
  url = {http://scg.unibe.ch/archive/papers/Duca01aTowardsAMethod.pdf},
  volume = {20},
  year = {2001},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca01aTowardsAMethod.pdf}
}

@article{Duca01b,
  abstract = {This article presents the Moose Reengineering
                  Environment, a language-independent tool environment
                  to reverse engineer, i.e., understand, and
                  reengineer software systems, as well as the tools
                  which have been developed around it and the
                  experience, both academic and industrial, we have
                  obtained.},
  annote = {notrefereed},
  author = {St\'ephane Ducasse and Michele Lanza and Sander Tichelaar},
  journal = {Smalltalk Chronicles},
  keywords = {scg-pub skip-doi repository reengineering stefPub moose-pub},
  month = aug,
  title = {The Moose Reengineering Environment},
  url = {http://scg.unibe.ch/archive/papers/Duca01bMoose.pdf
         http://www.smalltalkchronicles.net/edition3-2/Pages/moose.htm},
  year = {2001}
}

@techreport{Duca01c,
  abstract = {Reengineering ob ject-oriented applications is becoming a vital activity in today industry where the developer turnover drains the system oral memory out of the systems themselves and where applications should constantly evolve to meet new requirements.  This document summarizes the research effort led on reverse engineering and reengineering ob ject-oriented legacy systems. It includes (1) the definition of a suitable meta-model for reengineering, FAMIX. This meta-model, even if flat, supports both reverse engineering and code refac- toring analysis, (2) the presentation of a reengineering platform, MOOSE, (3) the evalution of software metrics for reengineer, (4) the definition of simple visual techniques to support large system understanding or finer grain code element, (5) the identification and cure sup- port for duplicated code, (6) the use of dynamic information to support composable views and collaboration extraction, and (7) the identification of reengineer patterns.  Keywords. Meta-Modeling, Language Independence, Reengineering, Reverse Engineering, Code Duplica- tion, Reengineering Patterns, Program Traces, Dynamic Information, Program Visualization, Software Metrics, Refactorings, Interexchange Format, CODECRAWLER, FAMIX, MOOSE, FAMOOS, Smalltalk, Java, C++.},
  annote = {habilitation},
  author = {Ducasse, St\'ephane},
  institution = {Universit\'e Pierre et Marie Curie (Paris 6)},
  keywords = {scg-pub skip-doi jb-none reengineering snf02 stefPub
                  moose-pub},
  month = sep,
  note = {TR University of Bern, Institute of Computer Science
                  and Applied Mathematics --- iam-03-008},
  title = {Reengineering Object-Oriented Applications},
  url = {http://scg.unibe.ch/archive/papers/Duca01cHab.pdf},
  year = {2001},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca01cHab.pdf}
}

@article{Duca01s,
  annote = {vulgarisation},
  author = {Ducasse, St\'ephane},
  journal = {Programmez! Le Magazine du D\'eveloppement},
  keywords = {stefPub},
  month = nov,
  number = 37,
  title = {Squeak: Introspection},
  url = {http://www.iam.unibe.ch/~ducasse/WebPages/Books.html},
  volume = 1,
  year = {2001},
  bdsk-url-1 = {http://www.iam.unibe.ch/~ducasse/WebPages/Books.html},
  x-scientific-popularization = {oui}
}

@article{Duca01t,
  annote = {vulgarisation},
  author = {St\'ephane Ducasse},
  journal = {Programmez! Le Magazine du D\'eveloppement},
  keywords = {stefPub},
  month = oct,
  number = 36,
  title = {Squeak: Classes},
  url = {http://www.iam.unibe.ch/~ducasse/WebPages/Books.html},
  volume = 1,
  year = {2001},
  bdsk-url-1 = {http://www.iam.unibe.ch/~ducasse/WebPages/Books.html},
  x-scientific-popularization = {oui}
}

@article{Duca01u,
  annote = {vulgarisation},
  author = {St\'ephane Ducasse},
  journal = {Programmez! Le Magazine du D\'eveloppement},
  keywords = {stefPub},
  month = sep,
  number = 35,
  title = {Squeak: Syntaxe par l'example},
  url = {http://www.iam.unibe.ch/~ducasse/WebPages/Books.html},
  volume = 1,
  year = {2001},
  bdsk-url-1 = {http://www.iam.unibe.ch/~ducasse/WebPages/Books.html},
  x-scientific-popularization = {oui}
}

@article{Duca01v,
  annote = {vulgarisation},
  author = {St\'ephane Ducasse},
  journal = {Programmez! Le Magazine du D\'eveloppement},
  keywords = {stefPub},
  month = jul,
  number = 34,
  title = {Squeak: Une syntaxe minimaliste},
  url = {http://www.iam.unibe.ch/~ducasse/WebPages/Books.html},
  volume = 1,
  year = {2001},
  bdsk-url-1 = {http://www.iam.unibe.ch/~ducasse/WebPages/Books.html},
   x-scientific-popularization = {oui}
}

@article{Duca01w,
  annote = {vulgarisation},
  author = {St\'ephane Ducasse},
  journal = {Programmez! Le Magazine du D\'eveloppement},
  keywords = {stefPub},
  month = jun,
  number = 33,
  title = {Squeak: Un smalltalk open-source d\'etonnant},
  url = {http://www.iam.unibe.ch/~ducasse/WebPages/Books.html},
  volume = 1,
  year = {2001},
  bdsk-url-1 = {http://www.iam.unibe.ch/~ducasse/WebPages/Books.html},
   x-scientific-popularization = {oui}
}

@techreport{Duca01x,
  author = {St\'ephane Ducasse and Sander Tichelaar},
  institution = {University of Bern},
  keywords = {moose-pub},
  note = {To appear},
  title = {{FAMIX} {Smalltalk} language plug-in},
  year = {2001}
}

@inproceedings{Duca02a,
  abstract = {In this paper we stress the fact that a language and an environment for teaching object-oriented programming should support the anthropomorphic metaphor promoted by the paradigm. We show that all the cultural aspects of Smalltalk, i.e., the vocabulary and the syntax support the object metaphor. In addition, we stress that the programming environment should also support the metaphor. We show that Smalltalk environments offer an important property we named liveness or object proximity that promotes the anthropomorphic perception of objects. By providing excerpt from our forth coming book, we show how Squeak with the Morphic framework reinforces this ability to make object into living entities.},
  annote = {internationalworkshop},
  author = {St\'ephane Ducasse and Roel Wuyts},
  booktitle = {Proceedings of the Ecoop'02 International Educator
                  Symposium},
  keywords = {snf-none stefPub scg-pub skip-doi jb04},
  title = {Supporting Objects as An Anthropomorphic View at Computation or Why {Smalltalk} for Teaching Objects?},
  url = {http://scg.unibe.ch/archive/papers/Duca02aTeacherWorkshop.pdf},
  year = {2002},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca02aTeacherWorkshop.pdf}
}

@article{Duca02v,
  annote = {vulgarisation},
  author = {St\'ephane Ducasse},
  journal = {Programmez! Le Magazine du D\'eveloppement},
  keywords = {stefPub},
  month = sep,
  number = 46,
  title = {Refactoring Browser et SmallLint},
  url = {http://www.iam.unibe.ch/~ducasse/WebPages/Books.html},
  volume = 1,
  year = {2002},
  x-scientific-popularization = {oui},
  bdsk-url-1 = {http://www.iam.unibe.ch/~ducasse/WebPages/Books.html}
}

@article{Duca02w,
  annote = {vulgarisation},
  author = {St\'ephane Ducasse},
  journal = {Programmez! Le Magazine du D\'eveloppement},
  keywords = {stefPub},
  month = jan,
  number = 39,
  title = {SUnit: Ces tests que souvent l'on deteste},
  url = {http://www.iam.unibe.ch/~ducasse/WebPages/Books.html},
  volume = 1,
  year = {2002},
   x-scientific-popularization = {oui},
  bdsk-url-1 = {http://www.iam.unibe.ch/~ducasse/WebPages/Books.html}
}

@article{Duca03a,
  abstract = {Although component-based software development (CBSD) has become mainstream for conventional applications, it has remained elusive for embedded applications due to non-functional constraints. The PECOS project has demonstrated that CBSD can also be applied to severely constrained embedded devices, with timing and memory requirements being taken into account.},
  annote = {notrefereed},
  author = {St\'ephane Ducasse and Oscar Nierstrasz and Roel Wuyts},
  cvs = {ErcimPecos},
  journal = {ERCIM News},
  keywords = {scg-pub skip-doi pecos jb03 stefPub},
  month = jan,
  title = {Composing Embedded Real-Time Software Components: the {PECOS} Data-Centric Approach},
  url = {http://www.ercim.org/publication/Ercim_News/enw52/nierstrasz.html},
  volume = 52,
  year = {2003},
  bdsk-url-1 = {http://www.ercim.org/publication/Ercim_News/enw52/nierstrasz.html}
}

@inproceedings{Duca03b,
  abstract = {Current languages contain visibility mechanisms such as private, protected, or public to control who can see what. However, these visibility mechanisms are fixed once for all. Moreover, they do not solve all problems related to the visibility, and are typically of a static nature. In this position paper we present an open and uniform way of dealing with visibility and introduce surfaces: i.e., list of methods that control the way the behavior of an ob ject is accessible. We introduce two problems that other visibility mechanisms cannot solve, and show how surfaces can.},
  annote = {internationalworkshop},
  author = {St\'ephane Ducasse and Nathanael Sch{\"a}rli and Roel Wuyts},
  booktitle = {Proceedings of the ECOOP '03 Workshop on Object-oriented Language Engineering for the Post-Java Era},
  keywords = {snf03 scg-pub skip-doi jb03 stefPub schaerli},
  month = jul,
  title = {Open Surfaces for Controlled Visibility},
  url = {http://scg.unibe.ch/archive/papers/Duca03bSurfaces.pdf},
  year = {2003},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca03bSurfaces.pdf}
}

@inproceedings{Duca03c,
  abstract = {Array programming shines in its ability to express computations at a high-level of abstraction, allowing one to manipulate and query whole sets of data at once. This paper presents the OOPAL model that enhances object-oriented programming with array programming features. The goal of OOPAL is to determine a minimum set of modifications that must be made to the traditional object model in order to take advantage of the possibilities of array programming. It is based on a minimal extension of method invocation and the definition of a kernel of methods implementing the fundamental array programming operations. The model is validated in F-SCRIPT, a new scripting language.},
  annote = {internationalworkshop},
  author = {St\'ephane Ducasse and Philippe Mougin},
  booktitle = {Proceedings of the ECOOP '03 Workshop on Object-oriented Language Engineering for the Post-Java Era},
  keywords = {snf03 scg-pub skip-doi jb03 stefPub},
  month = jul,
  title = {Power to Collections: Generalizing Polymorphism by Unifying Array Programming and Object-Oriented Programming},
  url = {http://scg.unibe.ch/archive/papers/Duca03cOOPALEcoop.pdf},
  year = {2003},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca03cOOPALEcoop.pdf}
}

@article{Duca03d,
  abstract = {Over the last decade many research groups and commercial companies have been developing reengineering environments. However, many design decisions such as support for multiple models, incremental loading of information, tool integration, entity grouping, and their impacts on the underlying meta-model and resulting environment have remained implicit. Based on the experience accumulated while developing the Moose reengineering environment and on a survey of reengineering environments, we present a design space defined by a set of criteria that makes explicit the different options and especially their dependencies and trade-offs. Using this design space, developers of future environments should have a better understanding of the problems they face and the impact of design choices.},
  annote = {internationaljournal},
  author = {St\'ephane Ducasse and Sander Tichelaar},
  doi = {10.1002/smr.279},
  journal = {Journal of Software Maintenance and Evolution: Research and Practice (JSME)},
  keywords = {scg-pub recast04 jb04 stefPub moose-pub},
  misc = {5 Year ISI impact factor 1.523 (2010)},
  impactfactor = {5 Year ISI impact factor 1.523 (2010)},
  month = oct,
  number = 5,
  pages = {345--373},
  title = {Dimensions of Reengineering Environment Infrastructures},
  url = {http://scg.unibe.ch/archive/papers/Duca03dInfrastructures.pdf},
  volume = 15,
  year = {2003},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca03dInfrastructures.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1002/smr.279}
}

@misc{Duca03e,
  abstract = {SUnit is a minimal yet powerful framework that supports the creation of tests. In this article we start by discussing why we test, then we present an example with SUnit and we go deep into the SUnit implementation.},
  author = {St\'ephane Ducasse},
  title = {{SUnit} Explained},
  url = {http://www.iam.unibe.ch/~ducasse/Programmez/OnTheWeb/SUnitEnglish2.pdf},
  bdsk-url-1 = {http://www.iam.unibe.ch/~ducasse/Programmez/OnTheWeb/SUnitEnglish2.pdf}
}

@article{Duca03w,
  annote = {vulgarisation},
  author = {St\'ephane Ducasse},
  journal = {Programmez! Le Magazine du D\'eveloppement},
  keywords = {stefPub},
  month = may,
  number = 53,
  title = {Seaside: Des composants pour le web},
  url = {http://www.iam.unibe.ch/~ducasse/WebPages/Books.html},
  volume = 1,
  year = {2003},
  bdsk-url-1 = {http://www.iam.unibe.ch/~ducasse/WebPages/Books.html}
}

@article{Duca03x,
  annote = {vulgarisation},
  author = {St\'ephane Ducasse},
  journal = {Programmez! Le Magazine du D\'eveloppement},
  keywords = {stefPub},
  month = apr,
  number = 52,
  title = {Seaside: Des applications web complexes simplement...},
  url = {http://www.iam.unibe.ch/~ducasse/WebPages/Books.html},
  volume = 1,
  year = {2003},
  bdsk-url-1 = {http://www.iam.unibe.ch/~ducasse/WebPages/Books.html}
}

@article{Duca03y,
  annote = {vulgarisation},
  author = {St\'ephane Ducasse},
  journal = {Programmez! Le Magazine du D\'eveloppement},
  keywords = {stefPub},
  month = mar,
  number = 51,
  title = {Squeak: R\'eflexion pour Prototyper},
  url = {http://www.iam.unibe.ch/~ducasse/WebPages/Books.html},
  volume = 1,
  year = {2003},
  bdsk-url-1 = {http://www.iam.unibe.ch/~ducasse/WebPages/Books.html}
}

@article{Duca03z,
  annote = {vulgarisation},
  author = {St\'ephane Ducasse},
  journal = {Programmez! Le Magazine du D\'eveloppement},
  keywords = {stefPub},
  month = feb,
  number = 50,
  title = {Espionnage en Squeak},
  url = {http://www.iam.unibe.ch/~ducasse/WebPages/Books.html},
  volume = 1,
  year = {2003},
  bdsk-url-1 = {http://www.iam.unibe.ch/~ducasse/WebPages/Books.html}
}

@inproceedings{Duca04a,
  abstract = {Understanding the run-time behavior of object-oriented legacy systems is a complex task due to factors such as late binding and polymorphism.  Current approaches extract and use information from the complete execution trace of a system. The sheer size and complexity of such traces make their handling, storage, and analysis difficult. Current software systems which run almost non-stop do not permit such a full analysis. In this paper we present a lightweight approach based on the extraction of a condensed amount of information, e.g., measurements, that does not require a full trace. Using this condensed information, we propose a visualization approach which allows us to identify and understand certain aspects of the objects' lifetime such as their role played in the creation of other objects and the communication architecture they support.},
  address = {Los Alamitos CA},
  annote = {internationalconference},
  author = {St\'ephane Ducasse and Michele Lanza and Roland Bertuli},
  booktitle = {Proceedings of 8th European Conference on Software Maintenance and Reengineering (CSMR'04)},
  doi = {10.1109/CSMR.2004.1281433},
  keywords = {recast04 scg-pub stefPub jb04 moose-pub},
  misc = {acceptance rate: 33/62 = 52\%},
  accepttotal = {62},
  acceptnum = {33},
  pages = {309--318},
  publisher = {IEEE Computer Society Press},
  title = {High-Level Polymetric Views of Condensed Run-Time Information},
  url = {http://scg.unibe.ch/archive/papers/Duca04aRuntimePolymetricViews.pdf},
  year = {2004},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca04aRuntimePolymetricViews.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1109/CSMR.2004.1281433}
}

@inproceedings{Duca04b,
  abstract = {Due to the size and the extreme complexity of legacy systems, it is nearly impossible to write from scratch tests before refactoring them. In addition object-oriented legacy systems present specific requirements to test them. Indeed late-binding allow subclasses to change fundamental aspects of the superclass code and in particular call flows.  Moreover Object-oriented programming promotes a distribution of the responsibilities to multiple entities leading to complex scenario to be tested.  In such a context one of the few trustable source of information is the execution of the application itself. Traditional forward engineering approaches such as unit testing do not really provide adequate solution to this problem. Therefore there is a need for a more expressive way of testing the execution of object-oriented applications. We propose to represent the trace of object-oriented applications as logic facts and express tests over the trace.  This way complex sequences of message exchanges, sequence matching, or expression of negative information are expressed in compact form. We validated our approach by implementing TestLog a prototype tool and testing the Moose reengineering environment and a meta-interpreter.},
  annote = {internationalworkshop},
  author = {St\'ephane Ducasse and Michael Freidig and Roel Wuyts},
  booktitle = {Fifth International Workshop on Object-Oriented
                  Reengineering (WOOR 2004)},
  keywords = {scg-pub skip-doi recast04 jb04 evolution
                  visualization test stefPub},
  title = {Logic and Trace-based Object-Oriented Application
                  Testing},
  url = {http://scg.unibe.ch/archive/papers/Duca04bTestLogicWoor04.pdf},
  year = {2004},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca04bTestLogicWoor04.pdf}
}

@techreport{Duca04d,
  abstract = {Understanding packages is an important activity in the reengineering of large object-oriented systems.  The relationships between packages and their contained classes can affect the cost of modifying the system. The main problem of this task is to quickly grasp the structure of a package and how it interacts with the rest of the system. In this paper we present a top-down program comprehension strategy based on polymetric views, radar charts, and software metrics. We illustrate this approach on two applications and show how we can retrieve the important characteristics of packages.},
  annote = {report notrefereed},
  author = {St\'ephane Ducasse and Michele Lanza and Laura
                  Ponisio},
  institution = {University of Bern, Institut of Applied Mathematics
                  and Computer Sciences},
  keywords = {jb05 scg-pub skip-doi stefPub snf04 recast05
                  moose-pub},
  number = {IAM-04-007},
  title = {A Top-Down Program Comprehension Strategy for
                  Packages},
  type = {Technical Report},
  url = {http://scg.unibe.ch/archive/papers/Duca04dPackageVisualization.pdf},
  year = {2004},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca04dPackageVisualization.pdf}
}

@inproceedings{Duca04e,
  abstract = {Developing web applications is difficult since (1) the client-server relationship is asymmetric: the server cannot update clients but only responds to client requests and (2) the navigation facilities of web browsers lead to a situation where servers cannot control the state of the clients.  Page-centric web application frameworks fail to offer adequate solutions to model control flow at a high-level of abstraction. Developers have to work manually around the shortcomings of the HTTP protocol. Some approaches offer better abstractions by composing an application out of components, however they still fail to offer modeling control flow at a high level. Continuation-based approaches solve this problem by providing the facilities to model a control flow over several pages with one piece of code. However combining multiple flows inside the same page is difficult. This article presents Seaside. Seaside is a framework which combines an object-oriented approach with a continuation-based one. A Seaside application is built out of components (i.e., objects) and the logic of the application benefits from the continuation-based program flow infrastructure.  Seaside offers a unique way to have multiple control flows on a page, one for each component. This enables the developer to write components that are highly reusable and that can be used to compose complex web applications with higher quality in less time.},
  annote = {internationalconference},
  author = {St\'ephane Ducasse and Adrian Lienhard and Lukas Renggli},
  booktitle = {Proceedings of 12th International Smalltalk Conference (ISC'04)},
  cvs = {seaside},
  keywords = {scg-pub skip-doi jb05 snf05 stefPub seaside-article},
  misc = {Also Technical Report IAM-04-008},
  month = sep,
  pages = {231--257},
  title = {Seaside --- a Multiple Control Flow Web Application Framework},
  url = {http://scg.unibe.ch/archive/papers/Duca04eSeaside.pdf
                  http://www.iam.unibe.ch/publikationen/techreports/2004/iam-04-008},
  year = {2004},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca04eSeaside.pdf%20http://www.iam.unibe.ch/publikationen/techreports/2004/iam-04-008}
}

@inproceedings{Duca04f,
  abstract = {The histories of software systems hold useful information when reasoning about the systems at hand or about general laws of software evolution. Yet, the approaches developed so far, do not rely on an explicit meta-model and do not facilitate the comparison of different evolutions. We argue for the need to define history as a first class entity and propose a meta-model centered around the notion of history. We show the usefulness of our a meta-model by discussing the different analysis it enables.},
  address = {Amsterdam},
  annote = {internationalworkshop},
  author = {St\'ephane Ducasse and Tudor G\^irba and Jean-Marie Favre},
  booktitle = {Proceedings Workshop on Software Evolution Through Transformation (SETra 2004)},
  doi = {10.1016/j.entcs.2004.08.035},
  keywords = {scg-pub evolution van stefPub recast05 jointERCIM
                  girba hismo jb05 moose-pub},
  pages = {75--86},
  publisher = {Elsevier},
  title = {Modeling Software Evolution by Treating History as a First Class Entity},
  url = {http://scg.unibe.ch/archive/papers/Duca04fHismo.pdf},
  year = {2004},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca04fHismo.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1016/j.entcs.2004.08.035}
}

@incollection{Duca05a,
  abstract = {Software systems are complex and difficult to analyze. Reverse engineering is a complex analysis that usually involves combining different techniques and tools. Moreover, oftentimes the existing tools are not perfectly suitable for the task, and customization of existing tools, or development of new tools is required. Moose is an extensible reengineering environment designed to provide the necessary infrastructure for tool integration. Moose centers on a language independent meta-model, and offers services like grouping, querying, navigation, and advanced tool integration mechanism.},
  address = {Milano},
  aeres = {OS},
  aeresstatus = {aeres08},
  annote = {articlebook},
  author = {St\'ephane Ducasse and Tudor G\^irba and Michele
                  Lanza and Serge Demeyer},
  booktitle = {Tools for Software Maintenance and Reengineering},
  inria = {hors},
  isbn = {88-464-6396-X},
  keywords = {moose-pub scg-pub skip-doi jb05 recast05 stefPub
                  jointERCIM girba},
  pages = {55--71},
  publisher = {Franco Angeli},
  series = {RCOST / Software Technology Series},
  title = {Moose: a Collaborative and Extensible Reengineering
                  Environment},
  url = {http://scg.unibe.ch/archive/papers/Duca05aMooseBookChapter.pdf},
  year = {2005},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca05aMooseBookChapter.pdf}
}

@article{Duca05b,
  abstract = {Understanding source code is an important task in the maintenance of software systems. Legacy systems are not only limited to procedural languages, but are also written in object-oriented languages. In such a context, understanding classes is a key activity as they are the cornerstone of the object-oriented paradigm and the primary abstraction from which applications are built. Such an understanding is however difficult to obtain because of reasons such as the presence of late binding and inheritance. A first level of class understanding consists of the understanding of its overall structure, the control flow among its methods, and the accesses on its attributes. We propose a novel xvisualization of classes called class blueprint that is based on a semantically enriched visualization of the internal structure of classes. This visualization allows a software engineer to build a first mental model of a class that he validates via opportunistic code-reading. Furthermore, we have identified visual patterns that represent recurrent situations and as such convey additional information to the viewer. The contributions of this article are the class blueprint, a novel visualization of the internal structure of classes, the identification of visual patterns, and the definition of a vocabulary based on these visual patterns. We have performed several case studies of which one is presented in depth, and validated the usefulness of the approach in a controlled experiment.},
  aeres = {ACL},
  aeresstatus = {aeres08},
  annote = {internationaljournal},
  author = {St\'ephane Ducasse and Michele Lanza},
  doi = {10.1109/TSE.2005.14},
  impactfactor = {5 Year ISI impact factor 4.865 (2010)},
  inria = {hors},
  journal = {Transactions on Software Engineering (TSE)},
  keywords = {hasler07 jb05 scg-pub stefPub recast05 mooseCincom
                  moose-pub},
  misc = {5-year ISI impact factor 4.865 (2010)},
  month = jan,
  number = {1},
  pages = {75--90},
  publisher = {IEEE Computer Society},
  selectif = {oui},
  title = {The {Class} {Blueprint}: Visually Supporting the Understanding of Classes},
  url = {http://scg.unibe.ch/archive/papers/Duca05bTSEClassBlueprint.pdf},
  volume = {31},
  year = {2005},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca05bTSEClassBlueprint.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1109/TSE.2005.14}
}

@inproceedings{Duca05d,
  annote = {internationalworkshop},
  author = {St\'ephane Ducasse and Tudor G\^irba},
  booktitle = {Proceedings of CHASE International Workshop 2005},
  keywords = {stefPub girba jb05},
  title = {Being a Long-Living Software Mayor --- the SimCity Metaphor to Explain the Challenges Behind Software Evolution},
  url = {http://scg.unibe.ch/archive/papers/Duca05dChaseSimCity.pdf},
  year = {2005},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca05dChaseSimCity.pdf}
}

@inproceedings{Duca05e,
  abstract = {Understanding sets of classes, or packages, is an important activity in the
development and reengineering of large object-oriented systems. Packages represent the
coarse-grained structure of an application. They are artefacts to deploy and structure
software, and therefore more than a simple generalization of classes. The relationships
between packages and their contained classes are key in the decomposition of an application
and its (re)-modularisation. However, it is difficult to quickly grasp the structure of a
package and to understand how a package interacts with the rest of the system. We tackle
this problem using butterfly visualizations, i.e. dedicated radar charts built from simple
package metrics based on a language-independent meta-model. We illustrate our approach on
two applications and show how we can retrieve the relevant characteristics of packages.},
  aeres = {ACT},
  aeresstatus = {aeres08},
  annote = {internationalconference},
  author = {St\'ephane Ducasse and Michele Lanza and Laura Ponisio},
  booktitle = {Proceedings of the 11th IEEE International Software Metrics Symposium (METRICS'05)},
  cvs = {AlchemistPackageMETRICS05},
  doi = {10.1109/METRICS.2005.15},
  inria = {hors},
  keywords = {jb06 scg-pub stefPub moose-pub recast06},
  misc = {acceptance rate: 39/89 = 44\%},
  accepttotal = {89},
  acceptnum = {39},
  pages = {70--77},
  publisher = {IEEE Computer Society},
  rate = {44%},
  selectif = {non},
  title = {Butterflies: A Visual Approach to Characterize Packages},
  url = {http://rmod.lille.inria.fr/archives/papers/Duca05e-Metrics-Butterflies-Ponisio.pdf},
  secondurl = {http://rmod.lille.inria.fr/archive/papers/Duca05ePackageVisualization.pdf},
  year = {2005}
}

@inproceedings{Duca05f,
  abstract = {Software systems are complex and difficult to analyze. Reengineering is a complex activity that usually involves combining different techniques and tools. Moose is an reengineering environment designed to provide the necessary infrastructure for building new tools and for integrating them. Moose centers on a language independent meta-model, and offers services like grouping, querying, navigation, and meta-descriptions. Several tools have been built on top of Moose dealing with different aspects of reengineering like: visualization, evolution analysis, semantic analysis, concept analysis or dynamic analysis.},
  annote = {conference tooldemo},
  author = {St\'ephane Ducasse and Tudor G\^irba and Oscar
                  Nierstrasz},
  booktitle = {Proceedings of ESEC/FSE 2005},
  cvs = {MooseDemoESEC05},
  doi = {10.1145/1081706.1081723},
  keywords = {scg-pub moose-pub stefPub jb06 recast06 girba},
  month = sep,
  note = {Tool demo},
  pages = {99--102},
  title = {{Moose}: an Agile Reengineering Environment},
  url = {http://scg.unibe.ch/archive/papers/Duca05fMooseDemo.pdf},
  year = {2005},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca05fMooseDemo.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1145/1081706.1081723}
}

@article{Duca05g,
  abstract = {In pure object-oriented languages, classes are objects, instances of other classes called metaclasses. In the same way as classes define the properties of their instances, metaclasses define the properties of classes. It is therefore very natural to wish to reuse class properties, utilizing them amongst several classes. However this introduced metaclass composition problems, i.e., code fragments applied to one class may break when used on another class due to the inheritance relationship between their respective metaclasses.  Numerous approaches have tried to solve metaclass composition problems, but they always resort to an ad-hoc manner of handling conflicting properties, alienating the meta-programmer. We propose a uniform approach that represents class properties as traits, groups of methods that act as a unit of reuse from which classes are composed. Like all the other classes in the system, metaclasses are composed out of traits. This solution supports the reuse of class properties, and their safe and automatic composition based on explicit conflict resolution. The paper discusses traits and our solution, shows concrete examples implemented in the Smalltalk environment Squeak, and compares our approach with existing models for composing class properties.},
  aeres = {ACL},
  aeresstastus = {2008},
  annote = {internationaljournal},
  author = {St\'ephane Ducasse and Nathanael Sch{\"a}rli and
                  Roel Wuyts},
  doi = {10.1016/j.cl.2004.11.003},
  impactfactor = {5 Year ISI impact factor 0.698 (2010)},
  inria = {hors},
  journal = {Journal of Computer Languages, Systems and Structures},
  keywords = {scg08 scg-pub stefPub schaerli jb05 snf05},
  impactfactor = {5 Year ISI impact factor 0.698 (2010)},
  misc = {5 Year ISI impact factor 0.698 (2010)},
  month = dec,
  number = {3-4},
  pages = {143--164},
  peerreview = {yes},
  publisher = {Elsevier},
  selectif = {non},
  title = {Uniform and Safe Metaclass Composition},
  url = {http://scg.unibe.ch/archive/papers/Duca05ySafeMetaclassTrait.pdf},
  volume = {31},
  year = {2005},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca05ySafeMetaclassTrait.pdf}
}

@inproceedings{Duca05h,
  abstract = {Wikis are often implemented using string-based approaches to parse and generate their pages. While such approaches work well for simple wikis, they hamper the customization and adaptability of wikis to the variety of end-users when more sophisticated needs are required (i.e., different output formats, user-interfaces, wiki managment, security policies, ...). In this paper we present SmallWiki, the second version of a fully object-oriented implementation of a wiki. SmallWiki is implemented with objects from the top to the bottom and it can be customized easily to accommodate new needs. In addition, SmallWiki is based on a powerful meta-description called Magritte that allows one to create user-interface elements declaratively.},
  address = {New York, NY, USA},
  aeres = {ACT},
  aeresstatus = {aeres08},
  annote = {internationalconference},
  author = {St\'ephane Ducasse and Lukas Renggli and Roel Wuyts},
  booktitle = {Proceedings ACM International Symposium on Wikis
                  (WikiSym'05)},
  cvs = {SmallWikiTwoOOPSLASymp2005},
  doi = {10.1145/1104973.1104981},
  inria = {hors},
  keywords = {jb06 scg-pub snf-none stefPub moose-pub},
  pages = {75--82},
  publisher = {ACM Computer Society},
  selectif = {non},
  title = {{SmallWiki} --- A Meta-Described Collaborative
                  Content Management System},
  url = {http://scg.unibe.ch/archive/papers/Duca05hSmallwikiWikiSymp05.pdf},
  year = {2005},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca05hSmallwikiWikiSymp05.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1145/1104973.1104981}
}

@inproceedings{Duca05i,
  abstract = {Understanding classes and methods is a key activity in object-oriented programming, since classes represent the primary abstractions from which applications are built, while methods contain the actual program logic. The main problem of this task is to quickly grasp the purpose and inner structure of a class. To achieve this goal, one must be able to overview multiple methods at once. In this paper, we present microprints, pixel-based representations of methods enriched with semantical information. We present three specialized microprints each dealing with a specific aspect we want to understand of methods: (1) state access, (2) control flow, and (3) invocation relationship.},
  annote = {internationalworkshop},
  author = {St\'ephane Ducasse and Michele Lanza and Romain
                  Robbes},
  booktitle = {Proceedings of {VISSOFT} 2005 (3th IEEE
                  International Workshop on Visualizing Software for
                  Understanding)},
  keywords = {scg-pub skip-doi jb06 MISSINGPAGENUMBERS stefPub
                  recast06},
  month = sep,
  title = {Multi-level Method Understanding Using
                  {Microprints}},
  url = {http://scg.unibe.ch/archive/papers/Duca05imicroprintsVissoft.pdf},
  year = {2005},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca05imicroprintsVissoft.pdf}
}

@book{Duca05j,
  aeres = {OV},
  aeresstatus = {aeres08},
  annote = {book},
  author = {St\'ephane Ducasse},
  keywords = {stefPub jb05 scglib},
  note = {ISBN: 1-59059-491-6},
  publisher = {APress},
  title = {Squeak: Learn Programming with Robots},
  year = {2005},
  x-scientific-popularization = {yes}
}

@misc{Duca05k,
  aeres = {OV},
  aeresstastus = {2008},
  annote = {vulgarisation},
  author = {St\'ephane Ducasse and Hilaire Fernandes},
  inria = {hors},
  journal = {Linux Pratique},
  keywords = {stefPub jb05},
  month = mar,
  number = 89,
  pages = {18--23},
  selectif = {non},
  title = {Squeak: un Smalltalk libre multim\'edia},
  volume = 1,
  year = {2005},
  x-scientific-popularization = {yes}
}

@inproceedings{Duca06a,
  abstract = {When reengineering legacy systems, it is crucial to assess if the legacy behavior has been preserved or how it changed due to the reengineering effort.  Ideally if a legacy system is covered by tests, running the tests on the new version can identify potential differences or discrepancies. However, writing tests for an unknown and large system is difficult due to the lack of internal knowledge. It is especially difficult to bring the system to an appropriate state. Our solution is based on the acknowledgment that one of the few trustable piece of information available when approaching a legacy system is the running system itself. Our approach reifies the execution traces and uses logic programming to express tests on them. Thereby it eliminates the need to programatically bring the system in a particular state, and handles the test-writer a high-level abstraction mechanism to query the trace. The resulting system, called TESTLOG, was used on several real-world case studies to validate our claims.},
  aeres = {ACT},
  aeresstatus = {aeres08},
  annote = {internationalconference},
  author = {St\'ephane Ducasse and Tudor G\^irba and Roel Wuyts},
  booktitle = {Proceedings of 10th European Conference on Software
                  Maintenance and Reengineering (CSMR'06)},
  doi = {10.1109/CSMR.2006.37},
  inria = {hors},
  keywords = {scg-pub recast06 snf06 jb06 fb06 stefPub girba},
  medium = {2},
  misc = {acceptance rate: 27/65 = 42 \%},
  accepttotal = {65},
  acceptnum = {27},
  pages = {35--44},
  peerreview = {yes},
  publisher = {IEEE Computer Society Press},
  selectif = {non},
  title = {Object-Oriented Legacy System Trace-based Logic
                  Testing},
  url = {http://scg.unibe.ch/archive/papers/Duca06aTestLogtestingCSMR.pdf},
  year = {2006},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca06aTestLogtestingCSMR.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1109/CSMR.2006.37}
}

@article{Duca06b,
  abstract = {Inheritance is well-known and accepted as a mechanism for reuse in object-oriented languages.  Unfortunately, due to the coarse granularity of inheritance, it may be difficult to decompose an application into an optimal class hierarchy that maximizes software reuse. Existing schemes based on single inheritance, multiple inheritance, or mixins, all pose numerous problems for reuse. To overcome these problems we propose traits, pure units of reuse consisting only of methods. We develop a formal model of traits that establishes how traits can be composed, either to form other traits, or to form classes. We also outline an experimental validation in which we apply traits to refactor a non-trivial application into composable units.},
  aeres = {ACL},
  aeresstatus = {aeres08},
  annote = {internationaljournal},
  author = {St\'ephane Ducasse and Oscar Nierstrasz and Nathanael Sch{\"a}rli and Roel Wuyts and Andrew P.  Black},
  cvs = {TraitsTOPLAS2005},
  doi = {10.1145/1119479.1119483},
  inria = {hors},
  issn = {0164-0925},
  journal = {ACM Transactions on Programming Languages and Systems (TOPLAS)},
  keywords = {scg-pub stefPub snf05 snf06 jb06 toplas traits
                  schaerli toplastraits stlit-traits},
  misc = {5-Year ISI impact factor 1.478 (2010), CORE A*},
  impactfactor = {5-Year ISI impact factor 1.478 (2010), CORE A*},
  miscmisc = {SCI impact factor 1.404 (2005)},
  month = mar,
  number = {2},
  pages = {331--388},
  selectif = {oui},
  title = {Traits: A Mechanism for fine-grained Reuse},
  url = {http://scg.unibe.ch/archive/papers/Duca06bTOPLASTraits.pdf},
  secondurl = {http://scg.unibe.ch/archive/papers/Duca06bTOPLASTraits.pdf},
  volume = {28},
  year = {2006}
}

@inproceedings{Duca06c,
  abstract = {Understanding large software systems is a challenging task, and to support it many approaches have been developed. Often, the result of these approaches categorize existing entities into new groups or associates them with mutually exclusive properties. In this paper we present the Distribution Map as a generic technique to visualize and analyze this type of result. Our technique is based on the notion of focus, which shows whether a property is well-encapsulated or cross-cutting, and the notion of spread, which shows whether the property is present in several parts of the system.  We present a basic visualization and complement it with measurements that quantify focus and spread. To validate our technique we show evidence of applying it on the result sets of different analysis approaches. As a conclusion we propose that the Distribution Map technique should belong to any reverse engineering toolkit.},
  address = {Los Alamitos CA},
  aeres = {ACT},
  aeresstatus = {aeres08},
  annote = {internationalconference},
  author = {St\'ephane Ducasse and Tudor G\^irba and Adrian
                  Kuhn},
  booktitle = {Proceedings of 22nd IEEE International Conference on
                  Software Maintenance (ICSM '06)},
  doi = {10.1109/ICSM.2006.22},
  inria = {hors},
  keywords = {scg-pub jb07 fb06 stefPub moose-pub girba recast07
                  snf06 akuhn},
  medium = {2},
  misc = {acceptance rate: 41/147 = 28\%},
  accepttotal = {147},
  acceptnum = {41},
  pages = {203--212},
  peerreview = {yes},
  publisher = {IEEE Computer Society},
  rate = {28%},
  selectif = {oui},
  title = {Distribution Map},
  url = {http://scg.unibe.ch/archive/papers/Duca06cDistributionMap.pdf},
  year = {2006},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca06cDistributionMap.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1109/ICSM.2006.22}
}

@inproceedings{Duca06d,
  abstract = {Object-oriented meta-languages such as MOF or EMOF are often used to specify domain specific languages.  However, these meta-languages lack the ability to describe behavior or operational semantics. Several approaches used a subset of Java mixed with OCL as executable meta-languages. In this paper, we report our experience of using Smalltalk as an executable and integrated meta-language. We validated this approach in incrementally building over the last decade, Moose, a meta-described reengineering environment. The reflective capabilities of Smalltalk support a uniform way of letting the base developer focus on his tasks while at the same time allowing him to meta-describe his domain model. The advantage of our this approach is that the developer uses the same tools and environment},
  address = {Berlin, Germany},
  aeres = {ACT},
  annote = {internationalconference},
  author = {St\'ephane Ducasse and Tudor G\^irba},
  booktitle = {International Conference on Model Driven Engineering
                  Languages and Systems (Models/UML 2006)},
  doi = {10.1007/11880240\_42},
  inria = {hors},
  isbn = {978-3-540-45772-5},
  keywords = {scg-pub jb07 fb06 girba moose-pub stefPub recast07
                  norex06},
  medium = {2},
  pages = {604--618},
  peerreview = {yes},
  publisher = {Springer-Verlag},
  rate = {28%},
  selectif = {oui},
  series = {LNCS},
  title = {Using {Smalltalk} as a Reflective Executable
                  Meta-Language},
  url = {http://scg.unibe.ch/archive/papers/Duca06dMOOSEMODELS2006.pdf},
  volume = {4199},
  year = {2006},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca06dMOOSEMODELS2006.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1007/11880240_42}
}

@misc{Duca06e,
  aeres = {OV},
  annote = {vulgarisation},
  author = {St\'ephane Ducasse and Hilaire Fernandes},
  inria = {hors},
  journal = {Linux Magazine},
  keywords = {stefPub},
  month = may,
  number = 83,
  pages = {18--23},
  selectif = {non},
  title = {La syntaxe Smalltalk par la pratique},
  volume = 1,
  year = {2006},
  x-scientific-popularization = {yes}
}

@misc{Duca06f,
  aeres = {OV},
  annote = {vulgarisation},
  author = {St\'ephane Ducasse and Serge Stinckwich},
  inria = {hors},
  journal = {Linux Magazine},
  keywords = {stefPub},
  month = sep,
  number = 86,
  selectif = {non},
  title = {Seaside: d\'eveloppement d'applications web en Smalltalk},
  volume = 1,
  year = {2006},
  x-scientific-popularization = {yes}
}

@misc{Duca06g,
  aeres = {OV},
  annote = {vulgarisation},
  author = {St\'ephane Ducasse and Serge Stinckwich},
  inria = {hors},
  journal = {Linux Magazine},
  keywords = {stefPub},
  month = nov,
  number = 88,
  selectif = {non},
  title = {Seaside: d\'evelopper des composants r\'eutilisables},
  volume = 1,
  year = {2006},
  x-scientific-popularization = {yes}
}

@article{Duca06h,
  aeres = {OV},
  annote = {vulgarisation},
  author = {St\'ephane Ducasse and Serge Stinckwich},
  inria = {hors},
  journal = {Linux Magazine},
  keywords = {stefPub},
  month = dec,
  number = 89,
  selectif = {non},
  title = {Smalltalk: un mod\`ele pur objet},
  volume = 1,
  year = {2006},
  x-scientific-popularization = {yes}
}

@article{Duca06i,
  abstract = {Although duplicated code is known to pose severe problems for software maintenance, it is difficult to identify in large systems. Many different techniques have been developed to detect software clones, some of which are very sophisticated, but are also expensive to implement and adapt.  Lightweight techniques based on simple string matching are easy to implement, but how effective are they? We present a simple stringbased approach which we have successfully applied to a number of different languages such COBOL, {Java}, C++, Pascal, Python, Smalltalk, C and PDP-11 assembler. In each case the maximum time to adapt the approach to a new language was less than 45 minutes. In this article we investigate a number of simple variants of string-based clone detection that abstract away from common editing operations, and assess the quality of clone detection for very different case studies. Our results confirm that this inexpensive clone detection technique generally achieves high recall and acceptable precision. Over-zealous normalization of the code before comparison, however, can result in unacceptable numbers of false positives.},
  aeres = {ACT},
  aeresstatus = {aeres08},
  annote = {internationaljournal},
  author = {St\'ephane Ducasse and Oscar Nierstrasz and Matthias
                  Rieger},
  cvs = {DuplocJournalPaper},
  doi = {10.1002/smr.317},
  inria = {hors},
  journal = {Journal of Software Maintenance and Evolution: Research and Practice (JSME)},
  keywords = {scg-pub recast06 jb06 stefPub duploc},
  misc = {5 Year ISI impact factor 1.523 (2010)},
  impactfactor = {5 Year ISI impact factor 1.523 (2010)},
  month = jan,
  number = 1,
  pages = {37--58},
  selectif = {non},
  title = {On the Effectiveness of Clone Detection by String Matching},
  url = {http://scg.unibe.ch/archive/papers/Duca06iDuplocJSMEPaper.pdf},
  volume = 18,
  year = {2006},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca06iDuplocJSMEPaper.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1002/smr.317}
}

@article{Duca07a,
  abstract = {Nowadays, many complex applications are built with a web browser as their main user interface. However, despite the increasing popularity of the web as an application platform, implementing and maintaining web applications still remains difficult and lags behind conventional desktop application development.  The underlying technologies such as HTTP for the interaction and XHTML/CSS for the presentation were originally built to display and link static documents. Unfortunately, most mainstream frameworks provide only little abstraction over the page-oriented structure imposed by those technologies. Inevitably, the goto-like manner of how pages are linked leads to spaghetti code and hampers reuse. In this article we present Seaside, a web application framework that provides an uniform and pure object-oriented view on web applications.  In this way, Seaside avoids the unwieldily goto-like style. Exploiting the reflective features of Smalltalk, Seaside reintroduces procedure call abstraction in the client-server context. Seaside's key concepts are: (i) a component architecture supporting multiple, simultaneously active control flows, (ii) a programmatic XHTML generation, and (iii) fully supported on-the-fly debugging, code-editing, and recompilation. In this article we discuss these key features of Seaside and explain how they are made possible by the dynamic nature and the reflective capabilities of Smalltalk.},
  address = {Los Alamitos, CA, USA},
  aeres = {ACL},
  aeresstatus = {aeres08},
  annote = {internationaljournal},
  author = {St\'ephane Ducasse and Adrian Lienhard and Lukas Renggli},
  doi = {10.1109/MS.2007.144},
  inria = {hors},
  issn = {0740-7459},
  journal = {IEEE Software},
  keywords = {scg07 scg-pub jb08 snf07 seaside-article},
  number = {5},
  pages = {56--63},
  peerreview = {yes},
  publisher = {IEEE Computer Society},
  selectif = {oui},
  title = {Seaside: A Flexible Environment for Building Dynamic Web Applications},
  url = {http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=4302687},
  volume = {24},
  year = {2007},
  misc = {5-year ISI impact factor 2.551 (2010)},
  impactfactor = {5-year ISI impact factor 2.551 (2010)},
  doi = {10.1109/MS.2007.144}
}

@inproceedings{Duca07b,
  abstract = {A trait is a unit of behaviour that can be composed with other traits and used by classes. Traits offer an alternative to multiple inheritance. Conflict resolution of traits, while flexible, does not completely handle accidental method name conflicts: if a trait with method m is composed with another trait defining a different method m then resolving the conflict may prove delicate or infeasible in cases where both versions of m are still needed. In this paper we present freezable traits, which provide an expressive composition mechanism to support unanticipated method composition conflicts.  Our solution introduces private trait methods and lets the class composer change method visibility at composition time (from public to private and vice versa). Moreover two class composers may use different composition policies for the same trait, something which is not possible in mainstream languages. This approach respects the two main design principles of traits: the class composer is empowered and traits can be flattened away. We present an implementation of freezable traits in Smalltalk. As a side-effect of this implementation we introduced private (early-bound and invisible) methods to Smalltalk by distinguishing object-sends from self-sends. Our implementation uses compile-time bytecode manipulation and, as such, introduces no run-time penalties.},
  address = {New York, NY, USA},
  aeres = {ACT},
  aeresstatus = {aeres08},
  annote = {internationalconference topconference},
  author = {St\'ephane Ducasse and Roel Wuyts and Alexandre Bergel and Oscar Nierstrasz},
  booktitle = {Proceedings of 22nd International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA'07)},
  doi = {10.1145/1297027.1297040},
  inria = {hors},
  isbn = {978-1-59593-786-5},
  keywords = {scg07 snf08 stefPub alexPub jb08 scg-pub},
  location = {Montreal, Quebec, Canada},
  medium = {2},
  misc = {Acceptance rate: 33/156:21\%},
  accepttotal = {156},
  acceptnum = {33},
  month = oct,
  pages = {171--190},
  peerreview = {yes},
  publisher = {ACM Press},
  rate = {21%},
  selectif = {oui},
  title = {User-Changeable Visibility: Resolving Unanticipated
                  Name Clashes in Traits},
  url = {http://scg.unibe.ch/archive/papers/Duca07b-FreezableTrait.pdf},
  year = {2007},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca07b-FreezableTrait.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1145/1297027.1297040}
}

@inproceedings{Duca07c,
  abstract = {Large object-oriented applications are structured over large number of packages. Packages are important but complex structural entities that may be difficult to understand since they play different development roles (i.e., class containers, code ownership basic structure, architectural elements...). Maintainers of large applications face the problem of understanding how packages are structured in general and how they relate to each others. In this paper, we present a compact visualization, named Package Surface Blueprint, that qualifies the relationships that a package has with its neighbours. A Package Surface Blueprint represents packages around the notion of package surfaces: groups of relationships according to the packages they refer to. We present two specific views one stressing the references made by a package and another showing the inheritance structure of a package. We applied the visualization on two large case studies: ArgoUML and Squeak.},
  aeres = {ACT},
  aeresstatus = {aeres08},
  annote = {internationalconference stefPub},
  author = {St\'ephane Ducasse and Damien Pollet and Mathieu
                  Suen and Hani Abdeen and Ilham Alloui},
  booktitle = {ICSM '07: Proceedings of the IEEE International
                  Conference on Software Maintenance},
  inria = {hors},
  keywords = {moose-pub},
  misc = {acceptance rate: 46/214 = 21\%},
  accepttotal = {214},
  acceptnum = {46},
  pages = {94--103},
  rate = {21%},
  selectif = {oui},
  title = {Package Surface Blueprints: Visually Supporting the
                  Understanding of Package Relationships},
  url = {http://scg.unibe.ch/archive/papers/Duca07cPackageBlueprintICSM2007.pdf},
  year = {2007},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca07cPackageBlueprintICSM2007.pdf}
}

@misc{Duca07y,
  aeres = {OV},
  aeresstatus = {aeres08},
  annote = {vulgarisation},
  author = {St\'ephane Ducasse and Hilaire Fernandes},
  inria = {hors},
  journal = {Linux Magazine},
  keywords = {stefPub},
  month = mar,
  number = 92,
  pages = {18--23},
  selectif = {non},
  title = {Smalltalk et design patterns, un couple assorti},
  volume = 1,
  year = {2007},
  x-scientific-popularization = {yes}
}

@misc{Duca07z,
  aeres = {OV},
  aeresstatus = {aeres08},
  annote = {vulgarisation},
  author = {St\'ephane Ducasse and Hilaire Fernandes},
  inria = {hors},
  journal = {Linux Magazine},
  keywords = {stefPub},
  month = may,
  number = 94,
  pages = {18--23},
  selectif = {non},
  title = {Tests unitaires en Smalltalk},
  volume = 1,
  year = {2007},
  x-scientific-popularization = {yes}
}

@article{Duca08a,
  annote = {internationaljournal},
  author = {St\'ephane Ducasse and Tudor G\^irba and Adrian Kuhn and Lukas Renggli},
  journal = {Journal of Software and Systems Modeling (SOSYM)},
  publisher = {Springer Verlag},
  title = {Meta-Environment and Executable Meta-Language using {Smalltalk}: an Experience Report},
  aeres = {ACL},
  selectif = {oui},
  labo = {dans},
  inria = {RMOD},
  inriareport = {2009},
  annote = {internationaljournal cook-pub remoose1-pub},
  url = {http://scg.unibe.ch/archive/drafts/Duca08a-Sosym-ExecutableMetaLanguage.pdf},
  doi = {10.1007/s10270-008-0081-4},
  month = feb,
  number = {1},
  pages = {5--19},
  volume = {8},
  year = {2009},
  x-pays = {CH},
  x-editorial-board = {yes},
  x-proceedings = {yes},
  x-international-audience = {yes},
  x-language = {EN},
  abstract = {No abstract}
}

@inproceedings{Duca08b,
  abstract = {The increasing amount of data available about software systems poses new challenges for re- and reverse engineering research, as the proposed approaches need to scale. In this context, concerns about meta-modeling and analysis techniques need to be augmented by technical concerns about how to reuse and how to build upon the efforts of previous research. Moose is an extensive infrastructure for reverse engineering evolved for over 10 years that promotes the reuse of engineering efforts in research. Moose accommodates various types of data modeled in the FAMIX family of meta-models. The goal of this half-day workshop is to strengthen the community of researchers and practitioners who are working in re- and reverse engineering, by providing a forum for building future research starting from Moose and FAMIX as shared infrastructure.},
  annote = {workshop},
  author = {St\'ephane Ducasse and Tudor G\^irba and Orla Greevy and Michele Lanza and Oscar Nierstrasz},
  booktitle = {15th Working Conference on Software Maintenance and Reengineering (WCRE 2008)},
  doi = {10.1109/WCRE.2008.51},
  keywords = {scg08 scg-pub greevy girba jb09 hasler08 moose-pub
                  stefPub},
  month = oct,
  pages = {343--344},
  peerreview = {yes},
  title = {Workshop on {FAMIX} and {Moose} in Software Reengineering ({FAMOOSr} 2008)},
  url = {http://scg.unibe.ch/archive/papers/Duca08bFAMOOSr2008.pdf},
  year = {2008},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca08bFAMOOSr2008.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1109/WCRE.2008.51}
}

@inproceedings{Duca09a,
  author = {Ducasse, St\'ephane and Pollet, Damien and Bergel, Alexandre and Cassou, Damien},
  title = {Reusing and Composing Tests with Traits},
  booktitle = {Proceedings of the 47th International Conference Objects, Models, Components, Patterns (TOOLS-Europe'09)},
  hal = {http://hal.archives-ouvertes.fr/docs/00/40/35/68/PDF/Reusing_Composing.pdf},
  hal-id = {inria-00403568 toberecovered for lse},
  url = {http://rmod.lille.inria.fr/archives/papers/Duca09a-Tools2009-TraitTests.pdf},
  year = {2009},
  keywords = {tools09 traits stefPub},
  month = {jun},
  annote = {internationalconference},
  aeres = {ACL},
  aeresstatus = {aeres12},
  selectif = {oui},
  misc = {acceptance rate: 17/67 = 25\%},
  rate = {24%},
  labo = {dans},
  inria = {RMOD},
  inriareport = {2009},
  pages = {252--271},
  x-editorial-board = {yes},
  x-proceedings = {yes},
  x-international-audience = {yes},
  x-country = {FR},
  x-language = {EN},
  address = {Zurich, Switzerland},
  abstract = {Single inheritance often forces developers to duplicate code and logic. This widely recognized situation affects both business code and tests. In a large and complex application whose classes implement many groups of methods (protocols), duplication may also follow the application's idiosyncrasies, making it difficult to specify, maintain, and reuse tests. The research questions we faced are (i) how can we reuse test specifications across and within complex inheritance hierarchies, especially in presence of orthogonal protocols; (ii) how can we test interface behavior in a modular way; (iii) how far can we reuse and parametrize composable tests. In this paper, we compose tests out of separately specified behavioral units of reuse ---traits. We propose test traits, where: (i) specific test cases are composed from independent specifications; (ii) executable behavior specifications may be reused orthogonally to the class hierarchy under test; (iii) test fixtures are external to the test specifications, thus are easier to specialize. Traits have been successfully applied to test two large and critical class libraries in Pharo, a new Smalltalk dialect based on Squeak, but are applicable to other languages with traits.}
}

@inproceedings{Duca09b,
  author = {Ducasse, St\'ephane and Denker, Marcus and Lienhard, Adrian},
  title = {Evolving a Reflective Language},
  abstract = {Traits are method groups that can be used to compose classes. They do not have a runtime existence and are conceptually folded into the classes that use them. Traits have been implemented in different languages. While implementing them in Smalltalk, our first reflex was to take advantage of the fact that traits are not run-time entities: we optimized the implementation for space and hence shared methods between traits and classes. However, by doing so we broke the introspective API of Smalltalk. This paper illustrates a more general problem seen in all reflective systems: the implementation serves both as a model for execution and as the model that is exposed to the programmer. There is a conflict of interests between the information necessary for execution and the information the programmer is interested in. In addition, as soon as the implementation is exposed via reflection, we are not free to optimize. As the complete implementation is visible reflectively, there is no way to hide the optimizations. Few papers report errors and this is one of them. We report our experience facing the initial API mismatch, which has a significant impact on the system because the language is reflective (i.e., written in itself and causally connected). We present the new introspective API we put in place.},
  booktitle = {Proceedings of the International Workshop on Smalltalk Technologies (IWST 2009)},
  year = {2009},
  keywords = {stefPub internationalworkshop lse-pub},
  month = {aug},
  annote = {internationalworkshop},
  aeres = {ACT},
  aeresstatus = {aeres12},
  selectif = {non},
  labo = {dans},
  inria = {RMOD},
  isbn = {978-1-60558-899-5},
  pages = {82--86},
  location = {Brest, France},
  doi = {10.1145/1735935.1735949},
  publisher = {ACM},
  x-editorial-board = {yes},
  x-proceedings = {yes},
  x-international-audience = {yes},
  x-pays = {CL,CH},
  x-country = {FR},
  x-language = {EN},
  address = {Brest, France},
  url = {http://rmod.lille.inria.fr/archives/workshops/Duca09b-IWST09-TraitMop.pdf}
}

@article{Duca09c,
  abstract = {To maintain and understand large applications, it is crucial to know their
architecture. The first problem is that unlike classes and packages, architecture is not
explicitly represented in the code. The second problem is that successful applications
evolve over time, so their architecture inevitably drifts. Reconstructing the architecture
and checking whether it is still valid is therefore an important aid. While there is a
plethora of approaches and techniques supporting architecture reconstruction, there is no
comprehensive state of the art and it is often difficult to compare the approaches. This
article presents a state of the art in software architecture reconstruction approaches.},
  annote = {internationaljournal},
  author = {Ducasse, St\'ephane and Pollet, Damien},
  journal = {IEEE Transactions on Software Engineering},
  volume = 35,
  number = 4,
  aeres = {ACL},
  aeresstatus = {aeres12},
  selectif = {oui},
  inria = {RMOD},
  inriareport = {2009},
  labo = {dans},
  title = {Software Architecture Reconstruction: A Process-Oriented Taxonomy},
  url = {http://rmod.lille.inria.fr/archives/papers/Duca09c-TSE-SOAArchitectureExtraction.pdf},
  year = {2009},
  misc = {5-Year ISI impact factor 4.865 (2010)},
  impactfactor = {5-year ISI impact factor 4.865 (2010)},
  month = jul,
  pages = {573-591},
  doi = {10.1109/TSE.2009.19},
  x-editorial-board = {yes},
  x-proceedings = {yes},
  x-international-audience = {yes},
  hal-id = {inria-00498407 / @4049m}
}



@techreport{Duca09t,
  author = {St\'ephane Ducasse and Simon Denier and Fran{\c c}oise Balmas and Alexandre Bergel and  Jannik Laval and Karine Mordal-Manet and  Fabrice Bellingard},
  title = {Visualization of Practices and Metrics (Squale Deliverable 1.2)},
  institution = {INRIA},
  keywords = {squale-pub lse-pub deliverable12},
  annote = {technicalreport},
  inria = {RMOD},
  inriareport = {2009},
  year = {2009},
  aeres = {AP},
  type_rapport = {Rapport technique},
  abstract = {No abstract},
  x-language = {EN},
  hal-id = {inria-00533618}
}


@book{Duca10a,
  abstract = {Seaside is the open source framework of choice for developing sophisticated and dynamic web applications. Seaside uses the power of objects to master the web. With Seaside web applications is as simple as building desktop applications. Seaside lets you build highly dynamic and interactive web applications. Seaside supports agile development through interactive debugging and unit testing.  Seaside is based on Smalltalk, a proven and robust language implemented by different vendors. Seaside is now available for all the major Smalltalk including Pharo, Squeak, GNU Smalltalk, Cincom Smalltalk, GemStone Smalltalk, and VA Smalltalk.},
  author = {St\'ephane Ducasse and Lukas Renggli and C. David Shaffer and Rick Zaccone and Michael Davies},
  annote = {book},
  keywords = {scg-pub skip-doi snf-none jb10},
  publisher = {Square Bracket Associates},
  title = {Dynamic Web Development with Seaside},
  url = {http://book.seaside.st/book},
  year = {2010},
  isbn = {978-3-9523341-1-9},
  aeresstatus = {2012},
  x-international-audience = {yes},
  annote = {book},
  inria = {RMOD},
  inriareport = {2010},
  keywords = {skipdoi remoose2-pub pharo-pub},
  x-scientific-popularization = {yes},
  hal-id = {inria-00531503},
  aeres = {OS},
  aeresstatus = {aeres12},
  selectif = {non},
  inria = {RMOD},
  inriareport = {2010},
  labo = {dans},
  x-pays = {CH,US,FR},
  x-country = {CH,US,FR}
}

@article{Duca10z,
  title = {Understanding Packages: The Package Blueprint},
  author = {St\'ephane Ducasse  and Simon Denier and Damien Pollet and Ilham Alloui and Hani Abdeen and Jean-R\'emy Falleri},
  journal = {IEEE Transactions on Software Engineering (TSE) (Accepted with major revisions)},
  annote = {internationaljournal},
  keywords = {insubmission sub lse-pub},
  misc = {5-Year ISI impact factor 4.865 (2010)},
  impactfactor = {5-Year ISI impact factor 4.865 (2010)},
  year = {2010},
  month = aug,
  inria = {RMOD},
  x-editorial-board = {yes},
  x-international-audience = {yes},
  x-language = {EN},
  aeres = {ACL},
  aeresstatus = {aeres12},
  selectif = {yes},
  inria = {RMOD},
  inriareport = {2010},
  labo = {dans}
}

@mastersthesis{Duca93a,
  annote = {dea},
  author = {St\'ephane Ducasse},
  keywords = {flo},
  month = sep,
  note = {Equipe Janus, Supervis\'e par M. Blay-Fornarino et E. Gall\'esio, Team Janus, supervised by M.  Blay-Fornarino and E. Gall\'esio},
  school = {Laboratoire I3S-Universit\'e de Nice-Sophia Antipolis},
  title = {Protocole meta pour l'expression de relations dans un langage \`a objets},
  year = {1993}
}


@inproceedings{Duca93b,
  annote = {internationalworkshop},
  author = {St\'ephane Ducasse and Mireille Fornarino},
  booktitle = {OOPSLA '93 International Workshop on Reflection and Metalevel Architectures in Object-Oriented Programming},
  keywords = {stefPub flo},
  note = {Technical Report, University of Nice-Sophia Antipolis, I3S Lab, RR-94-62},
  organization = {ACM},
  title = {Protocol for Managing Dependencies between Objects by controlling Generic Function Invocation},
  year = {1993}
}

@inproceedings{Duca94a,
  annote = {nationalconference},
  author = {St\'ephane Ducasse and Mireille Fornarino},
  booktitle = {Actes des Journ\'ees Francophones des Langages Applicatifs (JFLA'94)},
  editor = {Pierre Cointe, Christian Queinnec et Bernard Serpette},
  keywords = {stefPub flo},
  pages = {239--258},
  title = {Protocole pour la gestion des d\'ependances entre objets gr\^ace au contr\^ole des fonctions g\'en\'eriques},
  year = {1994}
}

@techreport{Duca94b,
  annote = {report notrefereed},
  author = {St\'ephane Ducasse and Mireille Fornarino and Anne-Marie Pinna},
  institution = {Laboratoire I3S},
  keywords = {stefPub flo},
  number = {I3S Lab, RR-94-60},
  title = {Embedding behavioral relationships between objects using computational relection},
  year = {1994}
}

@inproceedings{Duca95b,
  annote = {internationalconference topconference},
  author = {St{\'e}phane Ducasse and Mireille Blay-Fornarino and
                  Anne-Marie Pinna},
  booktitle = {Proceedings of 10th International Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA '95)},
  keywords = {stefPub flo},
  misc = {acceptance rate: 27/167 = 16\%},
  accepttotal = {167},
  acceptnum = {27},
  month = oct,
  pages = {265--280},
  publisher = {ACM},
  title = {A Reflective Model for First Class Dependencies},
  url = {http://scg.unibe.ch/archive/papers/Duca95bAReflectiveModel.pdf},
  year = {1995}
}

@inproceedings{Duca95c,
  annote = {internationalworkshop},
  author = {St\'ephane Ducasse},
  booktitle = {Proceedings of the International IJCAI'95 Workshop on Reflection and Meta-Level Architectures and their Applications in AI},
  institution = {University of Nice-Sophia Antipolis, Laboratoire I3S},
  keywords = {flo},
  note = {RR-95-12},
  pages = {39--49},
  title = {Inheritance Mechanism Reification by Means of First Class Object},
  year = {1995}
}

@techreport{Duca95d,
  annote = {report notrefereed},
  author = {St\'ephane Ducasse and Mireille Fornarino and Anne-Marie Pinna-Dery},
  institution = {University of Nice-Sophia Antipolis, Laboratoire I3S},
  keywords = {stefPub flo},
  number = {RR-95-03},
  title = {Control et PAC model},
  year = {1995}
}

@techreport{Duca96a,
  annote = {report notrefereed},
  author = {St\'ephane Ducasse},
  institution = {University of Nice Sophia-Antipolis, Laboratoire I3S},
  note = {I3S Lab, RR-95-28},
  title = {Reifying Inheritance in a Reflective Language},
  url = {http://scg.unibe.ch/archive/papers/Duca96aInhReify.ps.gz},
  year = {1996}
}

@inproceedings{Duca96b,
  abstract = {The FLO language integrates management of inter-object dependencies into the object oriented paradigms. In this paper, we focus on the use of reactive dependencies (links) in object-oriented knowledge representation. In particular, we present different meta-links (links between links) and show how the FLO links allow one to design some composition relationships.},
  annote = {internationalconference},
  author = {St\'ephane Ducasse and Mireille Blay-Fornarino and Anne-Marie Pinna},
  booktitle = {Proceedings of International Symposium on Methodologies for Intelligent Systems (ISMIS '96)},
  doi = {10.1007/3-540-61286-6_154},
  keywords = {flo scg-old scg-pub stefPub},
  month = jun,
  number = 1079,
  pages = {295--304},
  publisher = {Springer-Verlag},
  series = {LNIA (Lectures Notes in Artificial Intelligence)},
  title = {Object and Dependency Oriented Programming in FLO},
  url = {http://scg.unibe.ch/archive/papers/Duca96bDependencyOP.pdf},
  year = {1996},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca96bDependencyOP.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1007/3-540-61286-6_154}
}

@phdthesis{Duca97a,
  annote = {phdthesis},
  author = {St\'ephane Ducasse},
  keywords = {olit scglit oobib snf97 stefPub flo},
  month = jan,
  note = {Th\`ese de l'Universit\'e de Nice-Sophia Antipolis},
  school = {Universit\'e de Nice-Sophia Antipolis},
  title = {Int\'egration r\'eflexive de d\'ependances dans un mod\`ele \`a classes},
  url = {http://scg.unibe.ch/archive/papers/Duca97aPhD.ps.gz
                  http://scg.unibe.ch/archive/papers/Duca97aPhD.pdf},
  year = {1997},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca97aPhD.ps.gz%20http://scg.unibe.ch/archive/papers/Duca97aPhD.pdf}
}

@inproceedings{Duca97b,
  abstract = {The decomposition of a software application into components and connectors at the design stage has been promoted as a way to describe and reason about complex software architectures. There is, however, surprisingly little language support for this decomposition at implementation level. Interaction relationships which are identified at design time are lost as they get spread out into the participating entities at implementation. In this paper, we propose first-class connectors in an object-oriented language as a first step towards making software architecture more explicit at implementation level. Our connectors are run-time entities which control the interaction of components and can express a rich repertoire of interaction relationships. We show how connectors can be reused and how they enhance the reuse of components.},
  annote = {internationalconference topconference},
  author = {St\'ephane Ducasse and Tamar Richner},
  booktitle = {Proceedings of European Software Engineering Conference and Foundations on Software Engineering (ESEC/FSE'97)},
  doi = {10.1007/3-540-63531-9_32},
  isbn = {978-3-540-63531-4},
  keywords = {olit famoos-papref scglit oobib scg-pub flo snf97 jb97 scg-coord-98 stefPub},
  misc = {acceptance rate: 19/197 = 9\%},
  accepttotal = {197},
  acceptnum = {19},
  pages = {483--500},
  publisher = {Springer-Verlag},
  series = {LNCS},
  title = {Executable Connectors: Towards Reusable Design Elements},
  url = {http://scg.unibe.ch/archive/papers/Duca97bExecutableConnectors.pdf},
  volume = {1301},
  year = {1997},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca97bExecutableConnectors.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1007/3-540-63531-9_32}
}

@inproceedings{Duca97c,
  annote = {internationalworkshop},
  author = {St\'ephane Ducasse},
  booktitle = {Object-Oriented Technology (ECOOP '97 Workshop Reader)},
  editor = {Jan Bosch and Stuart Mitchell},
  month = jun,
  pages = {96--99},
  publisher = {Springer-Verlag},
  series = {LNCS},
  title = {Message Passing Abstractions as Elementary Bricks for Design Pattern Implementation},
  volume = 1357,
  year = {1997}
}

@inproceedings{Duca97d,
  annote = {nationalconference},
  author = {St\'ephane Ducasse},
  booktitle = {Actes de Langages et Mod\`eles \`a Objets (LMO'97)},
  keywords = {olit famoos-papref scglit oobib scg-pub skip-doi
                  skip-abstract snf97 jb97 stefPub flo},
  pages = {95--110},
  title = {R\'eification de Sch\'emas de Conception: Une
                  Exp\'erience},
  url = {http://scg.unibe.ch/archive/papers/Duca97dReificationDP.ps.gz},
  year = {1997},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca97dReificationDP.ps.gz}
}

@article{Duca97e,
  annote = {nationaljournal},
  author = {St\'ephane Ducasse},
  journal = {Revue des Sciences et Technologies de l'Information (RSTI) --- L'Objet},
  keywords = {olit famoos-papref scglit oobib scg-pub
                  skip-abstract skip-doi jb-none snf97 stefPub flo},
  number = {4},
  pages = {355--377},
  publisher = {Hermes, Paris},
  title = {Des techniques de contr\^ole de l'envoi de messages en {Smalltalk}},
  url = {http://scg.unibe.ch/archive/papers/Duca97eMessagePassing.pdf},
  volume = {3},
  year = {1997},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca97eMessagePassing.pdf}
}

@techreport{Duca97g,
  annote = {report notrefereed},
  author = {St\'ephane Ducasse},
  institution = {University of Bern, Institut of Applied Mathematics and Computer Sciences},
  keywords = {scg-pub skip-doi skip-pdf skip-abstract jb-none flo},
  note = {Extension version of Duca97e: Des techniques de contr\^ole de l'envoi de messages en Smalltalk},
  number = {97-004},
  title = {Des techniques de contr\^ole de l'envoi de messages en {Smalltalk}},
  year = {1997}
}

@inproceedings{Duca98b,
  abstract = {A reengineering pattern describes how to go from an existing legacy solution to a new refactored solution. In this paper we discuss the role of reengineering patterns and contrast them with design patterns and antipatterns. We then highlight the structure of a reengineering pattern and present two simple, related patterns for type-check elimination.},
  address = {Konstanz, Germany},
  annote = {internationalworkshop},
  author = {St\'ephane Ducasse and Robb Nebbe and Tamar Richner},
  booktitle = {Proceedings of the 4th European Conference on
                  Pattern Languages of Programming and Computing,
                  1999},
  editor = {Paul Dyson},
  keywords = {scg-pub skip-doi olit famoos-papunr oobib snf98
                  pattern jb98 stefPub},
  month = jul,
  publisher = {UVK Universit\"atsverlag Konstanz GmbH},
  title = {Two Reengineering Patterns: Eliminating Type
                  Checking},
  url = {http://scg.unibe.ch/archive/papers/Duca98bTwoReengPatterns.pdf},
  year = {1998},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca98bTwoReengPatterns.pdf}
}

@inproceedings{Duca98c,
  abstract = {Although coordination of multiple activities is a fundamental goal of object-oriented concurrent programming languages, there is only limited support for their specification and abstraction at the language level. This leads to a mismatch between conceptional designs, using high-level abstractions, and the implementation, using the low-level coordination constructs. Often coordination is hard-wired into the components they coordinate, which leads to evolution, maintenance and composibility problems. We propose a model called FLO/C that relies on the notion of connectors. A connector is an entity that enforces the coordination of the entities it coordinates. This model supports a clear separation between the coordinated active objects and their coordination.  An active object only defines specific domain information and a connector only defines coordination between a group of active objects (its participants). The coordination is abstractly defined refering to components in terms of the object interface. Coordination and coordinated entities are independant and can evolve separately.  Coordination can be composed and replaced easily.},
  annote = {internationalworkshop},
  author = {St\'ephane Ducasse and Manuel G{\"u}nter},
  booktitle = {Proceedings of the DEXA workshops},
  keywords = {scg-pub skip-doi flo floc olit coordination oobib
                  snf98 scg-coord-98 jb98 stefPub},
  month = aug,
  pages = {572--577},
  publisher = {IEEE Computer Society Press},
  title = {Coordination of Active Objects by Means of Explicit
                  Connectors},
  url = {http://scg.unibe.ch/archive/papers/Duca98cExplicitConnectors.pdf},
  year = {1998},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca98cExplicitConnectors.pdf}
}

@misc{Duca98z,
  annote = {workshopproceedings},
  author = {St\'ephane Ducasse and Joachim Weisbrod},
  booktitle = {Object-Oriented Technology (ECOOP'98 Workshop
                  Reader)},
  keywords = {skip-pdf scg-pub skip-abstract skip-doi jb-none
                  stefPub},
  number = 1543,
  pages = {72--96},
  publisher = {Springer-Verlag},
  series = {LNCS},
  title = {Report of the {ECOOP}'98 Workshop on Experiences in
                  Object-Oriented Re-Engineering},
  year = {1998}
}

@article{Duca99a,
  abstract = {In a language like Smalltalk in which objects communicate only via message passing, message passing control is a fundamental tool for the analysis of object behavior (trace, spying) or for the definition of new semantics (asynchronous messages, proxy,...). Different techniques exist, from the well known approach based on the specialization of the doesNotUnderstand: method to the exploitation the method lookup algorithm done by the virtual machine. Until now no comparison between these techniques has been made. In this article we compare the different techniques taking into account the reflective aspects used, the scope, the limit and the cost of the control.},
  annote = {internationaljournal},
  author = {St\'ephane Ducasse},
  journal = {Journal of Object-Oriented Programming (JOOP)},
  keywords = {olit famoos-papref snf98 oobib scg-pub skip-doi jb99
                  stefPub flo},
  misc = {SCI impact factor 0.306},
  month = jun,
  number = {6},
  pages = {39--44},
  publisher = {SIGS Press},
  title = {Evaluating Message Passing Control Techniques in {Smalltalk}},
  url = {http://scg.unibe.ch/archive/papers/Duca99aMsgPassingControl.pdf},
  volume = {12},
  year = {1999},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca99aMsgPassingControl.pdf}
}

@inproceedings{Duca99b,
  abstract = {Code duplication is one of the factors that severely complicates the maintenance and evolution of large software systems. Good tools for detecting duplicated code are scarce because of the large amount of data to be checked, because duplicated code is not known a priori and because especially it requires parsing technology. In this paper we show that is possible to circumvent these complicating factors by applying a language independent and lightweigth approach, i.e. a tool that requires no parsing and a little learning and configuration time, yet is able to detect a significant amount of code duplication. We validate our approach on a number of case studies, involving five different implementation languages and ranging from 256 K up untill 26Mb of source code.},
  annote = {internationalconference},
  author = {St\'ephane Ducasse and Matthias Rieger and Serge Demeyer},
  booktitle = {Proceedings of 15th IEEE International Conference on Software Maintenance (ICSM'99)},
  doi = {10.1109/ICSM.1999.792593},
  editor = {Hongji Yang and Lee White},
  keywords = {olit famoos-papref scg-pub toBeChecked
                  sergedem-papref duploc snf99 jb99 oorp stefPub
                  moose-pub},
  misc = {acceptance rate: 49/100 = 49\%},
  accepttotal = {100},
  acceptnum = {49},
  month = sep,
  pages = {109--118},
  publisher = {IEEE Computer Society},
  title = {A Language Independent Approach for Detecting Duplicated Code},
  url = {http://scg.unibe.ch/archive/papers/Duca99bCodeDuplication.pdf},
  year = {1999},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca99bCodeDuplication.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1109/ICSM.1999.792593}
}

@inproceedings{Duca99c,
  abstract = {In reengineering an object-oriented system we want to benefit from the expertise developed in earlier efforts. It is therefore essential to have a way to communicate expertise at different levels: from knowledge about how to approach a system to be reengineered, to knowledge about improving code by eliminating 'bad' style. In this paper we propose to use a pattern form to communicate knowledge about reengineering. A reengineering pattern connects an observable problem in the code to a reengineering goal: it describes the process of going from the existing legacy solution causing or aggravating the problem to a new refactored solution which meets the reengineering goal. It thus gives a method appropriate for a specific problem, rather than proposing a general methodology, and makes reference to the appropriate tools or techniques for obtaining the refactored solution. In this paper we discuss the role of reengineering patterns and contrast them with related kinds of patterns. We then highlight the form of reengineering patterns and present two simple patterns for type-check elimination.},
  annote = {internationalconference},
  author = {St\'ephane Ducasse and Tamar Richner and Robb Nebbe},
  booktitle = {Proceedings of 6th Working Conference on Reverse
                  Engineering (WCRE'99)},
  doi = {10.1109/WCRE.1999.806956},
  editor = {Francoise Balmas and Mike Blaha and Spencer Rugaber},
  keywords = {olit famoos-papref scg-pub jb99 stefPub},
  month = oct,
  pages = {157--168},
  publisher = {IEEE Computer Society},
  title = {Type-Check Elimination: Two Object-Oriented
                  Reengineering Patterns},
  url = {http://scg.unibe.ch/archive/papers/Duca99cTypeCheckElim.pdf},
  year = {1999},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Duca99cTypeCheckElim.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1109/WCRE.1999.806956}
}

@inproceedings{Duca99d,
  abstract = {Code duplication is an important problem in application maintenance. Tools exist that support code duplication detection. However, few of them propose a solution for the problem, i.e.  refactorings. We propose an approach that uses the information given by code duplication detection to guide the refactorings of OO applications.},
  annote = {internationalworkshop},
  author = {St\'ephane Ducasse and Matthias Rieger and Georges Golomingi},
  booktitle = {Proceedings of the ECOOP '99 Workshop on Experiences in Object-Oriented Re-Engineering},
  editor = {St\'ephane Ducasse and Oliver Ciupke},
  keywords = {olit famoos-papref scg-pub skip-doi jb99 stefPub},
  month = jun,
  note = {FZI-Report 2-6-6/99},
  publisher = {Forschungszentrum Informatik, Karlsruhe},
  title = {Tool Support for Refactoring Duplicated {OO} Code},
  url = {http://scg.unibe.ch/archive/papers/Rieg99aToolSuppRefacOOCode.pdf},
  year = {1999},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Rieg99aToolSuppRefacOOCode.pdf}
}

@inproceedings{Duca99s,
  annote = {internationalworkshop},
  author = {St\'ephane Ducasse and Michele Lanza and Serge
                  Demeyer},
  booktitle = {Object-Oriented Technology (ECOOP'99 Workshop
                  Reader)},
  keywords = {scg-pub snf-none skip-pdf jb-skip skip-abstract
                  skip-doi},
  number = {1743},
  publisher = {Springer-Verlag},
  series = {LNCS},
  title = {Reverse Engineering based on Metrics and Program
                  Visualization},
  year = {1999}
}

@techreport{Fabr10a,
  author = {Johan Fabry and Andy Kellens and St\'ephane Ducasse},
  institution = {University of Chile},
  month = apr,
  title = {AspectMaps: A Scalable Visualization of Join Point Shadows},
  year = {2010},
  type = {TR/DCC-2010-2}
}

@misc{Fern05a,
  aeres = {OV},
  aeresstatus = {aeres08},
  annote = {vulgarisation},
  author = {Hilaire Fernandes and St\'ephane Ducasse},
  inria = {hors},
  journal = {Linux Pratique},
  keywords = {stefPub},
  month = oct,
  number = 31,
  pages = {18--23},
  selectif = {non},
  title = {Squeak: mon premier programme},
  volume = 1,
  year = {2005},
  x-scientific-popularization = {yes}
}

@misc{Fern06a,
  aeres = {OV},
  aeresstatus = {aeres08},
  annote = {vulgarisation},
  author = {Hilaire Fernandes and St\'ephane Ducasse},
  inria = {hors},
  journal = {Linux Magazine},
  keywords = {stefPub},
  month = apr,
  number = 82,
  selectif = {non},
  title = {Smalltalk: Le pouvoir et la simplicit\'e du tout objet},
  volume = 1,
  year = {2006},
  x-scientific-popularization = {yes}
}

@misc{Fern06b,
  aeres = {OV},
  aeresstatus = {aeres08},
  annote = {vulgarisation},
  author = {Hilaire Fernandes and Serge Stinckwich},
  inria = {hors},
  journal = {Linux Magazine},
  month = jul,
  number = 85,
  selectif = {non},
  title = {Environnement de d\'eveloppement Smalltalk},
  volume = 1,
  year = {2006},
  x-scientific-popularization = {yes}
}

@inproceedings{Fern07a,
  aeres = {ACT},
  aeresstatus = {aeres08},
  annote = {internationalconference},
  author = {Hilaire Fernandes and St\'ephane Ducasse and Thibault Caron},
  booktitle = {Proceedings of 5th International Conference on Creating, Connecting and Collaborating through Computing (C5 2007)},
  inria = {hors},
  keywords = {stefPub},
  publisher = {IEEE Computer Society},
  selectif = {non},
  title = {Dr Geo II: Adding Interactivity Planes in Interactive Dynamic Geometry},
  year = {2007},
  isbn = {0-7695-2806-6},
  abstract = {Interactive geometry environments support the creation and exploitation of interactive geometric sketches. However, such environments are often driven in a rigid manner, following a well specified construction path. This rigidity is not always compatible with: i. the internal cognitive representation of the learner about the geometric domain and ii. the way a geometric sketch is used in a paper-pen environment. This rigidity is therefore a source of internal tension for the learner and it can reduce the pedagogical added value of the interactive geometry environments. We think additional interactive planes to manipulate a geometric sketch differently can help the learner. We have developed DR. GEO II, an interactive geometry framework that is able to receive additional interactive planes such as a free sketching and a command-based one. We have experimented it in a junior high school class and we report here our first results.},
  pages = {153--162},
  url = {http://rmod.lille.inria.fr/archives/papers/Fern07a-C5-DrIIInterfactiveMultimodal.pdf},
  doi = {10.1109/C5.2007.12},
  hal-id = {inria-00531636}
}



@inproceedings{Fern07b,
  aeres = {ACT},
  aeresstatus = {aeres08},
  author = 	 {Hilaire Fernandes and St\'ephane Ducasse and Thibault Carron},
  title = 	 {De l'importance des plans d'interaction dans la g\'eom\'etrie interactive},
  booktitle = {Environnements Informatiques pour l'Apprentissage Humain (EIAH 2007)},
  inria = {hors},
  keywords = {stefPub},
  selectif = {non},
  pages = 	 {383--388},
  year =  {2007},
  abstract = {Interactive geometry environments support creation and exploitation of geometric sketches. However, such environments are often driven in a rigid manner, following a well specified construction path. This rigidity is not always compatible with the internal cognitive representation of the learner about the geometric domain. This rigidity is therefore a source of internal tension for the learner and it can reduce the pedagogical added value of these environments. We think addi- tional interactive planes to manipulate a geometric sketch differently can help the learner. We have developed an interactive geometry framework that is able to receive additional interactive planes such as a free sketching and a command-based one. We have experimented it in a junior high school class and we report here our results.},
  publisher = {\textsc{atief}, \textsc{inrp}},
  url = {http://rmod.lille.inria.fr/archives/papers/Fern07b-EIAH-Multimodal.pdf},
  month = 	 jun,
  hal-id = {inria-00531641}
}

@misc{Fern07y,
  aeres = {OV},
  aeresstatus = {aeres08},
  annote = {vulgarisation},
  author = {Hilaire Fernandes and Serge Stinckwich},
  inria = {hors},
  journal = {Linux Magazine},
  month = jan,
  number = 90,
  selectif = {non},
  title = {Morphic, les interfaces utilisateurs selon Squeak},
  volume = 1,
  year = {2007}
}



@inproceedings{Fern08a,
  aeres = {ACT},
  aeresstatus = {aeres08},
  annote = {internationalconference},
  author = {Hilaire Fernandes and Thibault  Carron and  St\'ephane Ducasse },
  booktitle = {Proceedings of 6th International Conference on Creating, Connecting and Collaborating through Computing (C5 2008)},
  inria = {RMOD},
  keywords = {stefPub},
  publisher = {IEEE Computer Society},
  isbn = {0-7695-3115-6},
  pages = {65--72},
  selectif = {non},
  url = {http://rmod.lille.inria.fr/archives/papers/Fern08a-C5-istoa-exercises.pdf},
  title = {iSTOA: Artefacts for mathematical interactive learning execises},
  hal-id = {inria-00531649},
  abstract = {In primary schools, mathematics teachers use support tools to introduce new concepts. The objective of these tools is to reinforce a mental representation of the newly introduced concept. Tools can be physical objects or paper- pen based. We call these tools artefacts. In computer assisted environments, such artefacts are not always clearly present, those environments focus on the nature of the exercises (drills, quiz). To realise environments in closer relation to classroom teaching, we propose to analyse and categorise such artefacts: we used pedagogical literature and we extracted artefacts used in teaching multiplication. We present our infrastructure and a list of artefacts in the multiplication realm.},
  year = {2008}
}

@inproceedings{Fern09a,
  aeres = {ACT},
  aeresstatus = {aeres12},
  author = 	 {Hilaire Fernandes and Thibault Carron and St\'ephane Ducasse},
  title = 	 {Guidage macroscopique de l'apprentissage},
  booktitle = {Environnements Informatiques pour l'Apprentissage Humain (EIAH 2009)},
  inria = {RMOD},
  keywords = {stefPub},
  selectif = {non},
  year =  {2009},
  abstract = {Les EIAH sont souvent sp\'ecialis\'es dans un domaine bien pr\'ecis. Cela leur permet d'offrir des mod\'elisations fines du domaine et de l'apprenant. L'analyse alors produite \`a partir des traces est didactiquement tr\`es fine et sp\'ecifique au domaine en question. Elle permet de guider l'apprenant en cas de difficult\'e et de lui proposer des activit\'es de soutien. Cependant cette analyse est \'etroitement li\'ee aux domaines didactiques, et diff\'erente d'un domaine \`a un autre. Face \`a la diversit\'e des domaines enseign\'es, comment proposer un mod\`ele tenant compte de cette multitude et permettant une analyse de l'activit\'e de l'\'el\`eve et son guidage ?
Nous proposons une analyse de l'activit\'e de l'\'el\`eve hors du champ didactique pour un guidage que nous nommons macroscopique, par opposition \`a une analyse didactique fine. Le guidage propos\'e est g\'en\'erique mais param\'etr\'e par un r\'eseau notionnel afin d'\^etre transposable \`a diff\'erents domaines d'enseignement.
Notre approche s'appuie sur les r\'eseaux notionnels, les \'etayages p\'edagogiques, les traces d'objets et l'inf\'erence sur celles-ci. Leur utilisation conjointe permet la description du domaine, la mod\'elisation de l'apprenant et son pilotage par l'EIAH. Nous pr\'esentons cette approche dans iSTOA.net.},
  inriaReport = {2009},
  publisher = {\textsc{atief}, \textsc{inrp}},
  hal-id= { inria-00531658},
  url = {http://rmod.lille.inria.fr/archives/papers/Fern09a-EIAH2009-Guidage.pdf},
  month = 	jun
}


@phdthesis{Fern10a,
  author = {Hilaire Fernandes},
  school = {Universit\'e de Lille},
  year = {2010},
  annote = {PhD},
  title = {iStoa, mod\`ele notionnel de guidage macroscopique de  l'apprentissage},
  institution = {INRIA},
  inria = {RMOD},
  aeres = {AP},
  type_rapport = {PhD},
  hal-id = {tel-00498599},
  url = {http://rmod.lille.inria.fr/archives/phd/PhD-2010-Fernandes.pdf},
  asbtract = {Les EIAH sont souvent sp\'ecialis\'es \`a un domaine bien pr\'ecis. Cela leur permet d'offrir des mod\'elisations fines du domaine et de l'apprenant. L'analyse alors produite \`a partir des traces est didactiquement tr\`es fine et sp\'ecifique au domaine en question. Elle permet de guider l'apprenant en cas de difficult\'e et de lui proposer des activit\'es de soutien. Cependant cette analyse est \'etroitement li\'ee aux domaines didactiques, et diff\'erente d'un domaine \`a un autre. Dans la diversit\'e des domaines enseign\'es, comment proposer un mod\`ele tenant compte de cette multitude et permettant une analyse de l'activit\'e de l'\'el\`eve et son guidage ?
	Nous proposons une analyse de l'activit\'e de l'\'el\`eve hors du champ didactique pour un guidage que nous nommons macroscopique, par opposition \`a une analyse didactique fine. Le guidage propos\'e est param\'etr\'e selon le domaine afin d'\^etre transposable.
	Notre approche s'appuie sur les r\'eseaux notionnels, les \'etayages p\'edagogiques, les traces d'objets et l'inf\'erence sur celles-ci. Leur utilisation conjointe permet la description du domaine, la mod\'elisation de l'apprenant et son pilotage par l'EIAH. Nous pr\'esentons cette approche implant\'ee dans iSTOA 1.},
  x-language = {FR}
}

@article{Gael02a,
  annote = {notrefereed},
  author = {Markus Gaelli and Marcus Denker},
  comment = {bpb: Bundeszentrale f{\"u}r politische Bildung
                  Deutschland},
  journal = {bpb Online-Publikation: Freie Software im
                  Unterricht},
  keywords = {Squeak gaelli fromscgbib marcusdenker},
  misc = {gaelli},
  month = oct,
  publisher = {bpb: Bundeszentrale f{\"u}r politische Bildung
                  Deutschland},
  title = {Freie Software im Unterricht: Squeak},
  url = {http://rmod.lille.inria.fr/archives/popular/Gael02a-BPB-Squeak.pdf},
  year = {2002}
}

@article{Gael04b,
  abstract = {Es muss keine staubtrockene Angelegenheit von
                  Informatikstudenten sein, dem Computer neue Dinge
                  beizubringen. Squeak will Kindern nicht nur den
                  Umgang mit dem Rechner naeher bringen, sondern ihnen
                  auch als Mittel zur Entdeckung der realen Welt
                  dienen. Und fuer Erwachsene stellt es eine
                  Smalltalk-Umgebung dar, die auch spielerisch
                  erschlossen werden kann.},
  annote = {notrefereed},
  author = {Markus Gaelli and Marcus Denker},
  journal = {c't magazin f\"ur computer technik},
  keywords = {squeak smalltalk snf-none gaelli fromscgbib marcusdenker},
  misc = {gaelli},
  month = may,
  pages = {216--221},
  publisher = {Heise Verlag},
  title = {Von kleinen und grossen Erfindern --- Squeak:
                  Lernumgebung und Smalltalk-System f{\"u}r Kinder und
                  Erwachsene},
  url = {http://rmod.lille.inria.fr/archives/popular/Gael04b-Ct-VonKleinenUndGrossenErfindern.pdf},
  year = {2004}
}

@inproceedings{Gael04c,
  abstract = {Although unit testing is essential for programming, current languages only barely support the developer in composing unit tests into new ones or in navigating between unit tests and their corresponding methods under test. We have taken several Smalltalk programs and analyzed the relationships between unit tests and methods under test, and the re- lationships amongst unit tests.  First results indicate that most unit tests can be seen or at least decomposed into commands which focus on single methods, and that large portions of unit tests overlap each other. But these relationships between unit tests and methods under test are not reflected in current languages. We therefore first conceptually extend the meta-model of Smalltalk with one-method commands so that unit tests become both com- posable and navigable. Then we introduce a first lightweight implementation of this meta model using method comments to differentiate between the several test phases of existing XUnit test case methods.},
  annote = {internationalworkshop},
  author = {Markus Gaelli and Oscar Nierstrasz and St{\'e}phane
                  Ducasse},
  booktitle = {OOPSLA Workshop on Revival of Dynamic Languages},
  cvs = {EgRDL2004},
  keywords = {snf05 scg-pub skip-doi gaelli jb05},
  month = oct,
  title = {One-Method Commands: Linking Methods and Their
                  Tests},
  url = {http://scg.unibe.ch/archive/papers/Gael04cLinkingMethodsAndTests.pdf},
  year = {2004},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Gael04cLinkingMethodsAndTests.pdf}
}

@book{Gens02a,
  abstract = {This Handbook presents the PECOS approach for developing field device software. It has been written for the developer who wants to apply the method in a realistic setting. By following this tutorial the reader will get a good understanding of PECOS and will learn how to use PECOS to develop software for embedded real-time systems.},
  annote = {notrefereed handbook},
  author = {Thomas Genssler and Alexander Christoph and Benedikt Schulz and Michael Winter and Chris M. Stich and Christian Zeidler and Peter M\"uller and Andreas Stelter and Oscar Nierstrasz and St\'ephane Ducasse and Gabriela Ar{\'e}valo and Roel Wuyts and Peng Liang and Bastiaan Sch\"onhage and Reinier van den Born},
  keywords = {olit scg-pub skip-doi jb02 pecos arevalo stefPub},
  month = sep,
  publisher = {The Pecos Consortium},
  title = {PECOS in a Nutshell},
  url = {http://www.pecos-project.org/public_documents/pecosHandbook.pdf},
  year = {2002},
  bdsk-url-1 = {http://www.pecos-project.org/public_documents/pecosHandbook.pdf}
}

@inproceedings{Girb04b,
  abstract = {Knowing where to start reverse engineering a large software system, when no information other than the system`s source code itself is available, is a daunting task. Having the history of the code (i.e., the versions) could be of help if this would not imply analyzing a huge amount of data. In this paper we present an approach for identifying candidate classes for reverse engineering and reengineering efforts. Our solution is based on summarizing the changes in the evolution of object-oriented software systems by defining history measurements. Our approach, named Yesterday`s Weather, is an analysis based on the retrospective empirical observation that classes which changed the most in the recent past also suffer important changes in the near future. We apply this approach on two case studies and show how we can obtain an overview of the evolution of a system and pinpoint its classes that might change in the next versions.},
  address = {Los Alamitos CA},
  annote = {internationalconference},
  author = {Tudor G\^irba and St\'ephane Ducasse and Michele
                  Lanza},
  booktitle = {Proceedings of 20th IEEE International Conference on
                  Software Maintenance (ICSM'04)},
  doi = {10.1109/ICSM.2004.1357788},
  keywords = {scg-pub evolution metrics hismo stefPub van
                  moose-pub girba recast05 jb05},
  location = {Illinois, USA},
  misc = {acceptance rate: 38/122 = 31\%},
  accepttotal = {122},
  acceptnum = {38},
  month = sep,
  pages = {40--49},
  publisher = {IEEE Computer Society},
  title = {{Yesterday's} {Weather}: Guiding Early Reverse
                  Engineering Efforts by Summarizing the Evolution of
                  Changes},
  url = {http://scg.unibe.ch/archive/papers/Girb04bYesterdayWeather.pdf},
  year = {2004},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Girb04bYesterdayWeather.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1109/ICSM.2004.1357788}
}

@inproceedings{Girb04d,
  abstract = {Software system need to change over time to cope
                  with the new requirements. Furthermore, due to
                  design decisions, the new requirements happen to
                  crosscut the system's structure. Understanding how
                  changes appear in the system can reveal hidden
                  dependencies between different parts of the system.
                  We propose to group entities that change together
                  according to a logical expression that specifies the
                  change condition. Furthermore, we can group entities
                  at different levels of abstraction (i.e., method,
                  class, package). Our approach is based on an
                  explicit history meta model that centers around the
                  notion of history and which enables the definition
                  of historical measurements which summarize the
                  changes. We apply our approach on two large case
                  studies and show how we can identify groups of
                  related entities and detect bad smells.},
  annote = {internationalworkshop},
  author = {Tudor G\^irba and St\'ephane Ducasse and Radu
                  Marinescu and Daniel Ra\c{t}iu},
  booktitle = {Ninth IEEE Workshop on Empirical Studies of Software
                  Maintenance},
  keywords = {scg-pub skip-doi evolution van metrics smell hismo
                  stefPub recast05 girba jb05 moose-pub},
  title = {Identifying Entities That Change Together},
  url = {http://scg.unibe.ch/archive/papers/Girb04dEntitiesChangeTogether.pdf},
  year = {2004},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Girb04dEntitiesChangeTogether.pdf}
}

@inproceedings{Girb05a,
  abstract = {Analyzing historical information can show how a
                  software system evolved into its current state,
                  which parts of the system are stable and which have
                  changed more. However, historical analysis implies
                  processing a vast amount of information making the
                  interpretation of the results difficult. To address
                  this issue, we introduce the notion of the history
                  of source code artifacts as a first class entity and
                  define measurements which summarize the evolution of
                  such entities. We use these measurements to define
                  rules by which to detect different characteristics
                  of the evolution of class hierarchies. Furthermore,
                  we discuss the results we obtained by visualizing
                  them using a polymetric view. We apply our approach
                  on two large open source case studies and classify
                  their class hierarchies based on their history.},
  address = {Los Alamitos CA},
  aeres = {ACT},
  aeresstatus = {aeres08},
  annote = {internationalconference},
  author = {Tudor G\^irba and Michele Lanza and St\'ephane
                  Ducasse},
  booktitle = {Proceedings of 9th European Conference on Software
                  Maintenance and Reengineering (CSMR'05)},
  doi = {10.1109/CSMR.2005.15},
  inria = {hors},
  keywords = {scg-pub evolution visualization metrics van recast05
                  girba stefPub jb05 moose-pub},
  misc = {acceptance rate: 33/81 = 41 \%},
  accepttotal = {81},
  acceptnum = {33},
  pages = {2--11},
  publisher = {IEEE Computer Society},
  rate = {41%},
  selectif = {non},
  title = {Characterizing the Evolution of Class Hierarchies},
  url = {http://scg.unibe.ch/archive/papers/Girb05aHierarchiesEvolution.pdf},
  year = {2005},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Girb05aHierarchiesEvolution.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1109/CSMR.2005.15}
}

@inproceedings{Girb05b,
  abstract = {Understanding how software systems evolve is useful
                  from different perspectives: reverse engineering,
                  empirical studies etc.. For an effective
                  understanding we need an explicit meta-model. We
                  introduce Hismo, a meta-model which is centered
                  around the notion of history and we show how we can
                  obtain it from a snapshot meta-model. Based on our
                  experience in developing the Hismo reverse
                  engineering system, we show how we can transform a
                  snapshot meta-model in a history metamodel.},
  annote = {internationalworkshop},
  author = {Tudor G\^irba and Jean-Marie Favre and St\'ephane
                  Ducasse},
  booktitle = {Proceedings of 2nd International Workshop on
                  Meta-Models and Schemas for Reverse Engineering
                  (ATEM 2004)},
  doi = {10.1016/j.entcs.2005.07.005},
  keywords = {scg-pub evolution meta-modeling hismo van moose-pub
                  recast05 jointERCIM girba stefPub jb05},
  pages = {57--64},
  title = {Using Meta-Model Transformation to Model Software Evolution},
  url = {http://scg.unibe.ch/archive/papers/Girb05bMetaModelTransATEM2004.pdf},
  year = {2004},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Girb05bMetaModelTransATEM2004.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1016/j.entcs.2005.07.005}
}

@inproceedings{Girb05c,
  abstract = {As systems evolve their structure change in ways not
                  expected upfront. As time goes by, the knowledge of
                  the developers becomes more and more critical for
                  the process of understanding the system. That is,
                  when we want to understand a certain issue of the
                  system we ask the knowledgeable developers. Yet, in
                  large systems, not every developer is knowledgeable
                  in all the details of the system. Thus, we would
                  want to know which developer is knowledgeable in the
                  issue at hand. In this paper we make use of the
                  mapping between the changes and the author
                  identifiers (e.g., user names) provided by
                  versioning repositories. We first define a
                  measurement for the notion of code ownership. We use
                  this measurement to define the Ownership Map
                  visualization to understand when and how different
                  developers interacted in which way and in which part
                  of the system. We report the results we obtained on
                  several large systems.},
  aeres = {ACT},
  aeresstatus = {aeres08},
  annote = {internationalworkshop},
  author = {Tudor G\^irba and Adrian Kuhn and Mauricio Seeberger
                  and St\'ephane Ducasse},
  booktitle = {Proceedings of International Workshop on Principles
                  of Software Evolution (IWPSE 2005)},
  cvs = {ChroniaIWPSE2005},
  doi = {10.1109/IWPSE.2005.21},
  inria = {hors},
  keywords = {scg-pub evolution visualization authors stefPub
                  girba recast06 jb06 moose-pub chronia akuhn},
  location = {Lisbon, Portugal},
  misc = {acceptance rate: 13/54 = 24\%},
  accepttotal = {54},
  acceptnum = {13},
  pages = {113--122},
  publisher = {IEEE Computer Society Press},
  rate = {24%},
  selectif = {oui},
  title = {How Developers Drive Software Evolution},
  url = {http://scg.unibe.ch/archive/papers/Girb05cOwnershipMap.pdf},
  year = {2005},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Girb05cOwnershipMap.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1109/IWPSE.2005.21}
}

@article{Girb06a,
  abstract = {The histories of software systems hold useful
                  information when reasoning about the systems at hand
                  or when reasoning about general laws of software
                  evolution. Over the past 30 years more and more
                  research has been spent on understanding software
                  evolution. However, the approaches developed so far
                  do not rely on an explicit meta-model, and thus,
                  they make it difficult to reuse or compare their
                  results. We argue that there is a need for an
                  explicit meta-model for software evolution analysis.
                  We present a survey of the evolution analyses and
                  deduce a set of requirements that an evolution
                  meta-model should have. We define, Hismo, a
                  meta-model in which history is modeled as an
                  explicit entity. Hismo adds a time layer on top of
                  structural information, and provides a common
                  infrastructure for expressing and combining
                  evolution analyses and structural analyses. We
                  validate the usefulness of our a meta-model by
                  presenting how different analyses are expressed on
                  it.},
  aeres = {ACL},
  aeresstatus = {aeres08},
  annote = {internationaljournal},
  author = {Tudor G\^irba and St\'ephane Ducasse},
  misc = {5 Year ISI impact factor 1.523 (2010)},
  impactfactor = {5 Year ISI impact factor 1.523 (2010)},
  inria = {hors},
  journal = {Journal of Software Maintenance: Research and Practice (JSME)},
  keywords = {hasler07 scg-pub skip-doi recast06 jb06 stefPub  mooseCincom moose-pub van girba snf-actsc norex06
                  meta-modeling hismo evolution},
  pages = {207--236},
  publisher = {John Wiley and Sons, Ltd.},
  selectif = {non},
  title = {Modeling History to Analyze Software Evolution},
  url = {http://scg.unibe.ch/archive/papers/Girb06aHismo.pdf},
  volume = {18},
  year = {2006}
}

@inproceedings{Girb07a,
  abstract = {Software systems need to change over time to cope
                  with new requirements, and due to design decisions,
                  the changes happen to crosscut the system's
                  structure. Understanding how changes appear in the
                  system can reveal hidden dependencies between
                  different entities of the system. We propose the
                  usage of concept analysis to identify groups of
                  entities that change in the same way and in the same
                  time. We apply our approach at different levels of
                  abstraction (i.e., method, class, package) and we
                  detect fine grained changes (i.e., statements were
                  added in a class, but no method was added there).
                  Concept analysis is a technique that identifies
                  entities that have the same properties, but it
                  requires manual inspection due to the large number
                  of candidates it detects. We propose a heuristic
                  that dramatically eliminate the false positives. We
                  apply our approach on two case studies and we show
                  how we can identify hidden dependencies and detect
                  bad smells.},
  aeres = {ACT},
  aeresstatus = {aeres08},
  annote = {internationalworkshop},
  author = {Tudor G\^irba and St\'ephane Ducasse and {A}drian
                  {K}uhn and Radu Marinescu and Daniel Ra\c{t}iu},
  booktitle = {Proceedings of International Workshop on Principles
                  of Software Evolution (IWPSE 2007)},
  doi = {10.1145/1294948.1294970},
  inria = {hors},
  isbn = {978-1-59593-722-3},
  keywords = {scg07 scg-pub evolution fca girba jb08 metrics
                  moose-pub norex07 stefPub},
  medium = {2},
  pages = {83--89},
  peerreview = {yes},
  publisher = {ACM Press},
  selectif = {non},
  title = {Using Concept Analysis to Detect Co-Change Patterns},
  url = {http://scg.unibe.ch/archive/papers/Girb07aCoChangePatterns.pdf},
  year = {2007}
}

@misc{Gonz04a,
  abstract = {This report covers the activities of the 2nd
                  workshop on "Object-Oriented Language Engineering
                  for the Post-Java Era". We describe the motivation
                  that led to the organisation of a second edition of
                  the workshop. Relevant organisational aspects are
                  mentioned. The main part of the report consists of a
                  summary of Dave Thomas's invited talk, and a recount
                  of the presentations by the authors of position
                  papers. Comments given along the way by the
                  participants are included. Finally, some pointers to
                  related work and events are given.},
  annote = {workshopproceedings},
  author = {Sebastian Gonzales and Wolgang Demeuter and Pascal
                  Costanza and St\'ephane Ducasse and Richard Gabriel
                  and Theo D'hondt},
  booktitle = {Object-Oriented Technology (ECOOP'04 Workshop
                  Reader)},
  keywords = {scg-pub skip-doi jb04 stefPub recast04},
  publisher = {Springer-Verlag},
  series = {LNCS},
  title = {Report of the {ECOOP}'03 Workshop on Object-Oriented
                  Language Engineering in Post-Java Era},
  url = {http://scg.unibe.ch/archive/papers/Gonz04aoolepje04-report.pdf},
  year = {2004}
}

@inproceedings{Gonz09a,
  abstract = {The emerging field of context-oriented programming
                  gives a predominant role to the execution context of
                  applications, and advocates the use of dedicated
                  mechanisms to allow the elegant expression of
                  behavioural adaptations to such context. With
                  suitable reflective facilities, language semantics
                  can be adapted to context by reusing the same
                  context-oriented mechanisms that allow base-level
                  adaptability. This kind of meta-level adaptability,
                  in which the computation model itself becomes
                  adaptable to context, gives rise to context-oriented
                  computational reflection. To explore this idea, we
                  set out to implement a simple software transactional
                  memory system that exploits meta-level adaptability
                  by regarding transactions as contexts, and adapting
                  fundamental system behaviour to such transactional
                  contexts. The implementation is succinct and
                  non-intrusive, giving us an indication of the power
                  lying at the crossroads of context-oriented
                  programming and computational reflection.},
  address = {New York, NY, USA},
  author = {Gonz\'{a}lez, Sebasti\'{a}n and Denker, Marcus and
                  Mens, Kim},
  booktitle = {COP '09: International Workshop on Context-Oriented
                  Programming},
  doi = {10.1145/1562112.1562115},
  isbn = {978-1-60558-538-3},
  keywords = {cop-lit gonzales ambience fromscgbib},
  location = {Genova, Italy},
  pages = {1--6},
  publisher = {ACM},
  title = {Transactional contexts: harnessing the power of context-oriented reflection},
  year = {2009},
  url = {http://rmod.lille.inria.fr/archives/workshops/Gonz09a-COP09-Context.pdf}
}

@inproceedings{Gree05a,
  abstract = {Software developers are constantly required to
                  modify and adapt features of an application in
                  response to changing requirements. The problem is
                  that just by reading the source code, it is
                  difficult to determine how classes and methods
                  contribute to the runtime behavior of features.
                  Moreover, dependencies between system features are
                  not obvious, consequently software maintenance
                  operations often result in unintended side effects.
                  To tackle these problems, we propose a compact
                  feature-driven approach (\ie summarized trace
                  information) based on dynamic analysis to
                  characterize features and computational units of an
                  application. We extract execution traces to achieve
                  an explicit mapping between features and classes
                  using two complementary perspectives. We apply our
                  approach to two case studies and we report our
                  findings.},
  address = {Los Alamitos CA},
  aeres = {ACT},
  aeresstatus = {aeres08},
  annote = {internationalconference},
  author = {Orla Greevy and St\'ephane Ducasse},
  booktitle = {Proceedings of 9th European Conference on Software
                  Maintenance and Reengineering (CSMR'05)},
  cvs = {TraceScraperRevEng},
  doi = {10.1109/CSMR.2005.21},
  inria = {hors},
  keywords = {scg-pub greevy jb05 recast05 stefPub Feature
                  Feature-Traces Dynamic Analysis Evolution moose-pub},
  location = {Manchester, United Kingdom},
  misc = {acceptance rate: 33/81 = 41\%},
  accepttotal = {81},
  acceptnum = {33},
  pages = {314--323},
  publisher = {IEEE Computer Society},
  rate = {41%},
  selectif = {non},
  title = {Correlating Features and Code Using A Compact
                  Two-Sided Trace Analysis Approach},
  url = {http://scg.unibe.ch/archive/papers/Gree05aTraceScraperCSMR2005Features.pdf},
  year = {2005},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Gree05aTraceScraperCSMR2005Features.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1109/CSMR.2005.21}
}

@inproceedings{Gree05b,
  abstract = {Software developers are often faced with the task of
                  maintaining or extending large and complex
                  applications, with which they are unfamiliar.
                  Typically change requests and bug reports are
                  expressed in terms of system features. Much of the
                  maintenance effort is spent trying to identify which
                  classes and methods provide functionality to
                  individual features. To tackle this problem, we
                  propose an approach based on dynamic analysis that
                  exploits the relationship between features and
                  software entities. Our definition of a feature is a
                  unit of observable behavior of a software system. We
                  apply our approach to a large open source
                  application and identify key classes and methods
                  which provide functionality to individual features.},
  annote = {internationalworkshop},
  author = {Orla Greevy and St\'ephane Ducasse},
  booktitle = {Proceedings of WOOR 2005 (6th International Workshop
                  on Object-Oriented Reengineering)},
  cvs = {TraceScraperWOOR2005},
  keywords = {scg-pub skip-doi greevy jb06 MISSINGPAGENUMBERS
                  stefPub Feature Feature-Traces Dynamic Analysis
                  Evolution moose-pub recast05},
  month = jul,
  title = {Characterizing the Functional Roles of Classes and
                  Methods by Analyzing Feature Traces},
  url = {http://scg.unibe.ch/archive/papers/Gree05bTraceScraperWOOR2005.pdf},
  year = {2005},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Gree05bTraceScraperWOOR2005.pdf}
}

@inproceedings{Gree05c,
  abstract = {Many of the approaches that analyze software
                  evolution consider a static perspective of a system.
                  Static analysis approaches focus on the evolution of
                  static software entities such as packages, classes
                  and methods. Without knowledge of the roles software
                  entities play in system features, it is difficult to
                  interpret the motivation behind changes and
                  extensions in the code. To tackle this problem, we
                  propose an approach to software evolution analysis
                  that exploits the relationships between features and
                  software entities. Our definition of a feature is a
                  unit of observable behavior of a software system. We
                  define history measurements that summarize the
                  evolution of software entities from a feature
                  perspective. We show how we use our feature
                  perspective of software evolution to interpret
                  modifications and extensions to the code. We apply
                  our approach on two case studies and discuss our
                  findings.},
  address = {Los Alamitos},
  aeres = {ACT},
  aeresstatus = {aeres08},
  annote = {internationalconference},
  author = {Orla Greevy and St\'ephane Ducasse and Tudor  G\^irba},
  booktitle = {Proceedings of 21st IEEE International Conference on Software Maintenance (ICSM'05)},
  cvs = {TraceScraperICSM2005Evolution},
  doi = {10.1109/ICSM.2005.22},
  inria = {hors},
  keywords = {scg-pub girba greevy jb06 stefPub Features
                  Feature-Traces Dynamic-Analysis Evolution history
                  moose-pub recast06 listic},
  misc = {acceptance rate: 55/180 = 31\%},
  accepttotal = {180},
  acceptnum = {55},
  month = sep,
  pages = {347--356},
  publisher = {IEEE Computer Society},
  rate = {31%},
  selectif = {oui},
  title = {Analyzing Feature Traces to Incorporate the Semantics of Change in Software Evolution Analysis},
  url = {http://scg.unibe.ch/archive/papers/Gree05cTraceScraperICSM2005.pdf},
  year = {2005}
}

@article{Gree06b,
  abstract = {Features encapsulate the domain knowledge of a
                  software system and thus are valuable sources of
                  information for a reverse engineer. When analyzing
                  the evolution of a system, we need to know how and
                  which features were modified to recover both the
                  change intention and its extent, namely which source
                  artifacts are affected. Typically, the
                  implementation of a feature crosscuts a number of
                  source artifacts. To obtain a mapping between
                  features to the source artifacts, we exercise the
                  features and capture their execution traces. However
                  this results in large traces that are difficult to
                  interpret. To tackle this issue we compact the
                  traces into simple sets of source artifacts that
                  participate in a feature's runtime behavior. We
                  refer to these compacted traces as feature views.
                  Within a feature view, we partition the source
                  artifacts into disjoint sets of characterized
                  software entities. The characterization defines the
                  level of participation of a source entity in the
                  features. We then analyze the features over several
                  versions of a system and we plot their evolution to
                  reveal how and hich features were affected by
                  changes in the code. We show the usefulness of our
                  approach by applying it to a case study where we
                  address the problem of merging parallel development
                  tracks of the same system.},
  aeres = {ACL},
  aeresstatus = {aeres08},
  annote = {internationaljournal},
  author = {Orla Greevy and St\'ephane Ducasse and Tudor  G\^irba},
  doi = {10.1002/smr.340},
   misc = {5 Year ISI impact factor 1.523 (2010)},
  inria = {hors},
  journal = {Journal of Software Maintenance and Evolution: Research and Practice (JSME)},
  keywords = {scg-pub recast07 snf07 jb07 fb06 stefPub girba
                  mooseCincom dynamic-analysis feature evolution
                  moose-pub},
  impactfactor = {5 Year ISI impact factor 1.523 (2010)},
  number = {6},
  pages = {425--456},
  peerreview = {yes},
  selectif = {non},
  title = {Analyzing Software Evolution through Feature Views},
  url = {http://scg.unibe.ch/archive/papers/Gree06bTraceScraperJSME-SCG.pdf},
  volume = {18},
  year = {2006}
}

@inproceedings{Gree07a,
  abstract = {Software systems are typically developed by teams of
                  developers, with responsibilities for different
                  parts of the code. Knowledge of how the developers
                  collaborate, and how their responsibilities are
                  distributed over the software artifacts is a
                  valuable source of information when reverse
                  engineering a system. Determining which developers
                  are responsible for which software artifacts (\eg
                  packages or classes) is just one perspective. In
                  this paper we complement the static perspective with
                  the dynamic perspective of a system in terms of its
                  features. We want to extract information about which
                  developers are responsible for which features. To
                  achieve these two perspectives, we correlate
                  developer responsibilities both with a structural
                  view of the system and with a feature view. We
                  identify which developers are responsible for which
                  features, and whether the responsibilities
                  correspond with structural source code artifacts or
                  with features. We apply our technique to two
                  software projects developed by two teams of students
                  as part of their course work, and to one large open
                  source project.},
  address = {Los Alamitos CA},
  aeres = {ACT},
  aeresstatus = {aeres08},
  annote = {internationalconference},
  author = {Orla Greevy and Tudor G\^irba and St\'ephane
                  Ducasse},
  booktitle = {Proceedings of 11th European Conference on Software
                  Maintenance and Reengineering (CSMR 2007)},
  cvs = {TraceScraperCSMR2007},
  doi = {10.1109/CSMR.2007.27},
  inria = {hors},
  isbn = {0-7695-2802-3},
  issn = {1534-5351},
  keywords = {scg07 scg-pub greevy jb07 stefPub snf07 moose-pub
                  authors features evolution dynamic-analysis girba},
  medium = {2},
  misc = {Acceptance rate: 38/132=29\%},
  accepttotal = {132},
  acceptnum = {38},
  pages = {256--274},
  peerreview = {yes},
  publisher = {IEEE Computer Society},
  rate = {29%},
  selectif = {oui},
  title = {How Developers Develop Features},
  url = {http://scg.unibe.ch/archive/papers/Gree07aDevelopersDevelopFeatures.pdf},
  year = {2007},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Gree07aDevelopersDevelopFeatures.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1109/CSMR.2007.27}
}

@article{Gybe06a,
  abstract = {Meta programming is the act of reasoning about a
                  computational system. For example, a program in
                  Prolog can reason about a program written in
                  Smalltalk. Reflection is a more powerful form of
                  meta programming where the same language is used to
                  reason about, and act upon, itself in a causally
                  connected way. Thus on the one hand we have meta
                  programming that allows different languages or
                  paradigms to be used, but without causal connection,
                  while on the other hand we have reflection that
                  offers causal connection but only for a single
                  language. This paper combines both and presents
                  inter-language reflection that allows one language
                  to reason about and change in a causally connected
                  way another language and vice versa. The fundamental
                  aspects of inter-language reflection and the
                  language symbiosis used therein, are discussed.
                  Moreover the implementation of two symbiotic
                  reflective languages is discussed: Agora/Java and
                  SOUL/Smalltalk.},
  aeres = {ACL},
  aeresstatus = {aeres08},
  annote = {internationaljournal},
  author = {Kris Gybels and Roel Wuyts and St\'{e}phane Ducasse and Maja D'Hondt},
  doi = {10.1016/j.cl.2005.10.003},
  impactfactor = {5 Year ISI impact factor 0.698 (2010)},
  inria = {hors},
  journal = {Journal of Computer Languages, Systems and Structures},
  keywords = {stefPub decomp-pub},
  misc = {5 Year ISI impact factor 0.698 (2010)},
  month = jul,
  number = {2-3},
  pages = {109--124},
  publisher = {Elsevier},
  selectif = {non},
  title = {Inter-Language Reflection --- A Conceptual Model and Its Implementation},
  url = {http://scg.unibe.ch/archive/papers/Gybe06aSymbioticReflectionESUGJournal.pdf},
  volume = {32},
  year = {2006}
}


@inproceedings{Hald07b,
  abstract = {Most languages fall into one of two camps: either
                  they adopt a unique, static type system, or they
                  abandon static type-checks for run-time checks.
                  Pluggable types blur this division by (i) making
                  static type systems optional, and (ii) supporting a
                  choice of type systems for reasoning about different
                  kinds of static properties. Dynamic languages can
                  then benefit from static-checking without
                  sacrificing dynamic features or committing to a
                  unique, static type system. But the overhead of
                  adopting pluggable types can be very high,
                  especially if all existing code must be decorated
                  with type annotations before any type-checking can
                  be performed. We propose a practical and pragmatic
                  approach to introduce pluggable type systems to
                  dynamic languages. First of all, only annotated code
                  is type-checked. Second, limited type inference is
                  performed on unannotated code to reduce the number
                  of reported errors. Finally, external annotations
                  can be used to type third-party code. We present
                  Typeplug, a Smalltalk implementation of our
                  framework, and report on experience applying the
                  framework to three different pluggable type
                  systems.},
  annote = {internationalconference},
  author = {Niklaus Haldimann and Marcus Denker and Oscar
                  Nierstrasz},
  booktitle = {Proceedings of the 2007 International Conference on
                  Dynamic Languages (ICDL 2007)},
  doi = {10.1145/1352678.1352690},
  isbn = {978-1-60558-084-5},
  keywords = {scg07 scg-pub jb08 snf07 reflectivity marcusdenker fromscgbib},
  medium = {2},
  pages = {183--204},
  peerreview = {yes},
  publisher = {ACM Digital Library},
  title = {Practical, Pluggable Types},
  url = {http://rmod.lille.inria.fr/archives/papers/Hald07b-ICDL07-Typeplug.pdf},
  year = {2007}
}

@article{Hald09a,
  abstract = {Most languages fall into one of two camps: either
                  they adopt a unique, static type system, or they
                  abandon static type-checks for run-time checks.
                  Pluggable types blur this division by (i) making
                  static type systems optional, and (ii) supporting a
                  choice of type systems for reasoning about different
                  kinds of static properties. Dynamic languages can
                  then benefit from static-checking without
                  sacrificing dynamic features or committing to a
                  unique, static type system. But the overhead of
                  adopting pluggable types can be very high,
                  especially if all existing code must be decorated
                  with type annotations before any type-checking can
                  be performed. We propose a practical and pragmatic
                  approach to introduce pluggable type systems to
                  dynamic languages. First of all, only annotated code
                  is type-checked. Second, limited type inference is
                  performed on unannotated code to reduce the number
                  of reported errors. Finally, external annotations
                  can be used to type third-party code. We present
                  Typeplug, a Smalltalk implementation of our
                  framework, and report on experience applying the
                  framework to three different pluggable type
                  systems.},
  annote = {internationaljournal},
  author = {Niklaus Haldimann and Marcus Denker and Oscar
                  Nierstrasz},
  doi = {10.1016/j.cl.2008.06.003},
  journal = {Journal of Computer Languages, Systems and Structures},
  keywords = {scg09 scg-pub jb08 snf08 reflectivity marcusdenker fromscgbib},
  medium = {2},
  impactfactor = {5 Year ISI impact factor 0.698 (2010)},
  misc = {5 Year ISI impact factor 0.698 (2010)},
  miscmisc = {was: Hald08a},
  month = apr,
  number = {1},
  pages = {48--64},
  peerreview = {yes},
  publisher = {Elsevier},
  title = {Practical, Pluggable Types for a Dynamic Language},
  url = {http://rmod.lille.inria.fr/archives/papers/Hald08a-COMLAN-Typeplug.pdf},
  volume = {35},
  year = {2009}
}

@inproceedings{Haup07a,
  abstract = {This position paper proposes the exploitation of
                  type feedback mechanisms, or more precisely,
                  polymorphic inline caches, for purely interpreting
                  implementations of object-oriented programming
                  languages. Using Squeak's virtual machine as an
                  example, polymorphic inline caches are discussed as
                  an alternative to global caching. An implementation
                  proposal for polymorphic inline caches in the Squeak
                  virtual machine is presented, and possible future
                  applications for online optimization are outlined.},
  annote = {internationalworkshop},
  author = {Michael Haupt and Robert Hirschfeld and Marcus Denker},
  booktitle = {Proceedings of the Second Workshop on Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems (ICOOOLPS'2007), ECOOP Workshop},
  issn = {1436-9915},
  keywords = {scg07 scg-pub skip-doi jb08 snf07 fromscgbib marcusdenker},
  medium = {2},
  month = jul,
  pages = {17--22},
  peerreview = {yes},
  publisher = {TU Berlin},
  title = {Type feedback for bytecode interpreters},
  url = {http://rmod.lille.inria.fr/archives/workshops/Haup07a-ICOOLPS07-PIC.pdf},
  year = {2007}
}

@inproceedings{Hofe06a,
  abstract = {Traditional debugging and stepping execution trace
                  are well-accepted techniques to understand deep
                  internals about a program. However in many cases
                  navigating the stack trace is not enough to find
                  bugs, since the cause of a bug is often not in the
                  stack trace anymore and old state is lost, so out of
                  reach from the debugger. In this paper, we present
                  the design and implementation of a backward-in-time
                  debugger for a dynamic language, i.e, a debugger
                  that allows one to navigate back the history of the
                  application. We present the design and
                  implementation of a backward-in-time debugger called
                  Unstuck and show our solution to key implementation
                  challenges.},
  aeres = {ACT},
  aeresstatus = {aeres08},
  annote = {internationalconference},
  author = {Christoph Hofer and Marcus Denker and St\'ephane
                  Ducasse},
  booktitle = {Proceedings of NODE'06},
  inria = {hors},
  keywords = {skip-doi scg-pub stefPub jb07 fb06 snf06 fromscgbib marcusdenker},
  medium = {2},
  month = sep,
  organization = {Gesellschaft f{\"u}r Informatik (GI)},
  pages = {17--32},
  peerreview = {yes},
  selectif = {non},
  series = {Lecture Notes in Informatics},
  title = {Design and Implementation of a Backward-In-Time
                  Debugger},
  url = {http://rmod.lille.inria.fr/archives/papers/Hofe06a-NODE06-Unstuck.pdf},
  volume = {P-88},
  year = {2006}
}

@inproceedings{Kuhn05a,
  abstract = {Understanding a software system by just analyzing
                  the structure of the system reveals only half of the
                  picture, since the structure tells us only how the
                  code is working but not what the code is about. What
                  the code is about can be found in the semantics of
                  the source code: names of identifiers, comments etc.
                  In this paper, we analyze how these terms are spread
                  over the source artifacts using Latent Semantic
                  Indexing, an information retrieval technique. We use
                  the assumption that parts of the system that use
                  similar terms are related. We cluster artifacts that
                  use similar terms, and we reveal the most relevant
                  terms for the computed clusters. Our approach works
                  at the level of the source code which makes it
                  language independent. Nevertheless, we correlated
                  the semantics with structural information and we
                  applied it at different levels of abstraction (e.g.
                  classes, methods). We applied our approach on three
                  large case studies and we report the results we
                  obtained.},
  address = {Los Alamitos CA},
  aeres = {ACT},
  aeresstatus = {aeres08},
  annote = {internationalconference},
  author = {Adrian Kuhn and St\'ephane Ducasse and Tudor
                  G\^irba},
  booktitle = {Proceedings of 12th Working Conference on Reverse
                  Engineering (WCRE'05)},
  doi = {10.1109/WCRE.2005.16},
  inria = {hors},
  keywords = {scg-pub semantic clustering lsi stefPub girba jb06
                  recast06 hapax moose-pub listic akuhn},
  location = {Pittsburgh, PA},
  misc = {acceptance rate: 21/58 = 36 \%},
  accepttotal = {58},
  acceptnum = {21},
  month = nov,
  pages = {113--122},
  publisher = {IEEE Computer Society Press},
  rate = {36%},
  selectif = {non},
  title = {Enriching Reverse Engineering with Semantic
                  Clustering},
  url = {http://scg.unibe.ch/archive/papers/Kuhn05aSemanticClustering.pdf},
  year = {2005},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Kuhn05aSemanticClustering.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1109/WCRE.2005.16}
}

@article{Kuhn07a,
  abstract = {Many of the existing approaches in Software
                  Comprehension focus on program program structure or
                  external documentation. However, by analyzing formal
                  information the informal semantics contained in the
                  vocabulary of source code are overlooked. To
                  understand software as a whole, we need to enrich
                  software analysis with the developer knowledge
                  hidden in the code naming. This paper proposes the
                  use of information retrieval to exploit linguistic
                  information found in source code, such as identifier
                  names and comments. We introduce Semantic
                  Clustering, a technique based on Latent Semantic
                  Indexing and clustering to group source artifacts
                  that use similar vocabulary. We call these groups
                  semantic clusters and we interpret them as
                  linguistic topics that reveal the intention of the
                  code. We compare the topics to each other, identify
                  links between them, provide automatically retrieved
                  labels, and use a visualization to illustrate how
                  they are distributed over the system. Our approach
                  is language independent as it works at the level of
                  identifier names. To validate our approach we
                  applied it on several case studies, two of which we
                  present in this paper.},
  address = {Newton, MA, USA},
  aeres = {ACL},
  aereststatus = {2008},
  annote = {internationaljournal},
  author = {Adrian Kuhn and St\'ephane Ducasse and Tudor G\^irba},
  doi = {10.1016/j.infsof.2006.10.017},
  impactfactor = {0.435, SCI 2005},
  inria = {hors},
  issn = {0950-5849},
  journal = {Information and Software Technology},
  keywords = {scg07 moose-pub scg-pub snf07 jb07 recast07 girba stefPub akuhn},
  impactfactor = {ISI impact factor 1.821 (2010)},
  misc = {ISI impact factor 1.821 (2010)},
  month = mar,
  number = {3},
  pages = {230--243},
  peerreview = {yes},
  publisher = {Butterworth-Heinemann},
  title = {Semantic Clustering: Identifying Topics in Source Code},
  url = {http://scg.unibe.ch/archive/drafts/Kuhn06bSemanticClustering.pdf},
  volume = {49},
  year = {2007},
  bdsk-url-1 = {http://scg.unibe.ch/archive/drafts/Kuhn06bSemanticClustering.pdf}
}

@techreport{Kuhn10m,
  author = {Adrian Kuhn and David Erni and Marcus Denker},
  title = {Empowering Collections with Swarm Behavior},
  institution = {Arxiv},
  number = {arXiv:1007.0159},
  keywords = {lse-pub marcusdenker},
  month = jul,
  url = {http://rmod.lille.inria.fr/archives/reports/Kuhn10a-ArXiv-SwarmBehavior.pdf},
  year = {2010},
  inria = {RMOD},
  aeresstatus = {aeres12},
  annote = {technicalReport notrefereed},
  aeres = {AP},
  x-editorial-board = {no},
  x-proceedings = {no},
  x-international-audience = {yes},
  x-country = {CH},
  x-language = {EN},
  abstract = {Often, when modelling a system there are properties and operations that
	 are related to a group of objects rather than to a single object. In this paper we extend
	 Java with Swarm Behavior, a new composition operator that associates behavior with
	 a collection of instances. The lookup resolution of swarm behavior is based on the element
	 type of a collection and is thus orthogonal to the collection hierarchy.}
}

@inproceedings{Lanz01a,
  abstract = {One of the main problems which arises in the field
                  of software evolution is the sheer amount of
                  information to be dealt with. Compared to reverse
                  engineering where the main goal is the main
                  understanding of one single system. In the field of
                  software evolution this information is multiplied by
                  the number of versions of the system one wants to
                  understand. To counter this problem we have come up
                  with a flexible query engine which can perform
                  queries on the different versions of a system. In
                  this paper we give an outlook on our current work in
                  the field of software evolution and focus
                  particularly on the concepts behind the query engine
                  we have built.},
  annote = {internationalworkshop},
  author = {Michele Lanza and St\'ephane Ducasse and Lukas Steiger},
  booktitle = {Proceedings of the Workshop on Formal Foundations of
                  Software Evolution},
  keywords = {scg-pub skip-doi snf01 jb01 stefPub moose-pub},
  title = {Understanding Software Evolution using a Flexible
                  Query Engine},
  url = {http://scg.unibe.ch/archive/papers/Lanz01aQueryEngine.pdf},
  year = {2001},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Lanz01aQueryEngine.pdf}
}


@inproceedings{Lanz01b,
  abstract = {The reengineering and reverse engineering of
                  software systems is gaining importance in software
                  industry, because the accelerated turnover in
                  software companies creates legacy systems in a
                  shorter period of time. Especially understanding
                  classes is a key activity in object-oriented
                  programming, since classes represent the primary
                  abstractions from which applications are built. The
                  main problem of this task is to quickly grasp the
                  purpose of a class and its inner structure. To help
                  the reverse engineers in their first contact with a
                  foreign system, we propose a categorization of
                  classes based on the visualization of their internal
                  structure. The contributions of this paper are a
                  novel categorization of classes and a visualization
                  of the classes which we call the class blueprint. We
                  have validated the categorization on several case
                  studies, two of which we present here.},
  annote = {internationalconference topconference},
  author = {Michele Lanza and St\'ephane Ducasse},
  booktitle = {Proceedings of 16th International Conference on
                  Object-Oriented Programming Systems, Languages and
                  Applications (OOPSLA '01)},
  doi = {10.1145/504282.504304},
  keywords = {scg-pub snf01 jb01 stefPub moose-pub},
  misc = {acceptance rate: 27/145 = 18\%},
  accepttotal = {145},
  acceptnum = {27},
  pages = {300--311},
  publisher = {ACM Press},
  title = {A {Categorization} of {Classes} based on the
                  {Visualization} of their {Internal} {Structure}: the
                  {Class} {Blueprint}},
  url = {http://scg.unibe.ch/archive/papers/Lanz01bClassBlueprint.pdf},
  year = {2001},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Lanz01bClassBlueprint.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1145/504282.504304}
}

@inproceedings{Lanz01d,
  abstract = {Understanding classes is a key activity in
                  object-oriented programming, since classes represent
                  the primary abstractions from which applications are
                  built. The main problem of this task is to quickly
                  grasp the purpose and inner structure of a class. In
                  this paper we discuss the class blueprint, a
                  visualization of the inner structure of classes.},
  annote = {internationalworkshop},
  author = {Michele Lanza and St\'ephane Ducasse},
  booktitle = {Workshop Proceedings of OOPSLA 2001},
  keywords = {scg-pub skip-doi snf01 jb01 stefPub moose-pub},
  title = {The Class Blueprint: A Visualization of the Internal
                  Structure of Classes},
  url = {http://scg.unibe.ch/archive/papers/Lanz01dClassBlueprint.pdf},
  year = {2001},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Lanz01dClassBlueprint.pdf}
}

@inproceedings{Lanz02a,
  abstract = {Coping with huge amounts of data is one of the major
                  problems in the context of software evolution.
                  Current approaches reduce this complexity by
                  filtering out irrelevant information. In this paper
                  we propose an approach based on a combination of
                  software visualization and software metrics, as
                  software visualization is apt for complexity
                  reduction and metrics introduce the possibility to
                  qualify evolution. We discuss a simple and effective
                  way to visualize the evolution of software systems
                  which helps to recover the evolution of object
                  oriented software systems. In addition we define a
                  vocabulary that qualifies some specific situations
                  that occurs when considering system evolution.},
  address = {Paris},
  annote = {nationalconference},
  author = {Michele Lanza and St\'ephane Ducasse},
  booktitle = {Proceedings of Langages et Mod\`eles \`a Objets
                  (LMO'02)},
  keywords = {scg-pub skip-doi jb02 snf02 stefPub moose-pub},
  pages = {135--149},
  publisher = {Lavoisier},
  title = {Understanding Software Evolution Using a Combination
                  of Software Visualization and Software Metrics},
  url = {http://scg.unibe.ch/archive/papers/Lanz02aEvolutionMatrix.pdf},
  year = {2002},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Lanz02aEvolutionMatrix.pdf}
}

@inproceedings{Lanz02b,
  abstract = {Software Metrics have become essential in software
                  engineering for several reasons, among which quality
                  assessment and reengineering. In the context of the
                  European Esprit Pro ject FAMOOS, whose main goal was
                  to provide methodologies for the reengineering of
                  large industrial software systems, we have developed
                  the Moose Reengineering Environment, based on the
                  language independent FAMIX metamodel. Moose includes
                  a metrics engine which supports language independent
                  metrics, since coping with software written in
                  different implementation languages was one of the
                  project's main constraints. Our current research is
                  pushing us towards the development and
                  implementation of a metametamodel, which would
                  include our metamodel and allow for several
                  extension in different research directions, among
                  which concept analysis, knowledge management and
                  software evolution. In this article we want to
                  present our current and future work for the
                  transition from language independent to domain
                  independent metrics.},
  annote = {internationalworkshop},
  author = {Michele Lanza and St\'ephane Ducasse},
  booktitle = {Proceedings of the 6th International Workshop on
                  Quantitative Approaches in Object-Oriented Software
                  Engineering},
  editor = {Fernando Brito e Abreu and Mario Piattini and Geert
                  Poels and Houari A. Sahraoui},
  isbn = {84-699-8696-1},
  keywords = {scg-pub skip-doi jb02 snf02 stefPub moose-pub},
  pages = {77--84},
  title = {Beyond Language Independent Object-Oriented Metrics:
                  Model Independent Metrics},
  url = {http://scg.unibe.ch/archive/papers/Lanz02bModelIndependentMetrics.pdf},
  year = {2002},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Lanz02bModelIndependentMetrics.pdf}
}

@article{Lanz03d,
  abstract = {Reverse engineering software systems has become a
                  major concern in software industry because of their
                  sheer size and complexity. This problem needs to be
                  tackled, since the systems in question are of
                  considerable worth to their owners an d maintainers.
                  In this article we present the concept of a
                  polymetric view, a lightweight software
                  visualization technique enriched with software
                  metrics information. Polymetric views help to
                  understand the structure and detect problems of a
                  software system in the initial phases of a reverse
                  engineering process. We discuss the benefits and
                  limits of several predefined polymetric views we
                  have implemented in our tool CodeCrawler. Moreover,
                  based on clusters of different polymetric views we
                  have developed a methodology which supports and
                  guides a software engineer in the first phases of a
                  reverse engineering of a large software system. We
                  have refined this methodology by repeatedly applying
                  it on industrial systems, and illustrate it by
                  applying a selection of polymetric views to a case
                  study.},
  annote = {internationaljournal},
  author = {Michele Lanza and St\'ephane Ducasse},
  doi = {10.1109/TSE.2003.1232284},
  journal = {Transactions on Software Engineering (TSE)},
  keywords = {scg-pub jb04 recast04 stefPub moose-pub},
  misc = {5-Year ISI impact factor 4.865 (2010)},
  impactfactor = {5-Year ISI impact factor 4.865 (2010)},
  mismisc = {SCI impact factor 1.73},
  month = sep,
  number = {9},
  pages = {782--795},
  publisher = {IEEE Computer Society},
  title = {Polymetric Views---A Lightweight Visual Approach to  Reverse Engineering},
  url = {http://scg.unibe.ch/archive/papers/Lanz03dTSEPolymetric.pdf},
  volume = {29},
  year = {2003},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Lanz03dTSEPolymetric.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1109/TSE.2003.1232284}
}

@inproceedings{Lanz05a,
  annote = {tooldemo},
  author = {Michele Lanza and St\'ephane Ducasse and Harald Gall and Martin Pinzger},
  booktitle = {Proceedings of ICSE 2005 (27th IEEE International Conference on Software Engineering)},
  keywords = {mlanza moose-pub},
  pages = {672--673},
  publisher = {ACM Press},
  title = {{CodeCrawler} --- An Information Visualization Tool for Program Comprehension},
  year = {2005}
}

@incollection{Lanz05b,
  abstract = {CodeCrawler is an extensible and language
                  independent software visualization tool. It has been
                  validated in several industrial case studies over
                  the past years. CodeCrawler enables the fast
                  exploration of new visualization ideas. It
                  implements and visualizes polymetric views,
                  visualizations of software enriched with information
                  such as software metrics and other source code
                  semantics. It provides a rich set of views that can
                  be customized using a large set of metrics. While
                  CodeCrawler is mainly targeted at visualizing
                  object-oriented software, in its latest
                  implementation it has become a general information
                  visualization tool.},
  address = {Milano},
  aeres = {OS},
  aeresstatus = {aeres08},
  annote = {articlebook},
  author = {Michele Lanza and St\'ephane Ducasse},
  booktitle = {Tools for Software Maintenance and Reengineering},
  inria = {hors},
  isbn = {88-464-6396-X},
  keywords = {scg-pub skip-doi stefPub recast05 jb05 moose-pub},
  pages = {74--94},
  publisher = {Franco Angeli},
  selectif = {non},
  series = {RCOST / Software Technology Series},
  title = {{CodeCrawler} --- An Extensible and Language
                  Independent 2D and 3D Software Visualization Tool},
  url = {http://scg.unibe.ch/archive/papers/Lanz05bCCBookChapter.pdf},
  year = {2005},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Lanz05bCCBookChapter.pdf}
}

@inproceedings{Laut09a,
  title = {Meteoroid Towards a real MVC for the Web},
  abstract = {Web development has moved from simple static pages to complex web applications, some of them
resembling desktop ones. In most of these applications the web browser acts as thin-client (or a view) of the
model that sits on the server. Despite the technological evolution of the web, there is still no standard
mechanism to send data or events from the server to the client without an explicit request from the later,
thus forcing the web browser to constantly poll the server for updates. To solve this problem a set of
techniques under the name of Comet were proposed, allowing to send information from the server to the web
browser without an explicit client request. In this paper we introduce Meteoroid, a Comet approach to make
live Seaside applications. Our framework exploits the Model-View-Controller (MVC) paradigm for building
 simple yet scalable web applications, requiring very little programming effort.},
  annote = {internationalworkshop},
  author = {Juan Lautaro Fern\'andez and Santiago Robles	and Andr\'es Fortier and St\'ephane Ducasse
and Gustavo Rossi and 	Silvia Gordillo},
  booktitle = {Proceedings of International Workshop on Smalltalk Technologies (IWST 2009)},
  peer = {yes},
  keywords = {stefPub},
  location = {Brest, France},
  publisher = {ACM Digital Library},
  year = {2009},
  inriareport = {2009},
  aeres = {ACT},
  aeresstatus = {aeres12},
  selectif = {non},
  inria = {RMOD},
  x-pays = {AR},
  x-editorial-board = {yes},
  x-proceedings = {yes},
  x-international-audience = {yes},
  url = {http://rmod.lille.inria.fr/archives/workshops/Laut09a-IWST09-Meteroid.pdf}
}

@inproceedings{Lava08a,
  author = {Jannik Laval and Alexandre Bergel and St\'ephane Ducasse},
  title = {Assessing the Quality of your Software with MoQam},
  annote = {internationalworkshop},
  keywords = {moose-pub lse-pub stefPub},
  booktitle = {FAMOOSr, 2nd Workshop on FAMIX and Moose in Reengineering},
  url = {http://rmod.lille.inria.fr/archives/workshops/Lava08a-Famoosr2008-MoQam.pdf},
  year = {2008},
  x-editorial-board = {yes},
  x-proceedings = {no},
  x-international-audience = {yes},
  hal-id = {inria-00498482}
}

@inproceedings{Lava09a,
  title = {Matrice de d\'ependances enrichie},
  author = {Jannik Laval and Alexandre Bergel and St\'ephane Ducasse},
  booktitle = {Proceedings of Languages et Mod\`eles \`a Objets (LMO 2009)},
  annote = {nationalconference},
  keywords = {moose-pub lse-pub},
  year = {2009},
  inria = {RMOD},
  inriareport = {2009},
  x-editorial-board = {yes},
  x-proceedings = {yes},
  x-international-audience = {no},
  x-country = {FR},
  x-language = {FR},
  address = {Nancy, France},
  url = {http://rmod.lille.inria.fr/archives/papers/Lava09a-LMO2009-DSM.pdf},
  abstract = {Les matrices de d\'ependance (DSM - Dependency Structure Matrix), d\'evelopp\'ees dans le cadre de l'optimisation de processus, ont fait leurs preuves pour identifier les d\'ependances logicielles entre des packages ou des sous-syst\`e\-mes. Il existe plusieurs algorithmes pour structurer une matrice de fa\c con \`a ce qu'elle refl\`ete l'architecture des \'el\'ements analys\'es et mette en \'evidence des cycles entre les sous-sys\-t\`e\-mes. Cependant, les impl\'ementations de matrices de d\'ependance existantes manquent d'informations importantes pour apporter une r\'eelle aide au travail de r\'eing\'enierie. Par exemple, le poids des relations qui posent probl\`eme ainsi que leur type ne sont pas clairement pr\'esent\'es. Ou encore, des cycles ind\'ependants sont fusionn\'es. Il est \'egalement difficile d'obtenir une visualisation centr\'ee sur un package.  Dans ce papier, nous am\'eliorons les matrices de d\'ependance en ajoutant des informations sur (i) le type de r\'ef\'erences, (ii) le nombre d'entit\'es r\'ef\'eren\c cantes, (iii) le nombre d'entit\'es r\'ef\'erenc\'ees. Nous  distinguons \'egalement les cycles ind\'ependants. Ce travail a \'et\'e impl\'ement\'e dans l'environnement de r\'eing\'enierie open-source \emph{Moose}. Il a \'et\'e appliqu\'e \`a des \'etudes de cas complexes comme le framework \emph{Morphic UI} contenu dans les environnements Smalltalk open-source \emph{Squeak} et  \emph{Pharo}. Les r\'esultats obtenus ont \'et\'e appliqu\'es dans l'environnement de programmation \emph{Pharo} et ont men\'e \`a des am\'eliorations.},
  hal-id = {inria-00498463 /}
}

@inproceedings{Lava09b,
  title = {Supporting Incremental Changes in Large Models},
  author = {Jannik Laval and Simon Denier and St\'ephane Ducasse and Andy Kellens},
  booktitle = {Proceedings of ESUG International Workshop on Smalltalk Technologies (IWST 2009)},
  year = {2009},
  keywords = {moose-pub lse-pub},
  annote = {internationalworkshop},
  aeres = {ACT},
  aeresstatus = {aeres12},
  selectif = {oui},
  inria = {RMOD},
  inriareport = {2009},
  labo = {dans},
  x-pays = {BE},
  x-editorial-board = {yes},
  x-proceedings = {yes},
  x-international-audience = {yes},
  x-country = {FR},
  x-language = {EN},
  address = {Brest, France},
  url = {http://rmod.lille.inria.fr/archives/workshops/Lava09b-IWST09-incrementalChange.pdf},
  abstract = {When reengineering large systems, software developers would like to assess and compare the impact of multiple change scenarios without actually performing these changes. A change can be ef- fected by applying a tool to the source code, or by a manual refac- toring. In addition, tools run over a model are costly to redevelop. It raises an interesting challenge for tools implementors: how to support modification of large source code models to enable com- parison of multiple versions. One naive approach is to copy the entire model after each modification. However, such an approach is too expensive in memory and execution time. In this paper we ex- plore different implementations that source code metamodels sup- port multiple versions of a system. We propose a solution based on dynamic binding of entities between multiple versions, providing good access performance while minimizing memory consumption.},
  hal-id = {inria-00498492 /}
}

@inproceedings{Lava09c,
  title = {Identifying cycle causes with Enriched Dependency Structural Matrix},
  author = {Jannik Laval and Simon Denier and St\'ephane Ducasse and Alexandre Bergel},
  booktitle = {WCRE '09: Proceedings of the 2009 16th Working Conference on Reverse Engineering},
  year = {2009},
  keywords = {moose-pub lse-pub},
  aeres = {ACT},
  misc = {Acceptance rate: 20/79 = 25\%},
  rate = {25\%},
  annote = {internationalconference},
  aeresstatus = {aeres12},
  labo = {dans},
  inria = {RMOD},
  inriareport = {2009},
  selectif = {oui},
  x-editorial-board = {yes},
  x-proceedings = {yes},
  x-international-audience = {yes},
  x-language = {EN},
  x-country = {FR},
  address = {Lille, France},
  url = {http://rmod.lille.inria.fr/archives/papers/Lava09c-WCRE2009-eDSM.pdf},
  abstract = {Dependency Structure Matrix (DSM) has been successfully applied to identify software
 dependencies among packages and subsystems. A number of algorithms were proposed to compute the
 matrix so that it highlights patterns and problematic dependencies between subsystems. However,
 existing DSM implementations often miss important information to fully support reengineering
 effort. For example, they do not clearly qualify and quantify problematic relationships,
 information which is crucial to support remediation tasks.
In this paper we present enriched DSM (eDSM) where cells are enriched with contextual information
 about (i) the type of dependencies (inheritance, class reference . . . ), (ii) the proportion of
 referencing entities, (iii) the proportion of referenced entities. We distinguish independent
 cycles and stress potentially simple fixes for cycles using coloring information. This work is
 language independent and has been implemented on top of the Moose reengineering environment. It has
 been applied to non-trivial case studies among which ArgoUML, and Morphic the UI framework
 available in two open-source Smalltalks, Squeak and Pharo. Solution to problems identified by eDSM
 have been performed and retrofitted in Pharo main distribution.},
  hal-id = {inria-00498446 /}
}

@inproceedings{Lava09d,
  title = {Identifying cycle causes with CycleTable},
  author = {Jannik Laval and Simon Denier and St\'ephane Ducasse},
  booktitle = {FAMOOSr 2009: 3rd Workshop on FAMIX and MOOSE in Software Reengineering},
  year = {2009},
  keywords = {moose-pub lse-pub},
  aeres = {ACT},
  annote = {internationalworkshop},
  aeresstatus = {aeres12},
  labo = {dans},
  inria = {RMOD},
  inriareport = {2009},
  selectif = {non},
  x-editorial-board = {yes},
  x-proceedings = {yes},
  x-international-audience = {yes},
  x-language = {EN},
  x-country = {FR},
  address = {Brest, France},
  url = {http://rmod.lille.inria.fr/archives/workshops/Lava09d-Famoosr2009-CycleTable.pdf},
  abstract = {No abstract},
  hal-id = {inria-00498495}
}

@misc{Lava10a,
  annote = {vulgarisation},
  author = {Jannik Laval and St\'ephane Ducasse},
  journal = {Linux Magazine},
  annote = {vulgarisation},
  keywords = {pharo-pub lse-pub},
  month = jan,
  number = 123,
  aeres = {OV},
  aeresstatus = {aeres12},
  selectif = {non},
  inria = {RMOD},
  inriareport = {2010},
  title = {Optimisation d'applications en Pharo},
  x-scientific-popularization = {yes},
  volume = 1,
  year = {2010}
}

@article{Lava10b,
  title = {Supporting Simultaneous Versions for Software Evolution Assessment},
  author = {Jannik Laval and Simon Denier and St\'ephane Ducasse and Jean-R\'emy Falleri},
  journal = {Journal of Science of Computer Programming (SCP)},
  annote = {internationaljournal},
  keywords = {sub lse-pub moose-pub},
  year = {2010},
  month = may,
  inriareport = {2010},
  aeres = {ACL},
  aeresstatus = {aeres12},
  labo = {dans},
  inria = {RMOD},
  misc = {Core A},
  impactfactor = {Core A},
  selectif = {oui},
  abstract = {When reengineering software systems, maintainers should be able to assess and compare multiple change scenarios for a given goal, so as to choose the most pertinent one. Because they implicitly consider one single working copy, revision control systems do not scale up well to perform simultaneous analyses of multiple versions of systems. We designed Orion, an interactive prototyping tool for reengineering, to simulate changes and compare their impact on multiple versions of software source code models. Our approach offers an interactive simulation of changes, reuses existing assessment tools, and has the ability to hold multiple and branching versions simultaneously in memory. Specifically, we devise an infrastructure which optimizes memory usage of multiple versions for large models. This infrastructure uses an extension of the FAMIX source code meta-model but it is not limited to source code analysis tools since it can be applied to models in general. In this paper, we validate our approach by running benchmarks on memory usage and computation time of model queries on large models. Our benchmarks show that the Orion approach scales up well in terms of memory usage, while the current implementation could be optimized to lower its computation time. We also report on two large case studies on which we applied Orion.},
  x-editorial-board = {yes},
  x-proceedings = {yes},
  x-international-audience = {yes},
  x-language = {EN},
  hal-id = {inria-00531500},
  x-scientific-popularization = {yes},
  url = {http://rmod.lille.inria.fr/archives/papers/Lava10a-SCP-Orion.pdf}
}

@misc{Lava10c,
  annote = {vulgarisation},
  author = {Jannik Laval and St\'ephane Ducasse},
  journal = {Linux Magazine},
  annote = {vulgarisation},
  keywords = {pharo-pub lse-pub},
  month = sep,
  number = 130,
  aeres = {OV},
  aeresstatus = {aeres12},
  selectif = {non},
  inria = {RMOD},
  inriareport = {2010},
  title = {Pharo: un nouveau Smalltalk open source},
  x-scientific-popularization = {yes},
  volume = 1,
  year = {2010}
}

@misc{Lava10d,
  annote       = {vulgarisation},
  author       = {Jannik Laval and St\'ephane Ducasse},
  journal      = {Linux Magazine},
  annote = {vulgarisation},
  keywords     = {pharo-pub lse-pub},
  month	       = nov,
  number       = 132,
  aeres	       = {OV},
  aeresstatus  = {aeres12},
  selectif     = {non},
  inria	       = {RMOD},
  title	       = {Package et gestion de versions en Pharo},
  x-scientific-popularization = {yes},
  volume       = 1,
  Year	       = {2010}
}

@techreport{Leth97a,
  author = {Timothy C. Lethbridge and Nicolas Anquetil},
  institution = {University of Ottawa},
  month = jul,
  note = {Computer Science Technical Report of University of Ottawa},
  title = {Architecture of a Source Code Exploration Tool: A Software Engineering Case Study},
  url = {http://www.site.uottawa.ca/~tcl/papers/index.html},
  year = {1997},
  bdsk-url-1 = {http://www.site.uottawa.ca/~tcl/papers/index.html}
}

@inproceedings{Lian02a,
  abstract = {PECOS is a collaborative project between industrial
                  and research partners that seeks to enable
                  component-based technology for a class of embedded
                  systems known as "field devices". Results so far
                  include a component model for field devices and a
                  composition language for specifying connections
                  between software components. Here we investigate the
                  application of Rate Monotonic Analysis (RMA) to the
                  problem of generating real-time schedules for
                  compositions of field device components.},
  annote = {internationalworkshop},
  author = {Peng Liang and Gabriela Ar{\'e}valo and St\'ephane
                  Ducasse and Michele Lanza and Nathanael Sch{\"a}rli
                  and Roel Wuyts and Oscar Nierstrasz},
  booktitle = {ECOOP 2002 Workshop Reader},
  keywords = {scg-pub skip-doi jb02 pecos stefPub arevalo
                  schaerli},
  title = {Applying RMA for Scheduling Field Device Components},
  url = {http://scg.unibe.ch/archive/papers/Lian02aPecosRMA.pdf},
  year = {2002},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Lian02aPecosRMA.pdf}
}

@inproceedings{Lien05a,
  abstract = {Traits are basically mixins or interfaces but with
                  method bodies. In languages that support traits,
                  classes are composed out of traits. There are two
                  main advantages with traits. Firstly, decomposing
                  existing classes into traits from which they can be
                  recomposed improves the factoring of hierarchies.
                  Secondly it increases the library reuse potential by
                  providing more reusable traits. Identifying traits
                  and decomposing class hierarchies into traits is
                  therefore an important and challenging task to
                  facilitate maintainability and evolution. In this
                  paper we present how we use Formal Concept Analysis
                  to identify traits in inheritance hierarchies. Our
                  approach is two-staged: first we identify within a
                  hierarchy maximal groups of methods that have a set
                  of classes in common, second we cluster cohesive
                  groups of methods based on method invocations as
                  potential traits. We applied our approach on two
                  significant hierarchies and compare our results with
                  the manual refactorization of the same code which
                  was done by the authors of traits.},
  aeres = {ACT},
  aeresstatus = {aeres08},
  annote = {internationalconference topconference},
  author = {Adrian Lienhard and St\'ephane Ducasse and Gabriela
                  Ar{\'e}valo},
  booktitle = {Proceedings of 20th Conference on Automated Software
                  Engineering (ASE'05)},
  cvs = {ConAnASE05Traits},
  doi = {10.1145/1101908.1101921},
  inria = {hors},
  keywords = {scg-pub snf05 recast06 stefPub moose-pub arevalo
                  jb06 listic},
  medium = {2},
  misc = {acceptance rate: 28/291 = 9\%},
  accepttotal = {291},
  acceptnum = {28},
  month = nov,
  pages = {66--75},
  peerreview = {yes},
  publisher = {IEEE Computer Society},
  rate = {9%},
  selectif = {oui},
  title = {Identifying Traits with Formal Concept Analysis},
  url = {http://scg.unibe.ch/archive/papers/Lien05aIdentifyingTraits.pdf},
  year = {2005},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Lien05aIdentifyingTraits.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1145/1101908.1101921}
}

@inproceedings{Lien06a,
  abstract = {Most of today's dynamic analysis approaches are
                  based on method traces. However, in the case of
                  object-orientation understanding program execution
                  by analyzing method traces is complicated because
                  the behavior of a program depends on the sharing and
                  the transfer of object references (aliasing). We
                  argue that trace-based dynamic analysis is at a too
                  low level of abstraction for object-oriented
                  systems. We propose a new approach that captures the
                  life cycle of objects by explicitly taking into
                  account object aliasing and how aliases propagate
                  during the execution of the program. In this paper,
                  we present in detail our new meta-model and discuss
                  future tracks opened by it.},
  annote = {internationalworkshop},
  author = {Adrian Lienhard and St\'ephane Ducasse and Tudor
                  G\^irba and Oscar Nierstrasz},
  booktitle = {Proceedings International Workshop on Program
                  Comprehension through Dynamic Analysis (PCODA'06)},
  keywords = {scg-pub skip-doi stefPub girba jb07 fb06 snf07
                  object-flow dynamic-analysis},
  medium = {2},
  pages = {39--43},
  peerreview = {yes},
  title = {Capturing How Objects Flow At Runtime},
  url = {http://scg.unibe.ch/archive/papers/Lien06aCapturingHowObjectsFlowPCODA06.pdf
                  http://www.lore.ua.ac.be/Events/PCODA2006/pcoda2006proceedings.pdf},
  year = {2006}
}

@inproceedings{Lien07c,
  abstract = {To extract abstract views of the behavior of an
                  object-oriented system for reverse engineering, a
                  body of research exists that analyzes a system's
                  runtime execution. Those approaches primarily
                  analyze the control flow by tracing method execution
                  events. However, they do not capture information
                  flows. We address this problem by proposing a novel
                  dynamic analysis technique named Object Flow
                  Analysis, which complements method execution tracing
                  with an accurate analysis of the runtime flow of
                  objects. To exemplify the usefulness of our analysis
                  we present a visual approach that allows a system
                  engineer to study classes and components in terms of
                  how they exchange objects at runtime. We illustrate
                  and validate our approach on two case studies.},
  address = {New York, NY, USA},
  aeres = {ACT},
  aeresstatus = {aeres08},
  annote = {internationalconference},
  author = {Adrian Lienhard and St\'ephane Ducasse and Tudor
                  G\^irba},
  booktitle = {Proceedings of the 2007 International Conference on
                  Dynamic Languages (ICDL'07)},
  doi = {10.1145/1352678.1352686},
  inria = {hors},
  isbn = {978-1-60558-084-5},
  keywords = {scg07 scg-pub jb08 snf08 girba moose-pub object-flow
                  dynamic-analysis},
  location = {Lugano, Switzerland},
  medium = {2},
  pages = {121--140},
  peerreview = {yes},
  publisher = {ACM Digital Library},
  selectif = {non},
  title = {Object Flow Analysis --- Taking an Object-Centric
                  View on Dynamic Analysis},
  url = {http://scg.unibe.ch/archive/papers/Lien07c-ObjectFlowAnalysis.pdf},
  year = {2007},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Lien07c-ObjectFlowAnalysis.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1145/1352678.1352686}
}

@article{Lien08c,
  abstract = {A large body of research analyzes the runtime
                  execution of a system to extract abstract behavioral
                  views. Those approaches primarily analyze control
                  flow by tracing method execution events or they
                  analyze object graphs of heap snapshots. However,
                  they do not capture how objects are passed through
                  the system at runtime. We refer to the exchange of
                  objects as the object flow, and we claim that object
                  flow is necessary to analyze if we are to understand
                  the runtime of an object-oriented application. We
                  propose and detail Object Flow Analysis, a novel
                  dynamic analysis technique that takes this new
                  information into account. To evaluate its
                  usefulness, we present a visual approach that allows
                  a developer to study classes and components in terms
                  of how they exchange objects at runtime. We
                  illustrate our approach on three case studies.},
  aeres = {ACL},
  aeresstatus = {aeres10},
  annote = {internationaljournal},
  author = {Adrian Lienhard and St\'ephane Ducasse and Tudor  G\^irba},
  doi = {10.1016/j.cl.2008.05.006},
  inria = {hors},
  journal = {Journal of Computer Languages, Systems and Structures},
  keywords = {scg09 scg-pub girba moose-pub object-flow dynamic-analysis remoose jb09 snf09},
  impactfactor = {5 Year ISI impact factor 0.698 (2010)},
  misc = {5 Year ISI impact factor 0.698 (2010)},
  number = {1},
  pages = {63--79},
  peerreview = {yes},
  publisher = {Elsevier},
  selectif = {non},
  title = {Taking an Object-Centric View on Dynamic Information with Object Flow Analysis},
  url = {http://scg.unibe.ch/archive/papers/Lien08cObjectFlowAnalysis.pdf},
  volume = {35},
  year = {2009},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Lien08cObjectFlowAnalysis.pdf}
}

@inproceedings{Loew07a,
  abstract = {While many software systems today have to be aware
                  of the context in which they are executing, there is
                  still little support for structuring a program with
                  respect to context. A first step towards better
                  context-orientation was the introduction of method
                  layers. This paper proposes two additional language
                  concepts, namely the implicit activation of method
                  layers, and the introduction of dynamic variables},
  annote = {internationalconference},
  author = {Martin von L\"owis and Marcus Denker and Oscar Nierstrasz},
  booktitle = {Proceedings of the 2007 International Conference on
                  Dynamic Languages (ICDL 2007)},
  doi = {10.1145/1352678.1352688},
  isbn = {978-1-60558-084-5},
  keywords = {scg07 scg-pub jb08 snf08 fromscgbib marcusdenker},
  medium = {2},
  pages = {143--156},
  peerreview = {yes},
  publisher = {ACM Digital Library},
  title = {Context-Oriented Programming: Beyond Layers},
  url = {http://rmod.lille.inria.fr/archives/papers/Loew07a-ICDL07-PyContext.pdf},
  year = {2007}
}

@inproceedings{Manj02a,
  annote = {internationalconference},
  author = {Manjarr\'es, Angeles and Suny\'e, Gerson and Pollet, Damien and Pickin, Simon and J\'ez\'equel, Jean-Marc},
  booktitle = {International Conference on Software Engineering and Knowledge Engineering (SEKE)},
  editor = {ACM},
  month = {jul},
  pages = {237--238},
  title = {AI Analysis Patterns as UML Meta-model Constructs},
  url = {http://www.irisa.fr/triskell/publis/2002/Manjarres02a.pdf},
  year = {2002},
  bdsk-url-1 = {http://www.irisa.fr/triskell/publis/2002/Manjarres02a.pdf}
}

@inproceedings{Manj02b,
  annote = {internationalconference},
  author = {Manjarr\'es, Angeles and Pickin, Simon and Suny\'e,
                  Gerson and Pollet, Damien and J\'ez\'equel,
                  Jean-Marc},
  booktitle = {SGAI International Conference on Knowledge Based
                  Systems and Applied Artificial Intelligence:
                  Research and Development in Intelligent Systems XIX
                  (ES2002)},
  month = {dec},
  publisher = {Springer Verlag},
  series = {BCS Conference Series},
  title = {OO Analysis Patterns as UML Metalevel
                  Collaborations},
  year = {2002}
}

@inproceedings{Mens05a,
  aeres = {ACT},
  aeresstatus = {aeres08},
  annote = {internationalworkshop},
  author = {Tom Mens and Michel Wermelinger and St\'ephane Ducasse and Serge Demeyer and Robert Hirschfeld and Mehdi Jazayeri},
  booktitle = {Proceedings of the International Workshop on Principles of Software Evolution (IWPSE 2005)},
  inria = {hors},
  keywords = {stefPub scgPub},
  misc = {acceptance rate: 13/54 = 24\%},
  accepttotal = {54},
  acceptnum = {13},
  pages = {123--131},
  publisher = {IEEE Computer Society},
  rate = {24%},
  selectif = {oui},
  title = {Challenges in Software Evolution},
  year = {2005}
}

@inproceedings{Minj05a,
  abstract = {The trait model is complementary to class
                  inheritance and allows collections of methods to be
                  reused by several classes. The classbox model allows
                  a collection of classes to be locally extended with
                  variables and/or methods addition. This paper
                  describes a symbiosis of these two models: classes
                  can be locally extended by using a trait. It is
                  illustrated by an efficient implementation of the
                  collaboration model where a collaboration is
                  represented by a classbox and a role by a trait.},
  address = {Bern, Switzerland},
  aeres = {ACL},
  annote = {nationalconference},
  author = {Florian Minjat and Alexandre Bergel and Pierre Cointe and St\'ephane Ducasse},
  booktitle = {Actes de Langages et Mod\`eles \`a Objets (LMO'05)},
  inria = {hors},
  keywords = {traits classbox scg-pub skip-doi scg stefPub jb05
                  alexPub alexandrePub noWorkshop snf05},
  pages = {33--46},
  selectif = {non},
  title = {Mise en symbiose des traits et des classboxes : Application \`a l'expression des collaborations},
  url = {http://scg.unibe.ch/archive/papers/Minj05a-TraitClassbox.pdf},
  volume = {11},
  year = {2005},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Minj05a-TraitClassbox.pdf}
}

@inproceedings{Mord09a,
  author = {Karine Mordal-Manet and Fran{\c c}oise Balmas and Simon Denier and St\'ephane Ducasse and Harald Wertz and Jannik Laval and Fabrice Bellingard and Philippe Vaillergues},
  title = {The Squale Model -- A Practice-based Industrial Quality Model},
  annote = {internationalconference},
  booktitle = {ICSM '09: Proceedings of the IEEE International Conference on Software Maintenance},
  abstract = {No abstract},
  misc = {acceptance rate: 35(+29)/162: 21(40)\% for short papers},
  rate = {40\%},
  keywords = {squale-pub lse-pub},
  aeres = {ACT},
  aeresstatus = {aeres12},
  selectif = {oui},
  labo = {dans},
  inria = {RMOD},
  inriareport = {2009},
  pages = {94--103},
  keywords = {moose-pub},
  year = {2009},
  x-editorial-board = {yes},
  x-proceedings = {yes},
  x-international-audience = {yes},
  x-language = {EN},
  x-country = {FR},
  address = {Edmonton, Canada},
  url = {http://rmod.lille.inria.fr/archives/papers/Mord09a-ICSM2009-SqualeModel.pdf}
}

@techreport{Mord09b,
  author = {Karine Mordal-Manet and Fran{\c c}oise Balmas and Simon Denier and St\'ephane Ducasse and Harald Wertz and Jannik Laval and Fabrice Bellingard and Philippe Vaillergues},
  title = {The Squale Model -- A \emph{Practice-}based Industrial Quality Model},
  keywords = {squale-pub lse-pub},
  annote = {technicalReport stefPub},
  institution = {INRIA Lille Nord Europe},
  type_rapport = {Rapport technique},
  year = {2009},
  inria = {RMOD},
  inriareport = {2009},
  x-language = {EN},
  abstract = {No abstract}
}

@inproceedings{Moug03a,
  abstract = {Array programming shines in its ability to express
                  computations at a high-level of abstraction,
                  allowing one to manipulate and query whole sets of
                  data at once. This paper presents the OPA model that
                  enhances object-oriented programming with array
                  programming features. The goal of OPA is to
                  determine a minimum set of modifications that must
                  be made to the traditional object model in order to
                  take advantage of the possibilities of array
                  programming. It is based on a minimal extension of
                  method invocation and the definition of a kernel of
                  methods implementing fundamental array programming
                  operations. The OPA model presents a generalization
                  of traditional message passing in the sense that a
                  message can be send to an entire set of objects. The
                  model is validated in FS, a new scripting language.},
  annote = {internationalconference topconference},
  author = {Philippe Mougin and St\'ephane Ducasse},
  booktitle = {Proceedings of 17th International Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA'03)},
  doi = {10.1145/949305.949312},
  keywords = {snf04 scg-pub jb04 stefPub},
  misc = {acceptance rate: 26/142 = 18\%},
  accepttotal = {142},
  acceptnum = {26},
  month = oct,
  pages = {65--77},
  title = {{OOPAL}: Integrating Array Programming in Object-Oriented Programming},
  url = {http://scg.unibe.ch/archive/papers/Moug03aOOPALOOPSLA.pdf},
  year = {2003},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Moug03aOOPALOOPSLA.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1145/949305.949312}
}

@misc{Mull05c,
  address = {Montego Bay, Jamaica},
  annote = {internationalworkshop},
  author = {Muller, Pierre-Alain and Fleurey, Franck and Vojtisek, Didier and Drey, Zo\'e and Pollet, Damien and Fondement, Fr\'ed\'eric and Studer, Philippe and J\'ez\'equel, Jean-Marc},
  howpublished = {Model Transformations In Practice Workshop},
  month = {oct},
  title = {On Executable Meta-Languages applied to Model Transformations},
  year = {2005}
}

@unpublished{Nebb97a,
  author = {R. Nebbe and T.D. Meijler and S. Demeyer and S. Ducasse and T. Richner},
  month = feb,
  note = {Esprit IV \#21975 FAMOOS Achievement A2.2.1},
  publisher = {University of Bern},
  title = {Formal Model for Basic Object-Oriented Software
                  Structures},
  year = {1997}
}

@inproceedings{Nier02a,
  abstract = {Component-based software development is becoming
                  mainstream for conventional applications. However,
                  components can be difficult to deploy in embedded
                  systems because of non-functional requirements.
                  Pecos is a collaborative project between industrial
                  and research partners that seeks to enable
                  component-based technology for a class of embedded
                  systems known as field devices. In this paper we
                  introduce a component model for field devices that
                  captures a range of non-functional properties and
                  constraints. We report on the current status of
                  Pecos, including the Pecos composition language,
                  language mappings to {Java} and C++, and industrial
                  case studies.},
  address = {Berlin, Germany},
  annote = {internationalconference},
  author = {Oscar Nierstrasz and Gabriela Ar{\'e}valo and St{\'e}phane Ducasse and Roel Wuyts and Andrew Black and Peter M{\"u}ller and Christian Zeidler and Thomas Genssler and Reinier van den Born},
  booktitle = {Proceedings First International IFIP/ACM Working Conference on Component Deployment},
  keywords = {scg-pub skip-doi jb02 pecos stefPub arevalo},
  month = jun,
  pages = {200--209},
  publisher = {ACM},
  title = {A Component Model for Field Devices},
  url = {http://scg.unibe.ch/archive/papers/Nier02aPecosModel.pdf},
  year = {2002},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Nier02aPecosModel.pdf}
}

@article{Nier04c,
  abstract = {Aging software systems are difficult and expensive
                  to maintain. Moose is a language-independent
                  environment that supports a wide range of tools to
                  visualise, analyse and manipulate complex software
                  systems.},
  annote = {notrefereed},
  author = {Oscar Nierstrasz and St\'ephane Ducasse},
  cvs = {ERCIM_ASE},
  journal = {European Research Consortium for Informatics and Mathematics (ERCIM) News},
  keywords = {scg-pub skip-doi jb04 stefPub recast04 moose-pub},
  month = jul,
  pages = {24--25},
  title = {Moose--a Language-Independent Reengineering Environment},
  url = {http://www.ercim.org/publication/Ercim_News/enw58/nierstrasz.html},
  volume = {58},
  year = {2004},
  bdsk-url-1 = {http://www.ercim.org/publication/Ercim_News/enw58/nierstrasz.html}
}

@inproceedings{Nier04d,
  abstract = {In this paper we briefly review various kinds of
                  software changes and the issues that arise from
                  them. As a consequence, we propose research into
                  programming languages with explicit support for
                  representing first-class changes, and for
                  manipulating and merging multiple viewpoints of
                  evolving software systems.},
  annote = {internationalworkshop},
  author = {Oscar Nierstrasz and Marcus Denker},
  booktitle = {OOPSLA Workshop on Revival of Dynamic Languages},
  cvs = {RDLchange},
  keywords = {snf05 scg-pub skip-doi jb05 fromscgbib marcusdenker},
  month = oct,
  title = {Supporting Software Change in the Programming Language},
  url = {http://rmod.lille.inria.fr/archives/workshops/Nier04d-RDL04-Change.pdf},
  year = {2004}
}

@inproceedings{Nier05b,
  abstract = {The programming languages of today are stuck in a
                  deep rut that has developed over the past 50 years.
                  Although we are faced with new challenges posed by
                  enormous advances in hardware and internet
                  technology, we continue to struggle with
                  old-fashioned languages based on rigid, static,
                  closed-world file-based views of programming. We
                  argue the need for a new class of dynamic languages
                  that support a view of programming as constant
                  evolution of living and open software models. Such
                  languages would require features such as dynamic
                  first-class namespaces, explicit meta-models,
                  optional, pluggable type systems, and incremental
                  compilation of running software systems.},
  aeres = {INV},
  annote = {invited},
  author = {Oscar Nierstrasz and Alexandre Bergel and Marcus
                  Denker and St\'ephane Ducasse and Markus Gaelli and
                  Roel Wuyts},
  booktitle = {Proceedings of Software Composition 2005},
  cvs = {SC05Revival},
  doi = {10.1007/11550679_1},
  editor = {Thomas Gschwind and Uwe A{\ss}mann},
  inria = {hors},
  isbn = {3-540-28748-5},
  keywords = {snf05 snf-actsc scg-pub jb06 gaelli fromscgbib},
  misc = {gaelli},
  note = {Invited paper},
  pages = {1--13},
  publisher = {LNCS 3628},
  title = {On the Revival of Dynamic Languages},
  url = {http://rmod.lille.inria.fr/archives/papers/Nier05b-SC05-Revival.pdf},
  volume = {3628},
  year = {2005}
}

@inproceedings{Nier05c,
  abstract = {Moose is a language-independent environment for
                  reverse- and re-engineering complex software
                  systems. Moose provides a set of services including
                  a common meta-model, metrics evaluation and
                  visualization, a model repository, and generic GUI
                  support for querying, browsing and grouping. The
                  development effort invested in Moose has paid off in
                  precisely those research activities that benefit
                  from applying a combination of complementary
                  techniques. We describe how Moose has evolved over
                  the years, we draw a number of lessons learned from
                  our experience, and we outline the present and
                  future of Moose.},
  address = {New York NY},
  aeres = {INV},
  aeresstatus = {aeres08},
  annote = {invited},
  author = {Oscar Nierstrasz and St\'ephane Ducasse and Tudor
                  G\^irba},
  booktitle = {Proceedings of the European Software Engineering
                  Conference (ESEC/FSE'05)},
  cvs = {MOOSE-ESEC05},
  doi = {10.1145/1095430.1081707},
  inria = {hors},
  isbn = {1-59593-014-0},
  keywords = {hasler07 girba stefPub recast06 scg-pub jb06
                  mooseCincom moose-pub snf-actsc snf-bmcc norex06},
  note = {Invited paper},
  pages = {1--10},
  publisher = {ACM Press},
  title = {The Story of {Moose}: an Agile Reengineering
                  Environment},
  url = {http://scg.unibe.ch/archive/papers/Nier05cStoryOfMoose.pdf},
  year = {2005},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Nier05cStoryOfMoose.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1145/1095430.1081707}
}

@inproceedings{Nier05d,
  abstract = {Successful software systems must be prepared to
                  evolve or they will die. Although object-oriented
                  software systems are built to last, over time they
                  degrade as much as any legacy software system. As a
                  consequence, one must invest in reengineering
                  efforts to keep further development costs down. Even
                  though software systems and their business contexts
                  may differ in countless ways, the techniques one
                  uses to understand, analyze and transform these
                  systems tend to be very similar. As a consequence,
                  one may identify various reengineering patterns that
                  capture best practice in reverse- and re-engineering
                  object-oriented legacy systems. We present a brief
                  outline of a large collection of these patterns that
                  have been mined over several years of experience
                  with object-oriented legacy systems, and we indicate
                  how some of these patterns can be supported by
                  appropriate tools.},
  aeres = {INV},
  aeresstatus = {aeres08},
  annote = {invited},
  author = {Oscar Nierstrasz and St\'ephane Ducasse and Serge
                  Demeyer},
  booktitle = {Proceedings of Generative Programming and Component
                  Engineering (GPCE 2005)},
  cvs = {GPCE05ReengPatterns},
  doi = {10.1007/11561347_1},
  editor = {Robert Gl\"uck, Michael Lowry},
  inria = {hors},
  isbn = {3-540-29138-5},
  keywords = {stefPub recast06 scg-pub jb06},
  note = {Invited paper},
  pages = {1--9},
  publisher = {LNCS 3676},
  title = {Object-oriented Reengineering Patterns --- an
                  Overview},
  url = {http://scg.unibe.ch/archive/papers/Nier05dReengineeringPatterns.pdf},
  year = {2005},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Nier05dReengineeringPatterns.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1007/11561347_1}
}

@techreport{Nier05e,
  abstract = {Traits are fine-grained components that can be used
                  to compose classes, while avoiding many of the
                  problems of multiple inheritance and mixin-based
                  approaches. Since most implementations of traits
                  have focused on dynamically-typed languages, the
                  question naturally arises, how can one best
                  introduce traits to statically-typed languages, like
                  {Java} and C#? In this paper we argue that the
                  flattening property of traits should be used as a
                  guiding principle for any attempt to add traits to
                  statically-typed languages. This property
                  essentially states that, semantically, traits can be
                  compiled away. We demonstrate how this principle
                  applies to FTJ, a conservative extension to
                  Featherweight {Java}.},
  address = {Universit\"at Bern, Switzerland},
  author = {Oscar Nierstrasz and St\'ephane Ducasse and
                  Nathanael Sch\"arli},
  cvs = {TraitFlatteningTR},
  institution = {Institut f\"ur Informatik},
  keywords = {scg-pub skip-doi scg-rotor traits jb06 snf05 jot
                  stefPub},
  month = apr,
  number = {IAM-05-005},
  title = {Flattening {Traits}},
  type = {Technical Report},
  url = {http://scg.unibe.ch/archive/papers/Nier05eFlatteningTraitsTR.pdf},
  year = {2005},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Nier05eFlatteningTraitsTR.pdf}
}

@article{Nier05f,
  abstract = {Erfolgreiche Softwaresysteme m\"ussen so konzipiert
                  sein, dass sie sich weiterentwickeln k\"onnen ---
                  ansonsten gehen sie ein. Obwohl objektorientierte
                  Softwaresysteme auf eine lange Lebensda\"ur
                  ausgerichtet sind, veralten sie \"uber die Jahre
                  genauso wie jedes andere Legacy-Softwaresystem. Um
                  die weiteren Entwicklungskosten niedrig zu halten,
                  m\"ussen daher Investitionen im Bereich \
                  Re-Engineering get\"atigt werden. Softwaresysteme
                  und der Gesch\"aftskontext, in dem sie eingesetzt
                  werden, unterscheiden sich in vielen Punkten ---
                  dennoch \"ahneln sich Techniken, sie zu verstehen,
                  zu analysieren und zu transformieren. Folglich
                  lassen sich verschiedene Re-Engineering-Muster
                  identifizieren, die bew\"ahrte Vorgehensweisen beim
                  Reverse- und Re-Engineering objektorientierter
                  Legacy-Systeme beinhalten. Dieser Artikel stellt
                  einen kleinen Ausschnitt aus einer gr\"on Sammlung
                  dieser Muster vor, die auf der mehrj\"ahrigen
                  Erfahrung mit objektorientierten Legacy-Systemen
                  basieren. Dar\"uber hinaus werden Hinweise gegeben,
                  wie einige dieser Muster durch geeignete Werkzeuge
                  unterst\"utzt werden k\"onnen.},
  aeres = {INV},
  aeresstatus = {aeres08},
  annote = {invited},
  author = {Oscar Nierstrasz and St\'ephane Ducasse and Serge
                  Demeyer},
  inria = {hors},
  journal = {ObjektSpektrum},
  keywords = {stefPub recast06 scg-pub skip-doi jb06},
  note = {German translation of ``Object-oriented
                  Reengineering Patterns --- an Overview'' (GPCE 05)},
  number = {6},
  pages = {46--51},
  title = {Objektorientierte Re-Engineering-Muster: ein
                  \"{U}berblick},
  url = {http://www.sigs-datacom.de/sd/publications/pub_article_show.htm?&AID=1713&TABLE=sd_article
                  http://www.sigs.de/publications/os/2005/06/demeyer_nierstrasz_OS_06_05.pdf
                  http://scg.unibe.ch/archive/papers/Nier05fOORM.pdf},
  volume = {2005},
  year = {2005},
  bdsk-url-1 = {http://www.sigs-datacom.de/sd/publications/pub_article_show.htm?&AID=1713&TABLE=sd_article%20http://www.sigs.de/publications/os/2005/06/demeyer_nierstrasz_OS_06_05.pdf%20http://scg.unibe.ch/archive/papers/Nier05fOORM.pdf}
}

@techreport{Nier05g,
  abstract = {Traits offer a fine-grained mechanism for composing
                  classes in object-oriented languages from reusable
                  components, while avoiding the fragility problems
                  introduced by multiple inheritance and mixins.
                  Although traits were developed in the context of
                  dynamically typed languages, they would also offer
                  clear benefits for statically typed languages like
                  Java and C\#. This report summarizes the issues
                  raised when integrating traits into such languages.
                  We examine traits in the context of the statically
                  typed languages FeatherweightJava, C\# and C++.},
  address = {Universit\"at Bern, Switzerland},
  author = {Oscar Nierstrasz and St\'ephane Ducasse and Stefan
                  Reichhart and Nathanael Sch\"arli},
  cvs = {TraitsCSharp},
  institution = {Institut f\"ur Informatik},
  keywords = {scg-pub skip-doi scg-rotor traits jb06 snf05
                  stefPub},
  month = dec,
  number = {IAM-05-006},
  title = {Adding {Traits} to (Statically Typed) Languages},
  type = {Technical Report},
  url = {http://scg.unibe.ch/archive/papers/Nier05gTraitsCSharp.pdf},
  year = {2005},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Nier05gTraitsCSharp.pdf}
}

@article{Nier06a,
  abstract = {Traits are fine-grained components that can be used
                  to compose classes, while avoiding many of the
                  problems of multiple inheritance and mixin-based
                  approaches. Since most implementations of traits
                  have focused on dynamically-typed languages, the
                  question naturally arises, how can one best
                  introduce traits to statically-typed languages, like
                  {Java} and C#? In this paper we argue that the
                  flattening property of traits should be used as a
                  guiding principle for any attempt to add traits to
                  statically-typed languages. This property
                  essentially states that, semantically, traits can be
                  compiled away. We demonstrate how this principle
                  applies to FTJ, a conservative extension to
                  Featherweight {Java}.},
  aeres = {ACL},
  aeresstatus = {aeres08},
  annote = {internationaljournal},
  author = {Oscar Nierstrasz and St\'ephane Ducasse and
                  Nathanael Sch\"arli},
  cached = {http://scg.unibe.ch/archive/papers/Nier06aFlatteningTraits.pdf},
  cvs = {TraitFlatteningJOT},
  inria = {hors},
  journal = {Journal of Object Technology},
  keywords = {scg-pub skip-doi scg-rotor traits jb06 fb06 snf05
                  snf06 jot stefPub},
  medium = {2},
  misc = {May-June},
  month = may,
  number = {4},
  pages = {129--148},
  peerreview = {yes},
  selectif = {non},
  title = {Flattening {Traits}},
  url = {http://www.jot.fm/issues/issue_2006_05/article4.pdf},
  volume = {5},
  year = {2006},
  bdsk-url-1 = {http://www.jot.fm/issues/issue_2006_05/article4.pdf}
}


@inproceedings{Nier06b,
  abstract = {Software systems need to continuously change to
                  remain useful. Change appears in several forms and
                  needs to be accommodated at different levels. We
                  propose ChangeBoxes as a mechanism to encapsulate,
                  manage, analyze and exploit changes to software
                  systems. Our thesis is that only by making change
                  explicit and manipulable can we enable the software
                  developer to manage software change more effectively
                  than is currently possible. Furthermore we argue
                  that we need new insights into assessing the impact
                  of changes and we need to provide new tools and
                  techniques to manage them. We report on the results
                  of some initial prototyping efforts, and we outline
                  a series of research activities that we have started
                  to explore the potential of ChangeBoxes.},
  annote = {internationalworkshop},
  author = {Oscar Nierstrasz and Marcus Denker and Tudor G{\^\i}rba and Adrian Lienhard},
  booktitle = {Proceedings of the Workshop on Revival of Dynamic Languages (co-located with ECOOP'06)},
  cvs = {RDL06ACTSC},
  keywords = {girba snf06 scg-pub skip-doi jb06 fb06 fromscgbib marcusdenker},
  medium = {2},
  month = jul,
  peerreview = {yes},
  title = {Analyzing, Capturing and Taming Software Change},
  url = {http://rmod.lille.inria.fr/archives//workshops/Nier06b-RDL06-ACTSC.pdf},
  year = {2006}
}

@techreport{Nier08a,
  abstract = {Few real software systems are built completely from
                  scratch nowadays. Instead, systems are built
                  iteratively and incrementally, while integrating and
                  interacting with components from many other systems.
                  These systems also last longer than their developers
                  might imagine --- they are, in effect, eternal.
                  Nevertheless the platforms, tools and environments
                  we use to develop software are still largely based
                  on an outmoded model that presupposes that software
                  systems are closed and will not significantly evolve
                  after deployment. We claim that in order to enable
                  effective and graceful evolution of eternal systems,
                  we must make them self-aware. A self-aware eternal
                  system supports evolution by: (i) providing
                  explicit, first-class models of software artifacts,
                  change and history at the level of the platform,
                  (ii) continuously analysing static and dynamic
                  evolution to track emergent properties, and (iii)
                  closing the gap between the domain model and the
                  developers' view of the evolving system. We outline
                  our vision of self-aware eternal systems and
                  identify the research challenges to realizing this
                  vision.},
  annote = {report notrefereed},
  author = {Oscar Nierstrasz and Marcus Denker and Tudor G\^irba
                  and Adrian Kuhn and Adrian Lienhard and David
                  R{\"o}thlisberger},
  institution = {University of Bern, Institute of Applied Mathematics
                  and Computer Sciences},
  keywords = {scg-pub jb08 snf08 skip-doi girba roethlisberger
                  akuhn fromscgbib marcusdenker},
  number = {IAM-08-001},
  title = {Self-aware, Evolving Eternal Systems},
  type = {Technical Report},
  url = {http://rmod.lille.inria.fr/archives/reports/Nier08a-TechReport-SelfAwareEternal.pdf},
  year = {2008}
}

@incollection{Nier08b,
  abstract = {Few real software systems are built completely from
                  scratch nowadays. Instead, systems are built
                  iteratively and incrementally, while integrating and
                  interacting with components from many other systems.
                  Adaptation, reconfiguration and evolution are
                  normal, ongoing processes throughout the lifecycle
                  of a software system. Nevertheless the platforms,
                  tools and environments we use to develop software
                  are still largely based on an outmoded model that
                  presupposes that software systems are closed and
                  will not significantly evolve after deployment. We
                  claim that in order to enable effective and graceful
                  evolution of modern software systems, we must make
                  these systems more amenable to change by (i)
                  providing explicit, first-class models of software
                  artifacts, change, and history at the level of the
                  platform, (ii) continuously analysing static and
                  dynamic evolution to track emergent properties, and
                  (iii) closing the gap between the domain model and
                  the developers' view of the evolving system. We
                  outline our vision of dynamic, evolving software
                  systems and identify the research challenges to
                  realizing this vision.},
  author = {Oscar Nierstrasz and Marcus Denker and Tudor G\^irba and Adrian Lienhard and David R\"othlisberger},
  booktitle = {Challenges for Software-Intensive Systems and New
                  Computing Paradigms},
  doi = {10.1007/978-3-540-89437-7_3},
  editor = {Martin Wirsing and Jean-Pierre Ban\^atre and
                  Matthias H\"olzl},
  isbn = {978-3-540-89436-0},
  keywords = {scg08 scg-pub snf09 jb09 hasler09 girba cop-lit roethlisberger marcusdenker fromscgbib},
  medium = {2},
  pages = {64-79},
  peerreview = {yes},
  publisher = {Springer-Verlag},
  series = {LNCS},
  title = {Change-Enabled Software Systems},
  url = {http://rmod.lille.inria.fr/archives/papers/Nier08b-bookchapter-ChangeEnabledSoftware.pdf},
  volume = {5380},
  year = {2008}
}

@incollection{Nier09a,
  abstract = {Software must be constantly adapted to changing
                  requirements. The time scale, abstraction level and
                  granularity of adaptations may vary from short-term,
                  fine-grained adaptation to long-term, coarse-grained
                  evolution. Fine-grained, dynamic and
                  context-dependent adaptations can be particularly
                  difficult to realize in long-lived, large-scale
                  software systems. We argue that, in order to
                  effectively and efficiently deploy such changes,
                  adaptive applications must be built on an
                  infrastructure that is not just model-driven, but is
                  both model-centric and context-aware. Specifically,
                  this means that high-level, causally-connected
                  models of the application and the software
                  infrastructure itself should be available at
                  run-time, and that changes may need to be scoped to
                  the run-time execution context. We first review the
                  dimensions of software adaptation and evolution, and
                  then we show how model-centric design can address
                  the adaptation needs of a variety of applications
                  that span these dimensions. We demonstrate through
                  concrete examples how model-centric and
                  context-aware designs work at the level of
                  application interface, programming language and
                  runtime. We then propose a research agenda for a
                  model-centric development environment that supports
                  dynamic software adaptation and evolution.},
  author = {Oscar Nierstrasz and Marcus Denker and Lukas
                  Renggli},
  booktitle = {Software Engineering for Self-Adaptive Systems},
  doi = {10.1007/978-3-642-02161-9_7},
  editor = {Betty H.C. Cheng and Rogerio de Lemos and Holger
                  Giese and Paola Inverardi and Jeff Magee},
  keywords = {scg09 scg-pub diesel helvetia reflectivity snf09
                  jb09 fromscgbib marcusdenker},
  medium = {2},
  pages = {128-145},
  peerreview = {yes},
  publisher = {Springer-Verlag},
  series = {LNCS},
  title = {Model-Centric, Context-Aware Software Adaptation},
  url = {http://rmod.lille.inria.fr/archives/papers/Nier09a-bookchapter-ModelCentric.pdf},
  volume = {5525},
  year = {2009}
}

@mastersthesis{Peirs08a,
  author = {Romain Peirs},
  title = {Enhanced Dependency Structure Matrix},
  year = {2008},
  abstract = {Dependency Structure Matrix (DSM) is an approach taken from
                  process optimization and it exists a variety of algorithms
                  to help organizing the matrix in a form that reflects the
                  architecture and highlights patterns and problematic
                  dependencies. However, the existing DSM implementations have
                  a lack of information in their visualization. That is why, we
                  enhanced DSM by adding written and colored information in the
                  visualization to improve the architecture understanding of a
                  software system and the support of its remodularization. This
                  visualization has been implemented on top of Moose which is a
                  collaborative research platform for Software Analysis and
                  Information Visualization. This report presents my
                  internship done at the research centre INRIA Lille - Nord
                  Europe with the RMoD Team led by S. Ducasse.},
  annote = {master cook},
  school = {Enseita}
}

@misc{Poll02a,
  address = {Malaga},
  annote = {internationalworkshop},
  author = {Pollet, Damien and Vojtisek, Didier and
                  J\'ez\'equel, Jean-Marc},
  howpublished = {Workshop on Integration and Transformation of UML
                  models (WITUML~2002)},
  month = jun,
  title = {OCL as a Core UML Transformation Language},
  url = {http://ctp.di.fct.unl.pt/~ja/wituml02.htm},
  year = {2002},
  bdsk-url-1 = {http://ctp.di.fct.unl.pt/~ja/wituml02.htm}
}

@phdthesis{Poll05a,
  annote = {phdthesis},
  author = {Pollet, Damien},
  month = jun,
  school = {Universit\'e de Rennes 1},
  title = {Une architecture pour les transformations de
                  mod\`eles et la restructuration de mod\`eles UML},
  url = {http://www.irisa.fr/bibli/publi/theses/2005/pollet/pollet.html},
  year = {2005},
  bdsk-url-1 = {http://www.irisa.fr/bibli/publi/theses/2005/pollet/pollet.html}
}



@inproceedings{Poll07a,
  abstract = {To maintain and understand large applications, it is
                  crucial to know their architecture. The first
                  problem is that unlike classes and packages,
                  architecture is not explicitly represented in the
                  code. The second problem is that successful
                  applications evolve over time, so their architecture
                  inevitably drifts. Reconstructing the architecture
                  and checking whether it is still valid is therefore
                  an important aid. While there is a plethora of
                  approaches and techniques supporting architecture
                  reconstruction, there is no comprehensive state of
                  the art and it is often difficult to compare the
                  approaches. This article presents a state of the art
                  on software architecture reconstruction approaches.},
  aeres = {ACT},
  aeresstatus = {aeres08},
  annote = {internationalconference},
  author = {Pollet, Damien and Ducasse, St\'ephane and Poyet,
                  Lo\"{\i}c and Alloui, Ilham and C\^impan, Sorana and
                  Verjus, Herv\'e},
  booktitle = {Proceedings of 11th European Conference on Software
                  Maintenance and Reengineering (CSMR'07)},
  editor = {Krikhaar, Ren\'e and Verhoef, Chris and Di Lucca,
                  Giuseppe},
  inria = {hors},
  keywords = {recast},
  location = {Amsterdam, the Netherlands},
  misc = {Acceptance rate: 38/132=29\%},
  accepttotal = {132},
  acceptnum = {38},
  month = mar,
  note = {Best Paper Award},
  publisher = {IEEE Computer Society},
  rate = {29%},
  selectif = {oui},
  title = {Towards A Process-Oriented Software Architecture Reconstruction Taxonomy},
  url = {http://scg.unibe.ch/archive/papers/Poll07a-CSMRSARTaxonomy.pdf},
  year = {2007},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Poll07a-CSMRSARTaxonomy.pdf}
}


@misc{PowerfullIdeas,
  aeres = {OV},
  annote = {notrefereed},
  author = {St\'ephane Ducasse and Alexandre Bergel and
                  Fran\c{c}ois Schnell and Noury Bouraqadi and Serge
                  Stinckwich},
  inria = {hors},
  keywords = {squeak etoy book powerfull ideas stefPub jb-none},
  note = {French translation of Powerful Ideas in the
                  Classroom by B.J. Allen-Conn and Kim Rose},
  selectif = {non},
  title = {Des idees puissantes dans la classe --- Utilisation
                  de Squeak pour l'amelioration de l'apprentissage des
                  mathematiques et des sciences (traduction de
                  Powerful Ideas in the Classroom)}
}

@inproceedings{Rama02a,
  author    = {Maria Fernanda N. Ramal and
               Ricardo de Moura Meneses and
               Nicolas Anquetil},
  title     = {A Disturbing Result on the Knowledge Used during Software
               Maintenance},
  booktitle = {9th Working Conference on Reverse Engineering (WCRE 2002)},
  year      = {2002},
  pages     = {277-},
  publisher = {IEEE Computer Society},
  isbn      = {0-7695-1799-4},
  annote = {internationalconference},
 aeres = {ACT},
 selectif = {oui},
 labo = {non},
 x-editorial-board = {yes},
 x-international-audience = {yes},
 x-pays = {BR}
}

@inproceedings{Ramo04a,
  author    = {Cristiane S. Ramos and
               K{\'a}thia Mar\c{c}al de Oliveira and
               Nicolas Anquetil},
  title     = {Legacy Software Evaluation Model for Outsourced Maintainer},
  booktitle = {8th European Conference on Software Maintenance and Reengineering
               (CSMR 2004)},
  publisher = {IEEE Computer Society},
  year      = {2004},
  isbn      = {0-7695-2107-X},
  pages     = {48-57},
  annote = {internationalconference},
 aeres = {ACT},
 selectif = {oui},
 labo = {non},
 x-editorial-board = {yes},
 x-international-audience = {yes},
 x-pays = {BR}
}

@misc{Rapi98a,
  abstract = {Type information is a crucial information to support
                  object-oriented reengineering. In a dynamically
                  typed language like Smalltalk standard static type
                  inference is a complex and heavily computational
                  task. In this paper, we report how we use message
                  passing control and compiler extension to support
                  dynamic inference type in Smalltalk.},
  annote = {internationalworkshop},
  author = {Pascal Rapicault and Mireille Blay-Fornarino and
                  St\'ephane Ducasse and Anne-Marie Dery},
  keywords = {scg-pub skip-doi olit famoos-papunr oobib snf98 jb98
                  stefPub},
  note = {Proceedings of the ECOOP '98 International Workshop
                  Experiences in Object-Oriented Reengineering,
                  abstract in Object-Oriented Technology (ECOOP '98
                  Workshop Reader forthcoming LNCS)},
  pages = {76--77},
  title = {Dynamic Type Inference to Support Object-Oriented
                  Reengineering in Smalltalk},
  url = {http://scg.unibe.ch/archive/famoos/Rapi98a/type.pdf},
  year = {1998},
  bdsk-url-1 = {http://scg.unibe.ch/archive/famoos/Rapi98a/type.pdf}
}

@inproceedings{Rati04a,
  abstract = {As systems evolve and their structure decays,
                  maintainers need accurate and automatic
                  identification of the design problems. Current
                  approaches for automatic detection of design
                  problems are not accurate enough because they
                  analyze only a single version of a system and
                  consequently they miss essential information as
                  design problems appear and evolve over time. Our
                  approach is to use the historical information of the
                  suspected flawed structure to increase the accuracy
                  of the automatic problem detection. Our means is to
                  define measurements which summarize how persistent
                  the problem was and how much maintenance effort was
                  spent on the suspected structure. We apply our
                  approach on a large scale case study and show how it
                  improves the accuracy of the detection of God
                  Classes and Data Classes, and additionally how it
                  adds valuable semantical information about the
                  evolution of flawed design structures.},
  address = {Los Alamitos CA},
  annote = {internationalconference},
  author = {Daniel Ra{\c t}iu and St\'ephane Ducasse and Tudor
                  G{\^\i}rba and Radu Marinescu},
  booktitle = {Proceedings of 8th European Conference on Software
                  Maintenance and Reengineering (CSMR'04)},
  keywords = {recast04 scg-pub skip-doi stefPub jb04 moose-pub
                  girba ratiu evolution},
  misc = {acceptance rate: 33/62 = 52\%},
  accepttotal = {62},
  acceptnum = {33},
  pages = {223--232},
  publisher = {IEEE Computer Society},
  title = {Using History Information to Improve Design Flaws
                  Detection},
  url = {http://scg.unibe.ch/archive/papers/Rati04aHistoryImproveFlawsDetection.pdf},
  year = {2004},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Rati04aHistoryImproveFlawsDetection.pdf}
}

@inproceedings{Raza09a,
  title = {Multiple Viewpoints Architecture Extraction},
  year = {2009},
  author = {Azadeh Razavizadeh and Sorana C\^impan and Herv\'e Verjus and St\'ephane Ducasse},
  booktitle = {Proceedings of the 2009 Joint Working IEEE/IFIP Conference on Software Architecture \& European Conference on Software Architectures},
  annote = {internationalconference},
  pages = {329--332},
  aeres = {ACT},
  aeresstatus = {aeres12},
  labo = {dans},
  keywords = {moose-pub lse-pub},
  inria = {RMOD},
  inriareport = {2009},
  x-editorial-board = {yes},
  x-proceedings = {yes},
  x-international-audience = {yes},
  url = {http://rmod.lille.inria.fr/archives/papers/Raza09a-WASECSA-MultipleViewPoints.pdf}
}

@inproceedings{Raza09b,
  title = {Software System Understanding via Architectural Views Extraction According to Multiple Viewpoints},
  year = {2009},
  author = {Azadeh Razavizadeh and Sorana C\^impan and Herv\'e Verjus and St\'ephane Ducasse},
  booktitle = {8th International Workshop on System/Software Architectures},
  annote = {internationalworkshop},
  aeres = {ACT},
  aeresstatus = {aeres12},
  keywords = {moose-pub lse-pub},
  inria = {RMOD},
  inriareport = {2009},
  labo = {hors},
  x-editorial-board = {yes},
  x-proceedings = {yes},
  x-international-audience = {yes},
  url = {http://rmod.lille.inria.fr/archives/workshops/Raza09b-iwssa-.pdf}
}

@inproceedings{Reic07a,
  abstract = {With the success of agile methodologies more and
                  more projects develop large test suites to ensure
                  that the system is behaving as expected. Not only do
                  tests ensure correctness, but they also offer a live
                  documentation for the code. However, as the system
                  evolves, the tests need to evolve as well to keep up
                  with the system, and as the test suite grows larger,
                  the effort invested into maintaining tests is a
                  significant activity. In this context, the quality
                  of tests becomes an important issue, as developers
                  need to assess and understand the tests they have to
                  maintain. In this paper we present TestLint, an
                  approach together with an experimental tool for
                  qualifying tests. We define a set of criteria to
                  determine test quality, and we evaluate our approach
                  on a large sample of unit tests found in open-source
                  projects.},
  aeres = {ACT},
  aeresstatus = {aeres08},
  annote = {internationalconference},
  author = {Stefan Reichhart and Tudor G\^irba and St\'ephane
                  Ducasse},
  booktitle = {Journal of Object Technology, Special Issue.
                  Proceedings of TOOLS Europe 2007},
  cached = {http://scg.unibe.ch/archive/papers/Reic07aTestQualityAssessment.pdf},
  inria = {hors},
  issn = {1660-1769},
  keywords = {scg07 scg-pub jb08 snf07 skip-doi testlint test
                  smell refactoring girba},
  medium = {2},
  month = oct,
  note = {Special Issue. Proceedings of TOOLS Europe 2007},
  pages = {231--251},
  peerreview = {yes},
  selectif = {non},
  title = {Rule-based Assessment of Test Quality},
  url = {http://www.jot.fm/issues/issue_2007_10/paper12/
                  http://www.jot.fm/issues/issue_2007_10/paper12.pdf},
  volume = {6/9},
  year = {2007},
  bdsk-url-1 = {http://www.jot.fm/issues/issue_2007_10/paper12/%20http://www.jot.fm/issues/issue_2007_10/paper12.pdf}
}

@inproceedings{Reng07a,
  abstract = {Model-driven engineering is a powerful approach to
                  build large-scale applications. However, an
                  application's metamodel often remains static after
                  the development phase and cannot be changed unless a
                  new development effort occurs. Yet, end users often
                  need to rapidly adapt their applications to new
                  business needs. In many cases, the end users would
                  know how to make the required adaptations, if only,
                  the application would let them do so. In this paper
                  we present how we built a runtime-dynamic
                  meta-environment by integrating Magritte, a
                  self-described metamodel, into Smalltalk's
                  reflective language model. Our solution offers the
                  best of both worlds: developers can develop their
                  applications using the same tools they were used to,
                  but at the same time they gain the power of
                  meta-programming. We show in particular that our
                  approach is adapted to support end user
                  customization of applications: the adaptive model of
                  Magritte enables to not only describe existing
                  classes, but also lets end users build their own
                  metamodels on the fly.},
  aeres = {ACT},
  aeresstatus = {aeres08},
  annote = {internationalconference},
  author = {Lukas Renggli and St\'ephane Ducasse and Adrian
                  Kuhn},
  booktitle = {Model Driven Engineering Languages and Systems},
  doi = {10.1007/978-3-540-75209-7_8},
  editor = {Gregor Engels and Bill Opdyke and Douglas C. Schmidt
                  and Frank Weil},
  inria = {hors},
  isbn = {978-3-540-75208-0},
  keywords = {scg07 scg-pub jb07 snf07 snf-bmcc akuhn fame},
  medium = {2},
  month = sep,
  pages = {106--120},
  peerreview = {yes},
  publisher = {Springer},
  ratex = {32%},
  series = {LNCS},
  title = {Magritte --- A Meta-Driven Approach to Empower
                  Developers and End Users},
  url = {http://scg.unibe.ch/archive/papers/Reng07aMagritte.pdf},
  volume = {4735},
  year = {2007},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Reng07aMagritte.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1007/978-3-540-75209-7_8}
}

@inproceedings{Reng09c,
  abstract = {As domain-specific modeling begins to attract
                  widespread acceptance, pressure is increasing for
                  the development of new domain-specific languages.
                  Unfortunately these DSLs typically conflict with the
                  grammar of the host language, making it difficult to
                  compose hybrid code except at the level of strings;
                  few mechanisms (if any) exist to control the scope
                  of usage of multiple DSLs; and, most seriously,
                  existing host language tools are typically unaware
                  of the DSL extensions, thus hampering the
                  development process. Language boxes address these
                  issues by offering a simple, modular mechanism to
                  encapsulate (i) compositional changes to the host
                  language, (ii) transformations to address various
                  concerns such as compilation and highlighting, and
                  (iii) scoping rules to control visibility of
                  language extensions. We describe the design and
                  implementation of language boxes, and show with the
                  help of several examples how modular extensions can
                  be introduced to a host language and environment.},
  annote = {internationalconference},
  author = {Lukas Renggli and Marcus Denker and Oscar Nierstrasz},
  booktitle = {Software Language Engineering: Second International Conference (SLE 2009)},
  doi = {10.1007/978-3-642-12107-4_20},
  isbn = {978-3-642-12106-7},
  keywords = {scg09 scg-pub snf10 jb10 helvetia fromscgbib marcusdenker remoose lse-pub},
  medium = {2},
  pages = {274--293},
  peerreview = {yes},
  inria = {RMOD},
  inriareport = {2010},
  publisher = {Springer},
  ratex = {29%},
  series = {LNCS},
  title = {Language Boxes: Bending the Host Language with Modular Language Changes},
  url = {http://rmod.lille.inria.fr/archives/papers/Reng09c-SLE09-LanguageBoxes.pdf},
  volume = {5969},
  year = {2009}
}

@inproceedings{Reng10b,
  abstract = {Lint-like program checkers are popular tools that
                  ensure code quality by verifying compliance with
                  best practices for a particular programming
                  language. The proliferation of internal
                  domain-specific languages and models, however, poses
                  new challenges for such tools. Traditional program
                  checkers produce many false positives and fail to
                  accurately check constraints, best practices, common
                  errors, possible optimizations and portability
                  issues particular to domain-specific languages. We
                  advocate the use of dedicated rules to check
                  domain-specific practices. We demonstrate the
                  implementation of domain-specific rules, the
                  automatic fixing of violations, and their
                  application to two case-studies: (1) Seaside defines
                  several internal DSLs through a creative use of the
                  syntax of the host language; and (2) Magritte adds
                  meta-descriptions to existing code by means of
                  special methods. Our empirical validation
                  demonstrates that domain-specific program checking
                  significantly improves code quality when compared
                  with general purpose program checking.},
  annote = {internationalconference},
  author = {Lukas Renggli and St\'ephane Ducasse and Tudor G\^irba and Oscar Nierstrasz},
  booktitle = {Proceedings of the 48th International Conference on Objects, Models, Components and Patterns (TOOLS'10)},
  keywords = {scg-pub helvetia girba snf10 jb10 remoose lse-pub},
  inria = {RMOD},
  inriareport = {2010},
  series = {LNCS},
  pages = {213--232},
  isnb = {978-3-642-13952-9},
  doi = {10.1007/978-3-642-13953-6\_12},
  publisher = {Springer-Verlag},
  volume = {6141},
  editor = {Jan Vitek},
  peerreview = {yes},
  ratex = {29%},
  title = {Domain-Specific Program Checking},
  url = {http://rmod.lille.inria.fr/archives/papers/Reng10b-DomainSpecificProgramChecking.pdf},
  hal-id = {inria-00531509},
  year = {2010},
  x-proceedings = {yes},
  x-international-audience = {yes}
}

@inproceedings{Reng10c,
  abstract = {Grammars for programming languages are traditionally
                  specified statically. They are hard to compose and
                  reuse due to ambiguities that inevitably arise.
                  PetitParser combines ideas from scannerless parsing,
                  parser combinators, parsing expression grammars and
                  packrat parsers to model grammars and parsers as
                  objects that can be reconfigured dynamically.
                  Through examples and benchmarks we demonstrate that
                  dynamic grammars are not only flexible but highly
                  practical.},
  author = {Lukas Renggli and St\'ephane Ducasse and Tudor
                  G\^irba and Oscar Nierstrasz},
  booktitle = {4th Workshop on Dynamic Languages and Applications (DYLA 2010)},
  title = {Practical Dynamic Grammars for Dynamic Languages},
  keywords = {scg-pub helvetia girba missing-doi moose-pub snf10 jb10 lse-pub},
  annote = {internationalworkshop},
  url = {http://scg.unibe.ch/archive/papers/Reng10cDynamicGrammars.pdf},
  month = jun,
  inria = {RMOD},
  inriareport = {2010},
  address = {Malaga, Spain},
  peerreview = {yes},
  year = {2010},
  x-proceedings = {no},
  x-international-audience = {yes}
}

@inproceedings{Rich02a,
  abstract = {Modeling object-oriented applications using
                  collaborations and roles is now well accepted.
                  Collaboration-based or role-based designs decompose
                  an application into tasks performed by a subset of
                  the applications' classes. Collaborations prov ide a
                  larger unit of understanding and reuse than classes,
                  and are an important aid in the maintenance and
                  evolution of the software. This kind of design
                  information is lost, however, at the implementation
                  level, making it hard to maintain and evolve an e
                  xisting software application. The extraction of
                  collaborations from code is therefore an important
                  issue in design recovery. In this paper we propose
                  an iterative approach which uses dynamic information
                  to support the recovery and understanding of collabo
                  rations. We describe a tool we have developed to
                  support our approach and demonstrate its use on a
                  case study.},
  address = {Los Alamitos CA},
  annote = {internationalconference},
  author = {Tamar Richner and St\'ephane Ducasse},
  booktitle = {Proceedings of 18th IEEE International Conference on
                  Software Maintenance (ICSM'02)},
  doi = {10.1109/ICSM.2002.1167745},
  keywords = {scg-pub snf02 jb02 stefPub},
  misc = {acceptance rate: 61/127 = 48\%},
  accepttotal = {127},
  acceptnum = {61},
  month = oct,
  pages = {34},
  publisher = {IEEE Computer Society},
  title = {Using Dynamic Information for the Iterative Recovery
                  of Collaborations and Roles},
  url = {http://scg.unibe.ch/archive/papers/Rich02aRolesExtractionICSM2002.pdf},
  year = {2002},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Rich02aRolesExtractionICSM2002.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1109/ICSM.2002.1167745}
}

@inproceedings{Rich98b,
  abstract = {Understanding how components in an application
                  interact to ensure a certain functionality is an
                  essential aspect of understanding a software
                  application. To obtain this kind of information an
                  analysis of the dynamic behavior of an application
                  is more appropriate than a static analysis of the
                  code. Understanding dynamic behavior through event
                  analysis is a challenge because of the large amount
                  of data gathered through program executions. In this
                  paper, we show how we define declarative queries
                  that allow us to filter the event data collected and
                  to define new abstractions which aid in program
                  understanding.},
  annote = {internationalworkshop},
  author = {Tamar Richner and St\'ephane Ducasse and Roel Wuyts},
  booktitle = {Object-Oriented Technology (ECOOP '98 Workshop
                  Reader)},
  editor = {Serge Demeyer and Jan Bosch},
  keywords = {olit famoos-papunr scglit oobib scg-pub skip-doi
                  toBeChecked snf98 jb98 stefPub},
  month = jul,
  publisher = {Springer-Verlag},
  series = {LNCS},
  title = {Understanding Object-Oriented Programs with
                  Declarative Event Analysis},
  url = {http://scg.unibe.ch/archive/papers/Rich98bEvents.pdf},
  volume = {1543},
  year = {1998},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Rich98bEvents.pdf}
}


@inproceedings{Rich99a,
  abstract = {Recovering architectural documentation from code is
                  crucial to maintaining and reengineering software
                  systems. Reverse engineering and program
                  understanding approaches are often limited by the
                  fact that (1) they propose a fixed set of predefined
                  views and (2) they consider either purely static or
                  purely dynamic views of the application. In this
                  paper we present an environment supporting the
                  generation of tailorable views of object-oriented
                  systems from both static and dynamic information.
                  Our approach is based on the combination of
                  user-defined queries which allow an engineer to
                  create high-level abstractions and to produce views
                  using these abstractions.},
  address = {Los Alamitos CA},
  annote = {internationalconference},
  author = {Tamar Richner and St\'ephane Ducasse},
  booktitle = {Proceedings of 15th IEEE International Conference on
                  Software Maintenance (ICSM'99)},
  doi = {10.1109/ICSM.1999.792487},
  editor = {Hongji Yang and Lee White},
  keywords = {olit famoos-papref scg-pub toBeChecked snf99 jb99
                  oorp stefPub},
  misc = {acceptance rate: 49/100 = 49\%},
  accepttotal = {100},
  acceptnum = {49},
  month = sep,
  pages = {13--22},
  publisher = {IEEE Computer Society Press},
  title = {Recovering High-Level Views of Object-Oriented
                  Applications from Static and Dynamic Information},
  url = {http://scg.unibe.ch/archive/papers/Rich99aRecoveringViews.pdf},
  year = {1999},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Rich99aRecoveringViews.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1109/ICSM.1999.792487}
}

@inproceedings{Rieg04b,
  abstract = {Duplication of code is a common phenomenon in the
                  development and maintenance of large software
                  systems. The detection and removal of duplicated
                  code has become a standard activity during the
                  refactoring phases of a software life-cycle.
                  However, code duplication identification ends to
                  produce large amounts of data making the
                  understanding of the duplication situation as a
                  whole difficult. Reengineers can easily lose sight
                  of the forest for the trees. There is a need to
                  support a qualitative analysis of the duplicated
                  code. In this paper we propose a number of
                  visualzations of duplicated source elements that
                  support reengineers in answering questions, e.g.,
                  which parts of the sysem are connected by copied
                  code or which parts of the sysem are copied the
                  most.},
  annote = {internationalconference},
  author = {Matthias Rieger and St\'ephane Ducasse and Michele
                  Lanza},
  booktitle = {Proceedings of 11th Working Conference on Reverse
                  Engineering (WCRE'04)},
  cvs = {DuplocVizPaper},
  doi = {10.1109/WCRE.2004.25},
  keywords = {olit scg-pub jb05 recast05 stefPub clones},
  location = {Delft, The Netherlands},
  misc = {acceptance rate: 28/78 = 36\%},
  accepttotal = {78},
  acceptnum = {28},
  month = nov,
  pages = {100--109},
  publisher = {IEEE Computer Society Press},
  title = {Insights into System-Wide Code Duplication},
  url = {http://scg.unibe.ch/archive/papers/Rieg04bWCRE2004ClonesVisualization.pdf},
  year = {2004},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Rieg04bWCRE2004ClonesVisualization.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1109/WCRE.2004.25}
}

@inproceedings{Rieg98a,
  abstract = {Code duplication is considered as bad practice that
                  complicates the maintenance and evolution of
                  software. Detecting duplicated code is a difficult
                  task because of the large amount of data to be
                  checked and the fact that a priori it is unknown
                  which code part has been duplicated. In this paper,
                  we present a tool called DUPLOC that supports code
                  duplication detection in a visual and exploratory or
                  an automatic way.},
  annote = {internationalworkshop},
  author = {Matthias Rieger and St\'ephane Ducasse},
  booktitle = {Proceedings ECOOP Workshop on Experiences in Object-Oriented Re-Engineering},
  editor = {St\'ephane Ducasse and Joachim Weisbrod},
  keywords = {jb98 famoos-papunr snf98 scg-pub skip-doi},
  number = {6/7/98},
  publisher = {Forschungszentrum Informatik Karlsruhe},
  series = {FZI Report},
  title = {Visual Detection of Duplicated Code},
  url = {http://scg.unibe.ch/archive/papers/Rieg98aEcoopWorkshop.pdf},
  year = {1998}
}

@inproceedings{Rieg98b,
  abstract = {Code duplication is considered as bad practice that
                  complicates the maintenance and evolution of
                  software. Detecting duplicated code is a difficult
                  task because of the large amount of data to be
                  checked and the fact that a priori it is unknown
                  which code part has been duplicated. In this paper,
                  we present a tool called DUPLOC that supports code
                  duplication detection in a visual and exploratory or
                  an automatic way.},
  annote = {internationalworkshop},
  author = {Matthias Rieger and St\'ephane Ducasse},
  booktitle = {Object-Oriented Technology (ECOOP '98 Workshop Reader)},
  editor = {Serge Demeyer and Jan Bosch},
  keywords = {olit famoos-papunr reveng scg-pub skip-doi jb-none  stefPub},
  month = jul,
  pages = {75--76},
  publisher = {Springer-Verlag},
  series = {LNCS},
  title = {Visual Detection of Duplicated Code},
  url = {http://scg.unibe.ch/archive/papers/Rieg98aEcoopWorkshop.pdf},
  volume = {1543},
  year = {1998}
}

@inproceedings{Rieg99a,
  abstract = {Code duplication is an important problem in
                  application maintenance. Tools exist that support
                  code duplication detection. However, few of them
                  propose a solution for the problem, i.e.
                  refactorings. We propose an approach that uses the
                  information given by code duplication detection to
                  guide the refactorings of OO applications.},
  annote = {internationalworkshop},
  author = {Matthias Rieger and St\'ephane Ducasse and Georges Golomingi},
  booktitle = {Object-Oriented Technology (ECOOP '99 Workshop Reader)},
  keywords = {olit scg-pub skip-doi jb-none},
  number = {1743},
  publisher = {Springer-Verlag},
  series = {LNCS},
  title = {Tool Support for Refactoring Duplicated OO Code},
  url = {http://scg.unibe.ch/archive/papers/Rieg99aToolSuppRefacOOCode.pdf},
  year = {1999}
}

@inproceedings{Robb05b,
  abstract = {Understanding classes and methods is a key activity
                  in object-oriented programming, since classes
                  represent the primary abstractions from which
                  applications are built, while methods contain the
                  actual program logic. The main problem of this task
                  is to quickly grasp the purpose and inner structure
                  of a class. To achieve this goal, one must be able
                  to overview multiple methods at once. In this paper,
                  we present microprints, pixel-based representations
                  of methods enriched with semantical information. We
                  present three specialized microprints each dealing
                  with a specific aspect we want to understand of
                  methods: (1) state access, (2) control flow, and (3)
                  invocation relationship. We present the microprints
                  in conjunction with the class blueprints of the CODE
                  CRAWLER visualization tool [12] and also integrated
                  into the default code browser of the Smalltalk
                  VisualWorks development environment.},
  aeres = {ACT},
  aeresstatus = {aeres08},
  annote = {internationalconference},
  author = {Romain Robbes and St\'ephane Ducasse and Michele Lanza},
  booktitle = {Proceedings of 13th International Smalltalk Conference (ISC'05)},
  inria = {hors},
  keywords = {scg-pub skip-doi stefPub snf05 jb06 listic},
  pages = {131--157},
  selectif = {non},
  title = {Microprints: A Pixel-based Semantically Rich Visualization of Methods},
  url = {http://scg.unibe.ch/archive/papers/Robb05b-microprintsESUG.pdf},
  year = {2005}
}

@inproceedings{Robb10a,
  author = {Robbes, Romain and Pollet, Damien and Lanza, Michele},
  title = {Replaying IDE Interactions to Evaluate and Improve Change Prediction Approaches},
  editor = {Whitehead, Jim and Zimmermann, Thomas},
  booktitle = {7th IEEE Working Conference on Mining Software Repositories (MSR)},
  pages = {161--170},
  publisher = {IEEE Computer Society},
  month = may,
  year = {2010},
  misc = {Acceptance rate: 16/51 = 31.4\%},
  isbn = {978-1-4244-6803-4},
  doi = {10.1109/MSR.2010.5463278},
  abstract = {
    Change prediction helps developers by recommending program entities that will have to be changed alongside the entities currently
    being changed. To evaluate their accuracy, current change prediction approaches use data from versioning systems such as CVS or SVN.
    These data sources provide a coarse-grained view of the development history that flattens the sequence of changes in a single commit.
    They are thus not a valid basis for evaluation in the case of developmentstyle prediction, where the order of the predictions has to
    match the order of the changes a developer makes.
    We propose a benchmark for the evaluation of change prediction approaches based on fine-grained change data recorded from IDE usage.
    Moreover, the change prediction approaches themselves can use the more accurate data to fine-tune their prediction. We present an
    evaluation procedure and use it on several change prediction approaches, both novel and from the literature, and report on the
    results.},
  keywords = {lse-pub},
  annote = {internationalconference},
  hal = {inria-00531788},
  inria = {RMOD},
  inriareport  = {2010},
  selectif = {non},
  labo = {hors},
  TODO-impactfactor = {},
  rate = {31.4\%},
  x-editorial-board = {yes},
	x-proceedings = {yes},
	x-international-audience = {yes},
  x-pays = {CL,CH},
  aeres = {aeres12},
  aeresstatus = {ACT}
}

@inproceedings{Roet07b,
  abstract = {Dynamic, unanticipated adaptation of running systems
                  is of interest in a variety of situations, ranging
                  from functional upgrades to on-the-fly debugging or
                  monitoring of critical applications. In this paper
                  we study a particular form of computational
                  reflection, called unanticipated partial behavioral
                  reflection, which is particularly well-suited for
                  unanticipated adaptation of real-world systems. Our
                  proposal combines the dynamicity of unanticipated
                  reflection, i.e., reflection that does not require
                  preparation of the code of any sort, and the
                  selectivity and efficiency of partial behavioral
                  reflection. First, we propose unanticipated partial
                  behavioral reflection which enables the developer to
                  precisely select the required reifications, to
                  flexibly engineer the metalevel and to introduce the
                  meta behavior dynamically. Second, we present a
                  system supporting unanticipated partial behavioral
                  reflection in Squeak Smalltalk, called Geppetto, and
                  illustrate its use with a concrete example of a
                  Seaside web application. Benchmarks validate the
                  applicability of our proposal as an extension to the
                  standard reflective abilities of Smalltalk.},
  annote = {internationalconference},
  author = {David R{\"o}thlisberger and Marcus Denker and
                  {\'E}ric Tanter},
  booktitle = {Advances in Smalltalk --- Proceedings of 14th
                  International Smalltalk Conference (ISC 2006)},
  doi = {10.1007/978-3-540-71836-9\_3},
  isbn = {978-3-540-71835-2},
  issn = {0302-9743},
  keywords = {scg07 scg-pub jb07 snf06 roethlisberger
                  reflectivity marcusdenker fromscgbib},
  medium = {2},
  pages = {47--65},
  peerreview = {yes},
  publisher = {Springer},
  series = {LNCS},
  title = {Unanticipated Partial Behavioral Reflection},
  url = {http://rmod.lille.inria.fr/archives/papers/Roet07b-ISC06-UPBReflection.pdf},
  volume = {4406},
  year = {2007}
}

@article{Roet08a,
  abstract = {Dynamic, unanticipated adaptation of running systems
                  is of interest in a variety of situations, ranging
                  from functional upgrades to on-the-fly debugging or
                  monitoring of critical applications. In this paper
                  we study a particular form of computational
                  reflection, called unanticipated partial behavioral
                  reflection, which is particularly well-suited for
                  unanticipated adaptation of real-world systems. Our
                  proposal combines the dynamicity of unanticipated
                  reflection, i.e. reflection that does not require
                  preparation of the code of any sort, and the
                  selectivity and efficiency of partial behavioral
                  reflection. First, we propose unanticipated partial
                  behavioral reflection which enables the developer to
                  precisely select the required reifications, to
                  flexibly engineer the metalevel and to introduce the
                  meta behavior dynamically. Second, we present a
                  system supporting unanticipated partial behavioral
                  reflection in Squeak Smalltalk, called Geppetto, and
                  illustrate its use with a concrete example of a web
                  application. Benchmarks validate the applicability
                  of our proposal as an extension to the standard
                  reflective abilities of Smalltalk.},
  annote = {internationaljournal},
  author = {David R{\"o}thlisberger and Marcus Denker and
                  {\'E}ric Tanter},
  doi = {10.1016/j.cl.2007.05.001},
  journal = {Journal of Computer Languages, Systems and Structures},
  keywords = {scg08 scg08 scg-pub jb08 snf08 roethlisberger reflectivity marcusdenker fromscgbib},
  medium = {2},
  month = jul,
  number = {2-3},
  pages = {46--65},
  peerreview = {yes},
  publisher = {Elsevier},
  impactfactor = {5 Year ISI impact factor 0.698 (2010)},
  misc = {5 Year ISI impact factor 0.698 (2010)},
  title = {Unanticipated Partial Behavioral Reflection:
                  Adapting Applications at Runtime},
  url = {http://rmod.lille.inria.fr/archives/papers/Roet08a-COMLAN-UPBReflectionJournal.pdf},
  volume = {34},
  year = {2008}
}

@inproceedings{Roet09a,
  author = {David R\"{o}thlisberger and Oscar Nierstrasz and St\'ephane Ducasse and Damien Pollet and Romain Robbes},
  keywords = {scg-pub snf09 jb09 roethlisberger},
  annote = {internationalconference},
  title = {Supporting Task-oriented Navigation in {IDEs} with Configurable HeatMaps},
  abstract = {Mainstream IDEs generally rely on the static structure of a
  		software project to support browsing and navigation.
		We propose HeatMaps, a simple but highly configurable technique
		to enrich the way an IDE displays the static structure of a software
		system with additional kinds of information.
		A heatmap highlights software artifacts according to various metric values,
		such as bright red or pale blue, to indicate their potential degree of interest.
		We present a prototype system that implements heatmaps, and we describe
		an initial study that assesses the degree to which different heatmaps effectively
		guide developers in navigating software.},
  peer = {yes},
  booktitle = {Proceedings of the 17th International Conference on Program Comprehension (ICPC 2009)},
  publisher = {IEEE Computer Society},
  address = {Los Alamitos, CA, USA},
  pages = {253--257},
  isbn = {978-0-7695-3176-2},
  doi = {10.1109/ICPC.2008.32},
  url = {http://rmod.lille.inria.fr/archives/papers/Roet09a-ICPC2009-HeatMaps.pdf},
  year = {2009},
  inria = {RMOD},
  inriareport = {2009},
  labo = {dans},
  x-pays = {CH},
  x-editorial-board = {yes},
  x-proceedings = {yes},
  x-international-audience = {yes},
  hal-id = {inria-00498454 /}
}

@techreport{Roet09d,
  abstract = {Mainstream IDEs generally rely on the static structure of a
  		software project to support browsing and navigation.
		We propose HeatMaps, a simple but highly configurable technique
		to enrich the way an IDE displays the static structure of a software
		system with additional kinds of information.
		A heatmap highlights software artifacts according to various metric values,
		such as bright red or pale blue, to indicate their potential degree of interest.
		We present a prototype system that implements heatmaps, and we describe
		an initial study that assesses the degree to which different heatmaps effectively
		guide developers in navigating software.},
  address = {Universit\"at Bern, Switzerland},
  author = {David R\"{o}thlisberger and Oscar Nierstrasz and St\'ephane Ducasse and Damien Pollet and Romain Robbes},
  classification = {D.2.2 Tools and Techniques; D.2.3  Coding; D.2.6 Programming Environments; D.2.9 Management},
  general_terms = {Coding, Programming Environments, Program Editors, Integrated Environments},
  institution = {Institut f\"ur Informatik},
  keywords = {scg-pub snf09 jb09 roethlisberger},
  month = jul,
  number = {IAM-09-005},
  annote = {technicalreport},
  title = {Supporting Task-oriented Navigation in {IDEs} with Configurable HeatMaps},
  type = {Technical Report},
  url = {http://rmod.lille.inria.fr/archives/reports/Roet09d-TechReport-HeatMaps.pdf},
  year = {2009},
  x-pays = {CH},
  x-editorial-board = {no},
  x-proceedings = {no},
  x-international-audience = {yes}
}

@inproceedings{Roet09e,
  title = {Tackling Software Navigation Issues of the Smalltalk IDE},
  abstract = {The IDE used in most Smalltalk dialects such as Pharo, Squeak or Cincom Smalltalk did not evolve
  			significantly over the last years, if not to say decades. For other languages, for instance Java, the
			available IDEs made tremendous progress as Eclipse or NetBeans illustrate. While the Smalltalk
			IDE served as an exemplar for many years, other IDEs caught up or even overtook the erstwhile
			leader in terms of feature-richness, usability, or code navigation facilities.
			In this paper we first analyze the difficulty of software navigation in the Smalltalk IDE and second
			illustrate with concrete examples the features we added to the Smalltalk IDE to fill the gap to
			modern IDEs and to provide novel, improved means to navigate source space. We show that
			thanks to the agility and dynamics of Smalltalk, we are able to extend and enhance with reasonable
			effort the Smalltalk IDE to better support software navigation, program comprehension, and software
			maintenance in general. One such support is the integration of dynamic information into the static
			source views we are familiar with. Other means include easing the access to static information
			(for instance by better arranging important packages) or helping developers re-locating artifacts
			of interest (for example with a categorization system such as smart groups).},
  annote = {internationalworkshop},
  author = {David R\"{o}thlisberger and Oscar Nierstrasz and St\'ephane Ducasse and Alexandre Bergel},
  booktitle = {Proceedings of International Workshop on Smalltalk Technologies (IWST 2009)},
  peer = {yes},
  keywords = {scg-sub jb10 roethlisberger remoose2-pub},
  location = {Brest, France},
  publisher = {ACM Digital Library},
  year = {2009},
  aeres = {ACT},
  aeresstatus = {aeres12},
  selectif = {non},
  labo = {dans},
  inria = {RMOD},
  inriareport = {2009},
  x-editorial-board = {yes},
  x-proceedings = {yes},
  x-international-audience = {yes},
  x-pays = {CH},
  url = {http://rmod.lille.inria.fr/archives/workshops/Roet09e-IWST2009-obEnhancements.pdf}
}

@inproceedings{Roet09f,
  author = {David R\"{o}thlisberger and Oscar Nierstrasz and St\'ephane Ducasse},
  keywords = {snf09 jb10 roethlisberger remoose2-pub},
  annote = {internationalconference},
  title = {Autumn Leaves: Curing the Window Plague in IDEs},
  abstract = {Navigating large software systems is difficult as the various artifacts are distributed in a huge space, while the relationships between different artifacts often remain hidden and obscure. As a consequence, developers using a modern interactive development environment (IDE) are forced to open views on numerous source artifacts to reveal these hidden relationships, leading to a crowded workspace with many opened windows or tabs. Developers often lose the overview in such a cluttered workspace as IDEs provide little support to get rid of unused windows. AutumnLeaves automatically selects windows unlikely for future use to be closed or grayed out while important ones are displayed more prominently. This reduces the number of windows opened at a time and adds structure to the developer's workspace. We validate AutumnLeaves with a benchmark evaluation using recorded navigation data of various developers to determine the prediction quality of the employed algorithms.},
  peer = {yes},
  booktitle = {Proceedings of the 16th Working Conference on Reverse Engineering (WCRE 2009)},
  publisher = {IEEE Computer Society},
  address = {Los Alamitos, CA, USA},
  aeres = {ACT},
  misc = {Acceptance rate: 20/79 = 25\%},
  rate = {25\%},
  aeresstatus = {aeres12},
  selectif = {non},
  inria = {RMOD},
  labo = {dans},
  location = {Lille, France},
  year = {2009},
  inriareport = {2009},
  x-editorial-board = {yes},
  x-proceedings = {yes},
  x-international-audience = {yes},
  x-pays = {CH},
  url = {http://rmod.lille.inria.fr/archives/papers/Roet09f-WCRE2009-AutumnLeaves-ieee.pdf}
}

@article{Sade02a,
  abstract = {The concept of interfaces is central to
                  object-oriented methodologies and is one of the most
                  attractive features of {Java} and COM. Although
                  Smalltalk always had interfaces implicitly, in
                  Smalltalk interfaces are not first-class objects: t
                  hey cannot be conversed with, referred to, or
                  reflected upon. Consequently, Smalltalkers have been
                  deprived of such an important and useful tool. Since
                  a fundamental feature of Smalltalk is that just
                  about everything in the language is an
                  implementation feature, explicit, static interfaces
                  can be added to Smalltalk using Smalltalk itself
                  with ease. However, such an addition would
                  short-change the powerful dynamic aspects of
                  Smalltalk. In this article we present
                  SmallInterfaces; a new ontology of dynamic i
                  nterfaces which makes a powerful use of the dynamic
                  nature of Smalltalk. SmallInterfaces adds interfaces
                  as honorary members to Smalltalk's extensive
                  reflection mechanism, in a manner portable across
                  the many Smalltalk variants},
  annote = {internationaljournal},
  author = {Benny Sadeh and St\'ephane Ducasse},
  journal = {Journal of Object Technology},
  keywords = {scg-pub skip-doi jb02 snf02 stefPub},
  number = {1},
  title = {Adding Dynamic Interfaces to {Smalltalk}},
  url = {http://scg.unibe.ch/archive/papers/Sade02aDynamicInterfaces.pdf},
  volume = {1},
  year = {2002},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Sade02aDynamicInterfaces.pdf}
}

@inproceedings{Scha02a,
  abstract = {We present a simple, component-based model of
                  mixins, called traits, and argue that this simple
                  model sidesteps many of the practical problems with
                  other approaches to mixins and multiple inheritance.
                  With our model, classes are built from a set of
                  traits by specifying glue code that connects them
                  together and accesses the necessary state. We
                  briefly discuss practical experience with an
                  implementation of traits for Squeak, and we list a
                  number of open questions for discussion.},
  annote = {internationalworkshop},
  author = {Nathanael Sch{\"a}rli and St\'ephane Ducasse and
                  Oscar Nierstrasz},
  booktitle = {Proceedings of the International Workshop on
                  Inheritance},
  keywords = {scg-pub skip-doi scg-traits jb02 snf02 stefPub
                  schaerli},
  title = {Classes = Traits + States + Glue (Beyond mixins and
                  multiple inheritance)},
  url = {http://scg.unibe.ch/archive/papers/Scha02aTraitsPlusGlue2002.pdf},
  year = {2002},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Scha02aTraitsPlusGlue2002.pdf}
}



@techreport{Scha02b,
  abstract = {Inheritance is the fundamental reuse mechanism in
                  object-oriented programming languages; its most
                  prominent variants are single inheritance, multiple
                  inheritance, and mixin inheritance. In the first
                  part of this paper, we identify and illustrate the
                  conceptual and practical reusability problems that
                  arise with these forms of inheritance. We then
                  present a simple compositional model for structuring
                  object-oriented programs, which we call traits.
                  Traits are essentially groups of methods that serve
                  as building blocks for classes and are primitive
                  units of code reuse. In this model, classes are
                  composed from a set of traits by specifying glue
                  code that connects the traits together and accesses
                  the necessary state. We demonstrate how traits
                  overcome the problems arising with the different
                  variants of inheritance, we discuss how traits can
                  be implemented effectively, and we summarize our
                  experience applying traits to refactor an existing
                  class hierarchy.},
  address = {Universit\"at Bern, Switzerland},
  annote = {report notrefereed},
  author = {Nathanael Sch\"arli and St\'ephane Ducasse and Oscar
                  Nierstrasz and Andrew P. Black},
  classification = {D.1.5 Object-oriented Programming; D.3.3 Language
                  Constructs and Features},
  cvs = {TraitsECOOP},
  general_terms = {Inheritance, Mixins, Multiple Inheritance, Traits,
                  Reuse, Smalltalk},
  institution = {Institut f\"ur Informatik},
  keywords = {snf-redundant scg-pub skip-doi jb02 scg-traits
                  stefPub schaerli},
  month = nov,
  note = {Also available as Technical Report CSE-02-014, OGI
                  School of Science \& Engineering, Beaverton, Oregon,
                  USA},
  number = {IAM-02-005},
  title = {Traits: Composable Units of Behavior},
  type = {Technical Report},
  url = {http://scg.unibe.ch/archive/papers/Scha02bTraits.pdf},
  year = {2002},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Scha02bTraits.pdf}
}


@techreport{Scha02c,
  abstract = {Single-inheritance in object-oriented languages can
                  lead to duplicated code in rich class libraries
                  where feature-sharing cannot be linearized.
                  Multiple-inheritance and mixins alleviate this
                  problem, but lead to other difficulties in the face
                  of evolution. Changes to classes or mixins can break
                  code lower in the hierarchy in unexpected ways.
                  Traits solve both problems by factoring out shared
                  behaviour as sets of methods that do not depend on
                  state. Traits have the important property that
                  composition is symmetric, so changes do not lead to
                  unexpected side effects. We present a formal model
                  of traits, and define some basic properties of
                  traits and classes.},
  address = {Universit\"at Bern, Switzerland},
  annote = {notrefereed},
  author = {Nathanael Sch\"arli and Oscar Nierstrasz and
                  St\'ephane Ducasse and Roel Wuyts and Andrew Black},
  classification = {D.3.1 Formal Definitions and Theory; D.1.5
                  Object-oriented Programming; D.3.3 Language
                  Constructs and Features},
  cvs = {TraitsECOOP},
  general_terms = {Inheritance, Mixins, Multiple Inheritance, Traits,
                  Reuse, Smalltalk},
  institution = {Institut f\"ur Informatik},
  keywords = {snf03 scg-pub skip-doi jb02 scg-traits schaerli},
  month = nov,
  note = {Also available as Technical Report CSE-02-013, OGI
                  School of Science \& Engineering, Beaverton, Oregon,
                  USA},
  number = {IAM-02-006},
  title = {Traits: The Formal Model},
  type = {Technical Report},
  url = {http://scg.unibe.ch/archive/papers/Scha02cTraitsModel.pdf},
  year = {2002},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Scha02cTraitsModel.pdf}
}

@inproceedings{Scha03a,
  abstract = {Despite the undisputed prominence of inheritance as
                  the fundamental reuse mechanism in object-oriented
                  programming languages, the main variants --- single
                  inheritance, multiple inheritance, and mixin
                  inheritance --- all suffer from conceptual and
                  practical problems. In the first part of this paper,
                  we identify and illustrate these problems. We then
                  present traits, a simple compositional model for
                  structuring object-oriented programs. A trait is
                  essentially a group of pure methods that serves as a
                  building block for classes and is a primitive unit
                  of code reuse. In this model, classes are composed
                  from a set of traits by specifying glue code that
                  connects the traits together and accesses the
                  necessary state. We demonstrate how traits overcome
                  the problems arising from the different variants of
                  inheritance, we discuss how traits can be
                  implemented effectively, and we summarize our
                  experience applying traits to refactor an existing
                  class hierarchy.},
  annote = {internationalconference topconference},
  author = {Nathanael Sch\"arli and St\'ephane Ducasse and Oscar
                  Nierstrasz and Andrew P. Black},
  booktitle = {Proceedings of European Conference on
                  Object-Oriented Programming (ECOOP'03)},
  cvs = {TraitsECOOP2003},
  doi = {10.1007/b11832},
  isbn = {978-3-540-40531-3},
  keywords = {snf03 scg-pub jb03 scg-traits stefPub schaerli},
  misc = {acceptance rate: 18/88 = 20\%},
  accepttotal = {88},
  acceptnum = {18},
  month = jul,
  pages = {248--274},
  publisher = {Springer Verlag},
  series = {LNCS},
  title = {Traits: Composable Units of Behavior},
  url = {http://scg.unibe.ch/archive/papers/Scha03aTraits.pdf},
  volume = {2743},
  year = {2003},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Scha03aTraits.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1007/b11832}
}

@inproceedings{Scha04a,
  abstract = {Given the importance of encapsulation to
                  object-oriented programming, it is surprising to
                  note that mainstream object-oriented languages offer
                  only limited and fixed ways of encapsulating
                  methods. Typically one may only address two
                  categories of clients, users and heirs, and one must
                  bind visibility and access rights at an early stage.
                  This can lead to inflexible and fragile code as well
                  as clumsy workarounds. We propose a simple and
                  general solution to this problem in which
                  encapsulation policies can be specified separately
                  from implementations. As such they become
                  first-class composable entities that can be reused
                  by different classes. We present a detailed analysis
                  of the problem with encapsulation and visibility
                  mechanisms in mainstream OO languages, we introduce
                  our approach in terms of a simple model, and we
                  evaluate how our approach compares with existing
                  approaches. We also assess the impact of
                  incorporating encapsulation policies into Smalltalk
                  and discuss some implementation issues.},
  annote = {internationalconference topconference},
  author = {Nathanael Sch\"arli and St\'ephane Ducasse and Oscar
                  Nierstrasz and Roel Wuyts},
  booktitle = {Proceedings of European Conference on
                  Object-Oriented Programming (ECOOP'04)},
  cvs = {EncapsulationPoliciesECOOP2004},
  doi = {10.1007/b98195},
  isbn = {978-3-540-22159-3},
  keywords = {snf04 scg-pub jb04 scg-traits stefPub schaerli},
  misc = {acceptance rate: 25/132 = 19\%},
  accepttotal = {132},
  acceptnum = {25},
  month = jun,
  pages = {26--50},
  publisher = {Springer Verlag},
  series = {LNCS},
  title = {Composable Encapsulation Policies},
  url = {http://scg.unibe.ch/archive/papers/Scha04aEncapsulationPolicies.pdf},
  volume = {3086},
  year = {2004},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Scha04aEncapsulationPolicies.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1007/b98195}
}

@inproceedings{Scha04b,
  abstract = {Encapsulation in object-oriented languages has
                  traditionally been based on static type systems. As
                  a consequence, dynamically-typed languages have only
                  limited support for encapsulation. This is
                  surprising, considering that encapsulation is one of
                  the most fundamental and important concepts behind
                  object-oriented programming and that it is essential
                  for writing programs that are maintainable and
                  reliable, and that remain robust as they evolve. In
                  this paper we describe the problems that are caused
                  by insufficient encapsulation mechanisms and then
                  present object-oriented encapsulation, a simple and
                  uniform approach that solves these problems by
                  bringing state of the art encapsulation features to
                  dynamically typed languages. We provide a detailed
                  discussion of our design rationales and compare them
                  and their consequences to the encapsulation
                  approaches used for statically typed languages. We
                  also describe an implementation of object-oriented
                  encapsulation in Smalltalk. Benchmarks show that
                  extensive use of objectoriented encapsulation
                  results in a slowdown of less than 15 per cent.},
  annote = {internationalconference topconference},
  author = {Nathanael Sch\"arli and Andrew P. Black and
                  St\'ephane Ducasse},
  booktitle = {Proceedings of 18th International Conference on
                  Object-Oriented Programming Systems, Languages and
                  Applications (OOPSLA'04)},
  cvs = {OOEncapsulationOOPSLA2004},
  doi = {10.1145/1028976.1028988},
  keywords = {snf05 scg-pub jb03 scg-traits stefPub schaerli},
  misc = {acceptance rate: 27/174 = 16\%},
  accepttotal = {174},
  acceptnum = {27},
  month = oct,
  pages = {130--149},
  title = {Object-oriented Encapsulation for Dynamically Typed
                  Languages},
  url = {http://scg.unibe.ch/archive/papers/Scha04bOOEncapsulation.pdf},
  year = {2004},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Scha04bOOEncapsulation.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1145/1028976.1028988}
}

@inproceedings{Seeb06b,
  abstract = {To understand a certain issue of the system we want
                  to ask the knowledgeable developers. Yet, in large
                  systems, not every developer is knowledgeable in all
                  the details of the system. Thus, we would want to
                  know which developer is knowledgeable in the issue
                  at hand. In this paper we present the Chronia tool
                  that implements the Ownership Map visu- alization to
                  understand when and how different developers
                  interacted in which way and in which part of the
                  system. circle reflects the size of the change, and
                  the color of the line denotes the author who owns
                  most of the lines of code of the file in that
                  period. File A commit by the green author followed
                  by the ownership file removed by the blue author
                  file present from the first import},
  annote = {tooldemo},
  author = {Mauricio Seeberger and Adrian Kuhn and Tudor G\^irba
                  and St\'ephane Ducasse},
  booktitle = {Proceedings of 10th European Conference on Software
                  Maintenance and Reengineering (CSMR'06)},
  cvs = {ChroniaDemoCSMR2006},
  keywords = {scg-misc moose-pub stefPub recast06 jb06 fb06 girba
                  chronia},
  month = mar,
  note = {Tool demo},
  pages = {345--346},
  title = {{Chronia}: Visualizing How Developers Change
                  Software Systems},
  url = {http://scg.unibe.ch/archive/papers/Seeb06bChronia.pdf},
  year = {2006},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Seeb06bChronia.pdf}
}

@inproceedings{Sous04a,
  author    = {Kleiber D. de Sousa and
               Nicolas Anquetil and
               K{\'a}thia Mar\c{c}al de Oliveira},
  title     = {Learning Software Maintenance Organizations},
  booktitle = {Advances in Learning Software Organizations, 6th International
               Workshop, LSO 2004},
  year      = {2004},
  pages     = {67-77},
  publisher = {Springer},
  series    = {Lecture Notes in Computer Science},
  volume    = {3096},
  isbn      = {3-540-22192-1},
  annote = {internationalworkshop},
 aeres = {ACT},
 selectif = {oui},
 labo = {non},
 x-editorial-board = {yes},
 x-international-audience = {yes},
 x-pays = {BR}
}

@inproceedings{Souz05a,
  author    = {Sergio Cozzetti B. de Souza and
               Nicolas Anquetil and
               K{\'a}thia Mar\c{c}al de Oliveira},
  title     = {A study of the documentation essential to software maintenance},
  booktitle = {Proceedings of the 23rd Annual International Conference
               on Design of Communication: documenting {\&} Designing
               for Pervasive Information, SIGDOC 2005},
  year      = {2005},
  pages     = {68-75},
  publisher = {ACM},
  isbn      = {1-59593-175-9},
  doi       = {10.1145/1085313.1085331},
  annote = {internationalconference},
 aeres = {ACT},
 selectif = {oui},
 labo = {non},
 x-editorial-board = {yes},
 x-international-audience = {yes},
 x-pays = {BR}
}

@article{Souz06a,
  author = {Souza, Sergio Cozzetti B. de and Anquetil, Nicolas and Oliveira, K\'{a}thia M. de},
  title = {Which documentation for software maintenance?},
  journal = {Journal of the Brazilian Computer Society},
  issn = {0104-6500},
  year = {2006},
  pages = {31--44},
 annote = {nationaljournal},
  aeres = {ACLN},
 selectif = {oui},
 labo = {non},
 x-editorial-board = {yes},
 x-international-audience = {no},
 x-pays = {BR}
}

@misc{Stin05a,
  aeres = {OV},
  annote = {vulgarisation},
  author = {Serge Stinckwich and St\'ephane Ducasse},
  inria = {hors},
  journal = {Linux Pratique},
  keywords = {stefPub jb05},
  month = nov,
  number = 32,
  pages = {18--23},
  selectif = {non},
  title = {La syntaxe Smalltalk},
  volume = 1,
  year = {2005}
}

@misc{Stin06a,
  aeres = {OV},
  annote = {vulgarisation},
  author = {Serge Stinckwich and St\'ephane Ducasse},
  inria = {hors},
  journal = {Linux Pratique},
  keywords = {stefPub jb05},
  month = jan,
  number = 33,
  pages = {18--23},
  selectif = {non},
  title = {Les structures de contr\^ole en Smalltalk},
  volume = 1,
  year = {2006}
}

@misc{Stin06b,
  aeres = {OV},
  annote = {vulgarisation},
  author = {Serge Stinckwich and Hilaire Fernandes},
  inria = {hors},
  journal = {Linux Magazine},
  month = jun,
  number = 84,
  pages = {18--23},
  selectif = {non},
  title = {Nos premi\`eres classes en Smalltalk},
  volume = 1,
  year = {2006}
}

@inproceedings{Suen07a,
  annote = {internationalworkshop stefPub},
  author = {Mathieu Suen and St\'ephane Ducasse and Damien
                  Pollet and Hani Abdeen and Ilham Alloui},
  booktitle = {FAMOOSr, 1st Workshop on FAMIX and Moose in
                  Reengineering},
  keywords = {moose-pub},
  title = {Package Surface Blueprint: A Software Map},
  year = {2007}
}

@inproceedings{Suny01a,
  address = {Toronto, Canada},
  annote = {internationalconference},
  author = {Suny\'e, Gerson and Pollet, Damien and Le~Traon, Yves and J\'ez\'equel, Jean-Marc},
  booktitle = {UML~2001 --- The Unified Modeling Language --- Modeling Languages, Concepts, and Tools},
  editor = {Gogolla, Martin and Kobryn, Cris},
  isbn = {3-540-42667-1},
  month = oct,
  pages = {134--148},
  publisher = {Springer Verlag},
  series = {LNCS},
  title = {Refactoring UML Models},
  url = {http://www.irisa.fr/triskell/publis/2001/Sunye01b.pdf},
  volume = {2185},
  year = {2001},
  bdsk-url-1 = {http://www.irisa.fr/triskell/publis/2001/Sunye01b.pdf}
}

@techreport{Tant05a,
  aeres = {ACT},
  author = {{\'E}ric Tanter and Kris Gybels and Marcus Denker and Alexandre Bergel},
  inria = {hors},
  keywords = {fromscgbib marcusdenker},
  institution = {University of Chile},
  note = {published to Software Composition (SC'06)},
  number = {TR/DCC-2005-12},
  selectif = {non},
  title = {Context-aware aspects},
  year = {2005}
}

@inproceedings{Tant06a,
  abstract = {Context-aware applications behave differently
                  depending on the context in which they are running.
                  Since context-specific behavior tends to crosscut
                  base programs, it can advantageously be implemented
                  as aspects. This leads to the notion of
                  context-aware aspects, e.g., aspects whose behavior
                  depends on context. This paper analyzes the issue of
                  appropriate support from the aspect language to both
                  restrict the scope of aspects according to the
                  context and allow aspect definitions to access
                  information associated to the context. We propose an
                  open framework for context-aware aspects that allows
                  for the definition of first-class contexts and
                  supports the definition of context awareness
                  constructs for aspects, including the ability to
                  refer to past contexts, and to provide domain- and
                  application-specific constructs.},
  address = {Vienna, Austria},
  aeres = {ACT},
  annote = {internationalconference},
  author = {{\'E}ric Tanter and Kris Gybels and Marcus Denker and Alexandre Bergel},
  booktitle = {Proceedings of the 5th International Symposium on Software Composition (SC 2006)},
  doi = {10.1007/11821946_15},
  inria = {hors},
  isbn = {978-3-540-37657-6},
  keywords = {scg-pub jb06 fb06 snf06 fromscgbib marcusdenker},
  medium = {2},
  month = mar,
  pages = {227--242},
  peerreview = {yes},
  selectif = {non},
  series = {LNCS},
  title = {Context-Aware Aspects},
  url = {http://rmod.lille.inria.fr/archives/papers/Tant06a-SC06-ContextAspects.pdf},
  volume = {4089},
  year = {2006}
}



@inproceedings{Tich00b,
  abstract = {Refactoring --- transforming code while preserving
                  behaviour --- is currently considered a key approach
                  for improving object-oriented software systems.
                  Unfortunately, all of the current refactoring tools
                  depend on language-dependent refactoring engines,
                  which prevents a smooth integration with mainstream
                  development environments. In this paper we
                  investigate the similarities between refactorings
                  for Smalltalk and {Java}, derive a
                  language-independent meta-model and show that it is
                  feasible to build a language-independent refactoring
                  engine on top of this meta-model. Our feasibility
                  study is validated by means of a tool prototype
                  which uses the same engine to refactor both
                  Smalltalk and {Java} code. Using our approach we
                  minimize the language-dependent part of refactoring
                  tools, providing a standard way for programmers and
                  tools to perform refactorings no matter what
                  language they work in.},
  annote = {internationalconference},
  author = {Sander Tichelaar and St\'ephane Ducasse and Serge Demeyer and Oscar Nierstrasz},
  booktitle = {Proceedings of International Symposium on Principles of Software Evolution (ISPSE '00)},
  doi = {10.1109/ISPSE.2000.913233},
  keywords = {reengineering refactoring FAMIX repositories
                  mooseCincom tich-papref scg-pub jb00 snf01 stePub
                  moose-pub},
  misc = {acceptance rate: 22/51 = 43\%},
  accepttotal = {51},
  acceptnum = {22},
  pages = {157--167},
  publisher = {IEEE Computer Society Press},
  title = {A Meta-model for Language-Independent Refactoring},
  url = {http://scg.unibe.ch/archive/papers/Tich00bRefactoringMetamodel.pdf},
  year = {2000},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Tich00bRefactoringMetamodel.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1109/ISPSE.2000.913233}
}

@inproceedings{Tich00m,
  abstract = {In the FAMOOS project we have developed a set of
                  tools for reengineering object-oriented legacy
                  systems. These tools are based on the FAMIX meta
                  model and exchange information using CDIF, an
                  industry standard exchange format. For several
                  reasons XMI, an emerging standard for information
                  exchange, has appealed to us to be used as our
                  interchange format. In this paper we discuss why XMI
                  is interesting for us and what, to our current
                  experience, are the advantages and disadvantages of
                  XMI over CDIF.},
  annote = {internationalworkshop},
  author = {Sander Tichelaar and St\'ephane Ducasse and Serge Demeyer},
  booktitle = {Proceedings of the ICSE 2000 Workshop on Standard Exchange Format (WoSEF 2000)},
  keywords = {components scg-pub skip-doi snf00 jb00 stefPub moose-pub},
  month = jun,
  title = {{FAMIX}: Exchange Experiences with {CDIF} and {XMI}},
  url = {http://scg.unibe.ch/archive/papers/Tich00mFamixCdifXmi.pdf},
  year = {2000},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Tich00mFamixCdifXmi.pdf}
}

@inproceedings{Tich00n,
  abstract = {Recently exchange formats have gained lots of
                  attention. Multiple tools need to interact and/or
                  work on the same software system. Especially there
                  is a need to reuse parser technology. Within the
                  FAMOOS project we have developed a model for
                  representing object-oriented software systems at the
                  program entity level. The model has been designed
                  for language independence, extensibility and
                  information exchange. For the actual exchange of
                  data we are currently moving to use XMI, a standard
                  for model-based information exchange.},
  address = {Los Alamitos CA},
  annote = {internationalworkshop},
  author = {Sander Tichelaar and St\'ephane Ducasse and Serge
                  Demeyer},
  booktitle = {Proceedings WCRE 2000 Workshop on Exchange Formats},
  doi = {10.1109/WCRE.2000.891485},
  keywords = {components scg-pub tich-papunr sergedem-papunr snf00
                  jb00 stefPub moose-pub},
  month = nov,
  pages = {296--296},
  publisher = {IEEE Computer Society Press},
  title = {{FAMIX} and {XMI}},
  url = {http://scg.unibe.ch/archive/papers/Tich00nFamixWCRE2000.pdf},
  year = {2000},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Tich00nFamixWCRE2000.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1109/WCRE.2000.891485}
}

@techreport{Tich01y,
  annote = {report notrefereed},
  author = {Sander Tichelaar and St\'ephane Ducasse},
  institution = {Institute of Computer Science and Applied Mathematics},
  note = {University of Bern, IAM-TR-09-01},
  title = {Pull Up/Push Down Method: an Analysis},
  year = {2001}
}

@inproceedings{Tich97b,
  abstract = {In this workshop proposal we present a prototype
                  approach to help the extraction of architectural
                  information in the re-engineering process. Commonly,
                  the re-engineering life-cycle has been defined as a
                  succession of the following tasks: analysis of
                  requirements, model capture (understanding the
                  system), problem detection, problem analysis,
                  reorganization and change propagation. We have
                  evaluated the benefit of a prototyping approach with
                  a focus on model capture. Although prototyping is a
                  known approach to evaluate the application
                  feasibility, costs, comparison and validation of
                  choices, we focus in this paper on the aspects of
                  prototyping that are helpful for re-engineering.},
  annote = {internationalworkshop},
  author = {Sander Tichelaar and St\'ephane Ducasse and Theo-Dirk Meijler},
  booktitle = {Proceedings of the ESEC/FSE Workshop on Object-Oriented Re-engineering},
  editor = {Serge Demeyer and Harald Gall},
  keywords = {olit famoos-papunr tich-papunr scglit oobib scg-pub
                  skip-doi snf97 jb97 stePub},
  month = sep,
  note = {Technical Report TUV-1841-97-10},
  publisher = {Technical University of Vienna, Information Systems
                  Institute, Distributed Systems Group},
  title = {Architectural Extraction In Reverse Engineering by
                  Prototyping: An experiment},
  url = {http://scg.unibe.ch/archive/papers/Tich97bArchExtraction.pdf},
  year = {1997},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Tich97bArchExtraction.pdf}
}

@inproceedings{Uqui09b,
  address = {New York, NY, USA},
  author = {Uquillas G\'{o}mez, Ver\'{o}nica and Kellens, Andy and Brichau, Johan and D'Hondt, Theo},
  booktitle = {IWPSE-Evol '09: Proceedings of the joint international and annual ERCIM workshops on Principles of software evolution (IWPSE) and software evolution (Evol) workshops},
  doi = {10.1145/1595808.1595825},
  isbn = {978-1-60558-678-6},
  location = {Amsterdam, The Netherlands},
  pages = {79--88},
  publisher = {ACM},
  title = {Time warp, an approach for reasoning over system histories},
  year = {2009}
}

@inproceedings{Uqui10a,
  title = {Visually Supporting Source Code Changes Integration: the Torch Dashboard},
  author = {Uquillas G\'omez, Ver\'onica and St\'ephane Ducasse and Theo D'Hondt},
  booktitle = {Working Conference on Reverse Engineering (WCRE 2010)},
  year = {2010},
  annote = {internationalconference},
  keywords = {lse-pub},
  month = oct,
  inria = {RMOD},
  labo = {dans},
  inriareport = {2010},
  x-editorial-board = {yes},
  x-proceedings = {yes},
  x-international-audience = {yes},
  x-country = {BE},
  x-language = {EN},
  url = {http://rmod.lille.inria.fr/archives/papers/Uqui10a-Torch-WCRE10.pdf},
  abstract = {Automatic and advanced merging algorithms help programmers to merge their modifications in main development repositories. However, there is little support to help release masters (integrators) to take decisions about the integration of published merged changes into the system release. Most of the time, the release master has to read all the changed code, check the diffs to build an idea of a change, and read unchanged code to understand the context of some changes. Such a task can be overwhelming. In this paper we present a dashboard to support integrators getting an overview of proposed changes in the context of object-oriented programming. Our approach named Torch characterizes changes based on structural information, authors and symbolic information. It mixes text-based diff information with visual representation and metrics characterizing the changes. We describe our experiment applying it to Pharo, a large open-source system, and report on the evaluation of our approach by release masters of several open-source projects.},
  hal-id = {inria-00531508}
}

@inproceedings{Webs05a,
  author    = {Kenia P. Batista Webster and
               K{\'a}thia Mar\c{c}al de Oliveira and
               Nicolas Anquetil},
  title     = {A Risk Taxonomy Proposal for Software Maintenance},
  booktitle = {21st IEEE International Conference on Software Maintenance
               (ICSM 2005)},
  year      = {2005},
  pages     = {453-461},
  isbn      = {0-7695-2368-4},
  publisher = {IEEE Computer Society},
  doi       = {10.1109/ICSM.2005.14},
  annote = {internationalconference},
 aeres = {ACT},
 selectif = {oui},
 labo = {non},
 x-editorial-board = {yes},
 x-international-audience = {yes},
 x-pays = {BR}
}

@inproceedings{Weih05a,
  abstract = {We introduce Higher Order Messaging, a higher order
                  programming mechanism for dynamic object-oriented
                  languages. Higher Order Messages allow user-defined
                  message dispatch mechanism to be expressed using an
                  optimally compact syntax that is a natural extension
                  of plain messaging and also have a simple conceptual
                  model. They can be implemented without extending the
                  base language and operate through language bridges.},
  aeres = {ACT},
  aeresstatus = {aeres08},
  annote = {internationalconference},
  author = {Marcel Weiher and St\'ephane Ducasse},
  booktitle = {Proceedings of International Symposium on Dynamic Languages (SDL'05)},
  inria = {hors},
  keywords = {stefPub jb06 listic},
  pages = {23--34},
  publisher = {ACM Press},
  selectif = {non},
  title = {High-Order Messaging},
  url = {http://scg.unibe.ch/archive/papers/Weih05aHigherOrderMessagingOOPSLA2005.pdf},
  year = {2005},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Weih05aHigherOrderMessagingOOPSLA2005.pdf}
}

@inproceedings{Wint02a,
  abstract = {This paper presents a domain specific composition
                  language called CoCo. The CoCo language has been
                  developed in the context of the PECOS project which
                  aims at enabling component-based technology for a
                  certain class of embedded systems called "field
                  devices".},
  annote = {internationalworkshop},
  author = {Michael Winter and Thomas Gen{\ss}ler and Alexander
                  Christoph and Oscar Nierstrasz and St\'ephane
                  Ducasse and Roel Wuyts and Gabriela Ar{\'e}valo and
                  Peter M\"uller and Christian Stich and Bastiaan
                  Sch\"onhage},
  booktitle = {Proc. Second International Workshop on Composition
                  Languages},
  keywords = {olit skip-doi scg-pub jb-skip pecos stefPub arevalo},
  note = {In conjunction with 16th European Conference on
                  Object-Oriented Programming (ECOOP) Malaga, Spain,
                  June 11, 2002},
  title = {Components for Embedded Software --- The PECOS
                  Approach},
  url = {http://scg.unibe.ch/archive/pecos/public_documents/Wint02a.pdf},
  year = {2002},
  bdsk-url-1 = {http://scg.unibe.ch/archive/pecos/public_documents/Wint02a.pdf}
}

@inproceedings{Wuyt01a,
  abstract = {Meta-programming is the act of using one system or
                  language to reason about another one. Reflection
                  describes systems that have access to and change a
                  causally connected representation of themselves,
                  hence leading to self-extensible systems . Up to
                  now, most of the reflective languages have been
                  implemented in the same paradigm. In this paper, we
                  propose \emph{symbiotic reflection} as a way to
                  integrate a meta programming language with the
                  object-oriented language it reasons about and is
                  implemented in. New to this approach is that any
                  element of the implementation language can be
                  reasoned about and acted upon (not only the self
                  representation), and that both languages are of
                  different paradigms. Moreover, every language
                  implementer that is faced with the problem of
                  allowing the base language to access the underlying
                  meta-language has to solve the problem of enabling
                  entity transfer between both worlds. We propose a
                  uniform schema, called upping/downing, to this
                  problem that avoid explicit wrapping or
                  typechecking. We illustrate this with SOUL (the
                  Smalltalk Open Unification Language), a logic
                  programming language in symbiotic reflection with
                  the object-oriented language Smalltalk. We show how
                  SOUL does logic reasoning directly on Smalltalk
                  objects, and how to use this to implement type
                  snooping},
  annote = {internationalworkshop},
  author = {Roel Wuyts and St\'ephane Ducasse},
  booktitle = {ECOOP 2001 International Workshop on MultiParadigm
                  Programming with Object-Oriented Languages},
  keywords = {scg-pub skip-doi snf01 snf02 jb01 component Pecos
                  stefPub},
  title = {Symbiotic Reflection between an Object-Oriented and
                  a Logic Programming Language},
  url = {http://scg.unibe.ch/archive/papers/Wuyt01a.pdf},
  year = {2001},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Wuyt01a.pdf}
}

@inproceedings{Wuyt01c,
  abstract = {Supporting reuse of existing pieces of code is one
                  of the main goals of software engineering. In the
                  name of reuse, module-based programming languages
                  came to be, only to be surpassed by object-oriented
                  technology. With the same motivation component-based
                  solutions are overtaking object-oriented solutions.
                  However, the delegation-only focus of
                  component-based programming risks of resulting in
                  the same problems that modular-based approaches ran
                  into. To counter this, we claim that one of th e
                  important problems that should be addressed by
                  component languages is the composition of
                  components. More specifically, we see component
                  languages where components are black-box
                  abstractions, and with (one or more) composition
                  languages to glue them tog ether. As an example we
                  show a functional (Piccola) and a logic (QSoul)
                  composition approach.},
  annote = {internationalworkshop},
  author = {Roel Wuyts and St\'ephane Ducasse},
  booktitle = {First OOPSLA Workshop on Language Mechanisms for
                  Programming Software Components},
  keywords = {scg-pub skip-doi snf01 jb01 component piccola Pecos
                  stefPub},
  title = {Composition Languages for Black-Box Components},
  url = {http://scg.unibe.ch/archive/papers/Wuyt01c.pdf},
  year = {2001},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Wuyt01c.pdf}
}

@inproceedings{Wuyt01d,
  abstract = {This position paper presents some preliminary work
                  we made for applying declaractive component oriented
                  design in the context of embedded devices. We
                  quickly describes COMES the model we develop and
                  present how logic rules can be used to describe
                  architectures.},
  annote = {internationalworkshop},
  author = {Roel Wuyts and St\'ephane Ducasse and Gabriela
                  Ar{\'e}valo},
  booktitle = {Ecoop 6th International Workshop on
                  Component-Oriented Programming},
  keywords = {scg-pub skip-doi snf01 jb01 component Pecos stefPub
                  arevalo},
  title = {Applying Experiences with Declarative Codifications
                  of Software Architectures on COD},
  url = {http://scg.unibe.ch/archive/papers/Wuyt01d.pdf},
  year = {2001},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Wuyt01d.pdf}
}

@inproceedings{Wuyt01e,
  abstract = {In this paper we describe an interesting context to
                  study formal methods for component systems: embedded
                  devices. The context of embedded devices is highly
                  constrained by the physical requirements the devices
                  have to adhere to. As a result, component models for
                  embedded devices are not general purpose but geared
                  towards these constrained contexts. In this paper we
                  give the concrete setting of the Pecos project (a
                  project with as goal component engineering for
                  embedded devices). We describe the Pecos component
                  model, and show possibilities where we think formal
                  verification could be useful. We would like to use
                  this as a very concrete example to discuss formal
                  verification techniques.},
  annote = {internationalworkshop},
  author = {Roel Wuyts and St\'ephane Ducasse},
  booktitle = {International Workshop on Specification and
                  Verification of Component-Based Systems},
  keywords = {scg-pub skip-doi snf01 jb01 component Pecos stefPub},
  title = {Non-Functional Requirements in a Component Model for
                  Embedded Systems},
  url = {http://scg.unibe.ch/archive/papers/Wuyt01e.pdf},
  year = {2001},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Wuyt01e.pdf}
}

@article{Wuyt04a,
  abstract = {The increasing complexity of software development
                  spawns lots of specialised tools to edit code,
                  employ UML schemes, integrate documentation, and so
                  on. The problem is that the tool builders themselves
                  are responsible for making their tools interoperable
                  with other tools or development environments.
                  Because they cannot anticipate all other tools they
                  can integrate with, a lot of tools cannot
                  co-operate. This paper introduces the classication
                  model, a lightweight integration medium that enables
                  unrelated tools that were not meant to be integrated
                  to cooperate easily. Moreover, the tool integration
                  is done by a tool integrator, and not by the tool
                  builder. To validate this claim, we show how to
                  integrate several third-party tools using the
                  classication model, and how it forms the foundation
                  for the StarBrowser, a Smalltalk browser integrating
                  different tools.},
  annote = {internationaljournal},
  author = {Roel Wuyts and St\'ephane Ducasse},
  doi = {10.1016/j.cl.2003.08.003},
  journal = {Journal of Computer Languages, Systems and Structures},
  keywords = {recast04 scg-pub jb04 decomp-pub},
  impactfactor = {5 Year ISI impact factor 0.698 (2010)},
  misc = {5 Year ISI impact factor 0.698 (2010)},
  number = {1-2},
  pages = {63--77},
  publisher = {Elsevier},
  title = {Unanticipated Integration of Development Tools using the Classification Model},
  url = {http://scg.unibe.ch/archive/papers/Wuyt04aClassifications.pdf},
  volume = {30},
  year = {2004},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Wuyt04aClassifications.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1016/j.cl.2003.08.003}
}

@inproceedings{Wuyt04x,
  abstract = {This paper reports on the results of the Fifth
                  International Workshop on Object-Oriented
                  Reengineering in Oslo on June 15, 2004. It
                  enumerates the presentations made, classifies the
                  contributions and lists the main results of the
                  discussions held at the workshop. As such it
                  provides the context for future workshops around
                  this topic.},
  annote = {workshopproceedings},
  author = {Roel Wuyts and Serge Demeyer and St\'ephane Ducasse
                  and Kim Mens},
  booktitle = {Object-Oriented Technology. ECOOP'04 Workshop
                  Reader},
  doi = {10.1007/b104146},
  isbn = {978-3-540-23988-8},
  keywords = {scg-pub jb04 stefPub recast04},
  pages = {177--186},
  publisher = {Springer-Verlag},
  series = {LNCS},
  title = {Report of the {ECOOP}'04 Workshop on Object-Oriented
                  Reengineering},
  url = {http://scg.unibe.ch/archive/papers/Wuyt04x-OOR04Report.pdf},
  volume = {3344},
  year = {2004},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Wuyt04x-OOR04Report.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1007/b104146}
}

@article{Wuyt05a,
  abstract = {Software for embedded systems must cope with a
                  variety of stringent constraints, such as real-time
                  requirements, small memory footprints, and low power
                  consumption. It is usually implemented using
                  low-level programming languages, and as a result has
                  not benefitted from component-based software
                  development techniques. This paper describes a
                  \emph{data-centric component model} for embedded
                  devices that (i) minimizes the number of concurrent
                  tasks needed to implement the system, (ii) allows
                  one to verify whether components meet their
                  deadlines by applying Rate Monotonic Analysis (RMA),
                  and (iii) can generate and verify schedules using
                  Constraint Logic Programming (CLP). This model forms
                  the foundation for a suite of tools for specifying,
                  composing, verifying and deploying embedded software
                  components developed in the context of the \pecos
                  project.},
  aeres = {ACL},
  aeresstatus = {aeres08},
  annote = {internationaljournal},
  author = {Roel Wuyts and St\'ephane Ducasse and Oscar
                  Nierstrasz},
  cvs = {PecosJournalPaper},
  doi = {10.1016/j.jss.2003.05.004},
  inria = {hors},
  journal = {Journal of Systems and Software --- Special Issue on
                  Automated Component-Based Software Engineering},
  keywords = {scg-pub jb03 pecos stefPub},
  misc = {SCI impact factor 0.744},
  number = {1},
  pages = {25--34},
  publisher = {Elsevier},
  title = {A Data-centric Approach to Composing Embedded,
                  Real-time Software Components},
  url = {http://scg.unibe.ch/archive/papers/Wuyt05aPecosElsevier.pdf},
  volume = {74},
  year = {2005},
  bdsk-url-1 = {http://scg.unibe.ch/archive/papers/Wuyt05aPecosElsevier.pdf},
  bdsk-url-2 = {http://dx.doi.org/10.1016/j.jss.2003.05.004}
}

@inproceedings{Wuyt07a,
  aeres = {OV},
  aeresstatus = {aeres08},
  annote = {workshopproceedings},
  author = {Roel Wuyts and Serge Demeyer and Yann-Ga\"el Gu\'e{e}h\'{e}neuc and Kim Mens and St\'ephane Ducasse},
  booktitle = {Object-Oriented Technology. ECOOP'06 Workshop  Reader},
  inria = {hors},
  keywords = {stefPub},
  pages = {69--71},
  publisher = {Springer-Verlag},
  series = {LNCS},
  title = {Report of the 7th ECOOP'06 Workshop on
                  Object-Oriented Reengineering},
  url = {http://www.info.ucl.ac.be/~km/MyResearchPages/publications/workshop_report/WR_2007_ECOOP2006_WOOR.pdf},
  year = {2007}
}


@inproceedings{Mart10a,
  annote = {internationalworkshop},
  author = {Martinez Peck, Mariano and Noury Bouraqadi and Marcus Denker and St\'ephane Ducasse and Luc Fabresse},
  booktitle = {Smalltalks 2010},
  keywords = {moose-pub stefPub lse-pub marcusdenker},
  title = {Visualizing Objects and Memory Usage},
  year = {2010},
  abstract = {Most of the current garbage collector implementations work by reachability. This means they only take care of the objects that nobody else points to. As a consequence, there are objects which are not really used but are not garbage collected because they are still referenced. Such unused but reachable objects create memory leaks. This is a problem because applications use much more memory than what is actually needed. In addition, they may get slower and crash. It is important to understand which parts of the system are instantiated but also which are used or unused. There is a plethora of work on runtime information or class instantiation visualizations but none of them show whether instances are actually used. Such information is important to identify memory leaks.
In this paper, we present some visualizations that show used/unused objects in object-oriented applications. For this, we use Distribution Map which is a visualization showing spread and focus of properties across systems. We extend Distribution Maps to represent the way classes are used or not, since we distinguish between a class that just has instances from one that has used instances. To identify unused objects, we modified the Pharo Virtual Machine.},
  aeresstatus = {aeres12},
  aeres = {COM},
  inria = {RMOD},
  x-editorial-board = {yes},
  x-proceedings = {yes},
  inriareport  = {2010},
  x-international-audience = {yes},
  url = {http://rmod.lille.inria.fr/archives/workshops/Mart10a-Smalltalks2010-VisualizingUnusedObjects.pdf},
  hal-id = {inria-00531510}
}

@inproceedings{Mart10b,
  annote = {internationalworkshop},
  author = {Martinez Peck, Mariano and Noury Bouraqadi and Marcus Denker and St\'ephane Ducasse and Luc Fabresse},
  booktitle = {Smalltalks 2010},
  keywords = {moose-pub stefPub lse-pub marcusdenker},
  title = {Experiments with a Fast Object Swapper},
  year = {2010},
  abstract = {In object-oriented systems, runtime memory is composed of an object graph in which objects refer to other objects. This graph of objects evolves while the system is running. Graph exporting and swapping are two important object graph operations. Exporting refers to copying the graph to some other memory so that it can be loaded by another system. Swapping refers to moving the graph to a secondary memory (e.g., a hard disk) to temporary release part of the primary memory.
While exporting and swapping are achieved in different ways, each of them faces a common and central problem which is the speed of the approach in presence of large object graphs. Nevertheless, most of the existing solutions do not address well this issue. Another challenge is to deal with extremely common situations where objects outside the exported/swapped graph point to objects inside the graph. To correctly load back an exported subgraph, it is necessary to compute and export extra information that is not explicit in the object subgraph. This extra information is needed because certain objects may require to be reinitialized or recreated, to run specific code before or after the loading, to be updated to a new class definition, etc.
In this paper, we present most of the general problems of object exporting and swapping. As a case of study, we present an analysis of ImageSegment, a fast solution to export and swap object graphs, developed by Dan Ingalls. ImageSegment addresses the speed problems in an efficient way, as shown by the results of several benchmarks we have conducted using Pharo Smalltalk. However, ImageSegment is not a panacea since it still has other problems that hampers its general use.},
  aeresstatus = {aeres12},
  aeres = {COM},
  inria = {RMOD},
  x-editorial-board = {yes},
  x-proceedings = {yes},
  inriareport  = {2010},
  x-international-audience = {yes},
    url = {http://rmod.lille.inria.fr/archives/workshops/Mart10b-Smalltalks2010-Swapper-ImageSegments.pdf},
  hal-id = {inria-00531565}
 }


@inproceedings{Uqui10b,
  annote = {internationalworkshop},
  author = {Uquillas G\'omez, Ver\'onica and St\'ephane Ducasse and Theo D'Hondt},
  booktitle = {Smalltalks'2010},
  keywords = {moose-pub stefPub lse-pub},
  title = {Meta-models and Infrastructure for Smalltalk Omnipresent History},
  year = {2010},
  abstract = {Source code management systems record different versions of code. Tool support can then com- pute deltas between versions. However there is little support to be able to perform history-wide queries and analysis: for example building slices of changes and identifying their differences since the beginning of the project. We believe that this is due to the lack of a powerful code meta- model as well as an infrastructure. For example, in Smalltalk often several source code meta- models coexist: the Smalltalk reflective API coexists with the one of the Refactoring engine or distributed versioning system. While having specific meta-models is an engineered solution, it hampers meta-models manipulation as it requires more maintenance efforts (e.g., duplication of tests, transformation between models), and more importantly navigation tool reuse. As a first step to solve this problem, this article presents several source code models that could be used to support several activities and proposes an unified and layered approach to be the foundation for building an infrastructure for omnipresent version browsing.},
  aeresstatus = {aeres12},
  aeres = {COM},
  inria = {RMOD},
  x-editorial-board = {yes},
  x-proceedings = {yes},
  inriareport  = {2010},
  x-international-audience = {yes},
  url = {http://rmod.lille.inria.fr/archives/workshops/Uqui10b-Smalltalk2010-Metamodels.pdf},
  hal-id = {inria-00531613}
 }

